{"ast":null,"code":"import _get from \"/Users/ntws2/Dropbox/htdocs/ECCPEC_code/SITE_VERSIONS/ECPPEC/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/ntws2/Dropbox/htdocs/ECCPEC_code/SITE_VERSIONS/ECPPEC/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _createForOfIteratorHelper from \"/Users/ntws2/Dropbox/htdocs/ECCPEC_code/SITE_VERSIONS/ECPPEC/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _inherits from \"/Users/ntws2/Dropbox/htdocs/ECCPEC_code/SITE_VERSIONS/ECPPEC/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/ntws2/Dropbox/htdocs/ECCPEC_code/SITE_VERSIONS/ECPPEC/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _toConsumableArray from \"/Users/ntws2/Dropbox/htdocs/ECCPEC_code/SITE_VERSIONS/ECPPEC/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/ntws2/Dropbox/htdocs/ECCPEC_code/SITE_VERSIONS/ECPPEC/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/ntws2/Dropbox/htdocs/ECCPEC_code/SITE_VERSIONS/ECPPEC/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { SelectionModel, isDataSource } from '@angular/cdk/collections';\nimport { Observable, BehaviorSubject, of, Subject } from 'rxjs';\nimport { take, filter, takeUntil } from 'rxjs/operators';\nimport { Directive, Inject, InjectionToken, Optional, ViewContainerRef, TemplateRef, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, ElementRef, Input, IterableDiffers, ViewChild, ViewEncapsulation, Renderer2, HostListener, NgModule } from '@angular/core';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceNumberProperty, coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Base tree control. It has basic toggle/expand/collapse operations on a single data node.\n * @abstract\n * @template T\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/bidi';\n\nvar BaseTreeControl = /*#__PURE__*/function () {\n  function BaseTreeControl() {\n    _classCallCheck(this, BaseTreeControl);\n\n    /**\n     * A selection model with multi-selection to track expansion status.\n     */\n    this.expansionModel = new SelectionModel(true);\n  }\n  /**\n   * Toggles one single data node's expanded/collapsed state.\n   * @param {?} dataNode\n   * @return {?}\n   */\n\n\n  _createClass(BaseTreeControl, [{\n    key: \"toggle\",\n    value: function toggle(dataNode) {\n      this.expansionModel.toggle(dataNode);\n    }\n    /**\n     * Expands one single data node.\n     * @param {?} dataNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"expand\",\n    value: function expand(dataNode) {\n      this.expansionModel.select(dataNode);\n    }\n    /**\n     * Collapses one single data node.\n     * @param {?} dataNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"collapse\",\n    value: function collapse(dataNode) {\n      this.expansionModel.deselect(dataNode);\n    }\n    /**\n     * Whether a given data node is expanded or not. Returns true if the data node is expanded.\n     * @param {?} dataNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"isExpanded\",\n    value: function isExpanded(dataNode) {\n      return this.expansionModel.isSelected(dataNode);\n    }\n    /**\n     * Toggles a subtree rooted at `node` recursively.\n     * @param {?} dataNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"toggleDescendants\",\n    value: function toggleDescendants(dataNode) {\n      this.expansionModel.isSelected(dataNode) ? this.collapseDescendants(dataNode) : this.expandDescendants(dataNode);\n    }\n    /**\n     * Collapse all dataNodes in the tree.\n     * @return {?}\n     */\n\n  }, {\n    key: \"collapseAll\",\n    value: function collapseAll() {\n      this.expansionModel.clear();\n    }\n    /**\n     * Expands a subtree rooted at given data node recursively.\n     * @param {?} dataNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandDescendants\",\n    value: function expandDescendants(dataNode) {\n      var _this$expansionModel;\n\n      /** @type {?} */\n      var toBeProcessed = [dataNode];\n      toBeProcessed.push.apply(toBeProcessed, _toConsumableArray(this.getDescendants(dataNode)));\n\n      (_this$expansionModel = this.expansionModel).select.apply(_this$expansionModel, toBeProcessed);\n    }\n    /**\n     * Collapses a subtree rooted at given data node recursively.\n     * @param {?} dataNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"collapseDescendants\",\n    value: function collapseDescendants(dataNode) {\n      var _this$expansionModel2;\n\n      /** @type {?} */\n      var toBeProcessed = [dataNode];\n      toBeProcessed.push.apply(toBeProcessed, _toConsumableArray(this.getDescendants(dataNode)));\n\n      (_this$expansionModel2 = this.expansionModel).deselect.apply(_this$expansionModel2, toBeProcessed);\n    }\n  }]);\n\n  return BaseTreeControl;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Flat tree control. Able to expand/collapse a subtree recursively for flattened tree.\n * @template T\n */\n\n\nvar FlatTreeControl = /*#__PURE__*/function (_BaseTreeControl) {\n  _inherits(FlatTreeControl, _BaseTreeControl);\n\n  var _super = _createSuper(FlatTreeControl);\n\n  /**\n   * Construct with flat tree data node functions getLevel and isExpandable.\n   * @param {?} getLevel\n   * @param {?} isExpandable\n   */\n  function FlatTreeControl(getLevel, isExpandable) {\n    var _this;\n\n    _classCallCheck(this, FlatTreeControl);\n\n    _this = _super.call(this);\n    _this.getLevel = getLevel;\n    _this.isExpandable = isExpandable;\n    return _this;\n  }\n  /**\n   * Gets a list of the data node's subtree of descendent data nodes.\n   *\n   * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes\n   * with correct levels.\n   * @param {?} dataNode\n   * @return {?}\n   */\n\n\n  _createClass(FlatTreeControl, [{\n    key: \"getDescendants\",\n    value: function getDescendants(dataNode) {\n      /** @type {?} */\n      var startIndex = this.dataNodes.indexOf(dataNode);\n      /** @type {?} */\n\n      var results = []; // Goes through flattened tree nodes in the `dataNodes` array, and get all descendants.\n      // The level of descendants of a tree node must be greater than the level of the given\n      // tree node.\n      // If we reach a node whose level is equal to the level of the tree node, we hit a sibling.\n      // If we reach a node whose level is greater than the level of the tree node, we hit a\n      // sibling of an ancestor.\n\n      for (var i = startIndex + 1; i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]); i++) {\n        results.push(this.dataNodes[i]);\n      }\n\n      return results;\n    }\n    /**\n     * Expands all data nodes in the tree.\n     *\n     * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened\n     * data nodes of the tree.\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandAll\",\n    value: function expandAll() {\n      var _this$expansionModel3;\n\n      (_this$expansionModel3 = this.expansionModel).select.apply(_this$expansionModel3, _toConsumableArray(this.dataNodes));\n    }\n  }]);\n\n  return FlatTreeControl;\n}(BaseTreeControl);\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Nested tree control. Able to expand/collapse a subtree recursively for NestedNode type.\n * @template T\n */\n\n\nvar NestedTreeControl = /*#__PURE__*/function (_BaseTreeControl2) {\n  _inherits(NestedTreeControl, _BaseTreeControl2);\n\n  var _super2 = _createSuper(NestedTreeControl);\n\n  /**\n   * Construct with nested tree function getChildren.\n   * @param {?} getChildren\n   */\n  function NestedTreeControl(getChildren) {\n    var _this2;\n\n    _classCallCheck(this, NestedTreeControl);\n\n    _this2 = _super2.call(this);\n    _this2.getChildren = getChildren;\n    return _this2;\n  }\n  /**\n   * Expands all dataNodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all root level\n   * data nodes of the tree.\n   * @return {?}\n   */\n\n\n  _createClass(NestedTreeControl, [{\n    key: \"expandAll\",\n    value: function expandAll() {\n      var _this3 = this,\n          _this$expansionModel4;\n\n      this.expansionModel.clear();\n      /** @type {?} */\n\n      var allNodes = this.dataNodes.reduce(\n      /**\n      * @param {?} accumulator\n      * @param {?} dataNode\n      * @return {?}\n      */\n      function (accumulator, dataNode) {\n        return [].concat(_toConsumableArray(accumulator), _toConsumableArray(_this3.getDescendants(dataNode)), [dataNode]);\n      }, []);\n\n      (_this$expansionModel4 = this.expansionModel).select.apply(_this$expansionModel4, _toConsumableArray(allNodes));\n    }\n    /**\n     * Gets a list of descendant dataNodes of a subtree rooted at given data node recursively.\n     * @param {?} dataNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"getDescendants\",\n    value: function getDescendants(dataNode) {\n      /** @type {?} */\n      var descendants = [];\n\n      this._getDescendants(descendants, dataNode); // Remove the node itself\n\n\n      return descendants.splice(1);\n    }\n    /**\n     * A helper function to get descendants recursively.\n     * @protected\n     * @param {?} descendants\n     * @param {?} dataNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"_getDescendants\",\n    value: function _getDescendants(descendants, dataNode) {\n      var _this4 = this;\n\n      descendants.push(dataNode);\n      /** @type {?} */\n\n      var childrenNodes = this.getChildren(dataNode);\n\n      if (Array.isArray(childrenNodes)) {\n        childrenNodes.forEach(\n        /**\n        * @param {?} child\n        * @return {?}\n        */\n        function (child) {\n          return _this4._getDescendants(descendants, child);\n        });\n      } else if (childrenNodes instanceof Observable) {\n        // TypeScript as of version 3.5 doesn't seem to treat `Boolean` like a function that\n        // returns a `boolean` specifically in the context of `filter`, so we manually clarify that.\n        childrenNodes.pipe(take(1), filter(\n        /** @type {?} */\n        Boolean)).subscribe(\n        /**\n        * @param {?} children\n        * @return {?}\n        */\n        function (children) {\n          var _iterator = _createForOfIteratorHelper(children),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var child = _step.value;\n\n              _this4._getDescendants(descendants, child);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        });\n      }\n    }\n  }]);\n\n  return NestedTreeControl;\n}(BaseTreeControl);\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Injection token used to provide a `CdkTreeNode` to its outlet.\n * Used primarily to avoid circular imports.\n * \\@docs-private\n * @type {?}\n */\n\n\nvar CDK_TREE_NODE_OUTLET_NODE = new InjectionToken('CDK_TREE_NODE_OUTLET_NODE');\n/**\n * Outlet for nested CdkNode. Put `[cdkTreeNodeOutlet]` on a tag to place children dataNodes\n * inside the outlet.\n */\n\nvar CdkTreeNodeOutlet =\n/**\n * @param {?} viewContainer\n * @param {?=} _node\n */\nfunction CdkTreeNodeOutlet(viewContainer, _node) {\n  _classCallCheck(this, CdkTreeNodeOutlet);\n\n  this.viewContainer = viewContainer;\n  this._node = _node;\n};\n\nCdkTreeNodeOutlet.ɵfac = function CdkTreeNodeOutlet_Factory(t) {\n  return new (t || CdkTreeNodeOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(CDK_TREE_NODE_OUTLET_NODE, 8));\n};\n\nCdkTreeNodeOutlet.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: CdkTreeNodeOutlet,\n  selectors: [[\"\", \"cdkTreeNodeOutlet\", \"\"]]\n});\n/** @nocollapse */\n\nCdkTreeNodeOutlet.ctorParameters = function () {\n  return [{\n    type: ViewContainerRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [CDK_TREE_NODE_OUTLET_NODE]\n    }, {\n      type: Optional\n    }]\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkTreeNodeOutlet, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkTreeNodeOutlet]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ViewContainerRef\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [CDK_TREE_NODE_OUTLET_NODE]\n      }, {\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Context provided to the tree node component.\n * @template T\n */\n\n\nvar CdkTreeNodeOutletContext =\n/**\n * @param {?} data\n */\nfunction CdkTreeNodeOutletContext(data) {\n  _classCallCheck(this, CdkTreeNodeOutletContext);\n\n  this.$implicit = data;\n};\n/**\n * Data node definition for the CdkTree.\n * Captures the node's template and a when predicate that describes when this node should be used.\n * @template T\n */\n\n\nvar CdkTreeNodeDef =\n/**\n * \\@docs-private\n * @param {?} template\n */\nfunction CdkTreeNodeDef(template) {\n  _classCallCheck(this, CdkTreeNodeDef);\n\n  this.template = template;\n};\n\nCdkTreeNodeDef.ɵfac = function CdkTreeNodeDef_Factory(t) {\n  return new (t || CdkTreeNodeDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n};\n\nCdkTreeNodeDef.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: CdkTreeNodeDef,\n  selectors: [[\"\", \"cdkTreeNodeDef\", \"\"]],\n  inputs: {\n    when: [\"cdkTreeNodeDefWhen\", \"when\"]\n  }\n});\n/** @nocollapse */\n\nCdkTreeNodeDef.ctorParameters = function () {\n  return [{\n    type: TemplateRef\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkTreeNodeDef, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkTreeNodeDef]',\n      inputs: ['when: cdkTreeNodeDefWhen']\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.TemplateRef\n    }];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Returns an error to be thrown when there is no usable data.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction getTreeNoValidDataSourceError() {\n  return Error(\"A valid data source must be provided.\");\n}\n/**\n * Returns an error to be thrown when there are multiple nodes that are missing a when function.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction getTreeMultipleDefaultNodeDefsError() {\n  return Error(\"There can only be one default row without a when predicate function.\");\n}\n/**\n * Returns an error to be thrown when there are no matching node defs for a particular set of data.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction getTreeMissingMatchingNodeDefError() {\n  return Error(\"Could not find a matching node definition for the provided node data.\");\n}\n/**\n * Returns an error to be thrown when there are tree control.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction getTreeControlMissingError() {\n  return Error(\"Could not find a tree control for the tree.\");\n}\n/**\n * Returns an error to be thrown when tree control did not implement functions for flat/nested node.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction getTreeControlFunctionsMissingError() {\n  return Error(\"Could not find functions for nested/flat tree in tree control.\");\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * CDK tree component that connects with a data source to retrieve data of type `T` and renders\n * dataNodes with hierarchy. Updates the dataNodes when new data is provided by the data source.\n * @template T\n */\n\n\nvar CdkTree = /*#__PURE__*/function () {\n  /**\n   * @param {?} _differs\n   * @param {?} _changeDetectorRef\n   */\n  function CdkTree(_differs, _changeDetectorRef) {\n    _classCallCheck(this, CdkTree);\n\n    this._differs = _differs;\n    this._changeDetectorRef = _changeDetectorRef;\n    /**\n     * Subject that emits when the component has been destroyed.\n     */\n\n    this._onDestroy = new Subject();\n    /**\n     * Level of nodes\n     */\n\n    this._levels = new Map(); // TODO(tinayuangao): Setup a listener for scrolling, emit the calculated view to viewChange.\n    //     Remove the MAX_VALUE in viewChange\n\n    /**\n     * Stream containing the latest information on what rows are being displayed on screen.\n     * Can be used by the data source to as a heuristic of what data should be provided.\n     */\n\n    this.viewChange = new BehaviorSubject({\n      start: 0,\n      end: Number.MAX_VALUE\n    });\n  }\n  /**\n   * Provides a stream containing the latest data array to render. Influenced by the tree's\n   * stream of view window (what dataNodes are currently on screen).\n   * Data source can be an observable of data array, or a data array to render.\n   * @return {?}\n   */\n\n\n  _createClass(CdkTree, [{\n    key: \"ngOnInit\",\n\n    /**\n     * @return {?}\n     */\n    value: function ngOnInit() {\n      this._dataDiffer = this._differs.find([]).create(this.trackBy);\n\n      if (!this.treeControl) {\n        throw getTreeControlMissingError();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this._nodeOutlet.viewContainer.clear();\n\n      this._onDestroy.next();\n\n      this._onDestroy.complete();\n\n      if (this._dataSource && typeof\n      /** @type {?} */\n      this._dataSource.disconnect === 'function') {\n        /** @type {?} */\n        this.dataSource.disconnect(this);\n      }\n\n      if (this._dataSubscription) {\n        this._dataSubscription.unsubscribe();\n\n        this._dataSubscription = null;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngAfterContentChecked\",\n    value: function ngAfterContentChecked() {\n      /** @type {?} */\n      var defaultNodeDefs = this._nodeDefs.filter(\n      /**\n      * @param {?} def\n      * @return {?}\n      */\n      function (def) {\n        return !def.when;\n      });\n\n      if (defaultNodeDefs.length > 1) {\n        throw getTreeMultipleDefaultNodeDefsError();\n      }\n\n      this._defaultNodeDef = defaultNodeDefs[0];\n\n      if (this.dataSource && this._nodeDefs && !this._dataSubscription) {\n        this._observeRenderChanges();\n      }\n    } // TODO(tinayuangao): Work on keyboard traversal and actions, make sure it's working for RTL\n    //     and nested trees.\n\n    /**\n     * Switch to the provided data source by resetting the data and unsubscribing from the current\n     * render change subscription if one exists. If the data source is null, interpret this by\n     * clearing the node outlet. Otherwise start listening for new data.\n     * @private\n     * @param {?} dataSource\n     * @return {?}\n     */\n\n  }, {\n    key: \"_switchDataSource\",\n    value: function _switchDataSource(dataSource) {\n      if (this._dataSource && typeof\n      /** @type {?} */\n      this._dataSource.disconnect === 'function') {\n        /** @type {?} */\n        this.dataSource.disconnect(this);\n      }\n\n      if (this._dataSubscription) {\n        this._dataSubscription.unsubscribe();\n\n        this._dataSubscription = null;\n      } // Remove the all dataNodes if there is now no data source\n\n\n      if (!dataSource) {\n        this._nodeOutlet.viewContainer.clear();\n      }\n\n      this._dataSource = dataSource;\n\n      if (this._nodeDefs) {\n        this._observeRenderChanges();\n      }\n    }\n    /**\n     * Set up a subscription for the data provided by the data source.\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"_observeRenderChanges\",\n    value: function _observeRenderChanges() {\n      var _this5 = this;\n\n      /** @type {?} */\n      var dataStream;\n\n      if (isDataSource(this._dataSource)) {\n        dataStream = this._dataSource.connect(this);\n      } else if (this._dataSource instanceof Observable) {\n        dataStream = this._dataSource;\n      } else if (Array.isArray(this._dataSource)) {\n        dataStream = of(this._dataSource);\n      }\n\n      if (dataStream) {\n        this._dataSubscription = dataStream.pipe(takeUntil(this._onDestroy)).subscribe(\n        /**\n        * @param {?} data\n        * @return {?}\n        */\n        function (data) {\n          return _this5.renderNodeChanges(data);\n        });\n      } else {\n        throw getTreeNoValidDataSourceError();\n      }\n    }\n    /**\n     * Check for changes made in the data and render each change (node added/removed/moved).\n     * @param {?} data\n     * @param {?=} dataDiffer\n     * @param {?=} viewContainer\n     * @param {?=} parentData\n     * @return {?}\n     */\n\n  }, {\n    key: \"renderNodeChanges\",\n    value: function renderNodeChanges(data) {\n      var _this6 = this;\n\n      var dataDiffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._dataDiffer;\n      var viewContainer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._nodeOutlet.viewContainer;\n      var parentData = arguments.length > 3 ? arguments[3] : undefined;\n\n      /** @type {?} */\n      var changes = dataDiffer.diff(data);\n\n      if (!changes) {\n        return;\n      }\n\n      changes.forEachOperation(\n      /**\n      * @param {?} item\n      * @param {?} adjustedPreviousIndex\n      * @param {?} currentIndex\n      * @return {?}\n      */\n      function (item, adjustedPreviousIndex, currentIndex) {\n        if (item.previousIndex == null) {\n          _this6.insertNode(data[\n          /** @type {?} */\n          currentIndex],\n          /** @type {?} */\n          currentIndex, viewContainer, parentData);\n        } else if (currentIndex == null) {\n          viewContainer.remove(\n          /** @type {?} */\n          adjustedPreviousIndex);\n\n          _this6._levels.delete(item.item);\n        } else {\n          /** @type {?} */\n          var view = viewContainer.get(\n          /** @type {?} */\n          adjustedPreviousIndex);\n          viewContainer.move(\n          /** @type {?} */\n          view, currentIndex);\n        }\n      });\n\n      this._changeDetectorRef.detectChanges();\n    }\n    /**\n     * Finds the matching node definition that should be used for this node data. If there is only\n     * one node definition, it is returned. Otherwise, find the node definition that has a when\n     * predicate that returns true with the data. If none return true, return the default node\n     * definition.\n     * @param {?} data\n     * @param {?} i\n     * @return {?}\n     */\n\n  }, {\n    key: \"_getNodeDef\",\n    value: function _getNodeDef(data, i) {\n      if (this._nodeDefs.length === 1) {\n        return this._nodeDefs.first;\n      }\n      /** @type {?} */\n\n\n      var nodeDef = this._nodeDefs.find(\n      /**\n      * @param {?} def\n      * @return {?}\n      */\n      function (def) {\n        return def.when && def.when(i, data);\n      }) || this._defaultNodeDef;\n\n      if (!nodeDef) {\n        throw getTreeMissingMatchingNodeDefError();\n      }\n\n      return nodeDef;\n    }\n    /**\n     * Create the embedded view for the data node template and place it in the correct index location\n     * within the data node view container.\n     * @param {?} nodeData\n     * @param {?} index\n     * @param {?=} viewContainer\n     * @param {?=} parentData\n     * @return {?}\n     */\n\n  }, {\n    key: \"insertNode\",\n    value: function insertNode(nodeData, index, viewContainer, parentData) {\n      /** @type {?} */\n      var node = this._getNodeDef(nodeData, index); // Node context that will be provided to created embedded view\n\n      /** @type {?} */\n\n\n      var context = new CdkTreeNodeOutletContext(nodeData); // If the tree is flat tree, then use the `getLevel` function in flat tree control\n      // Otherwise, use the level of parent node.\n\n      if (this.treeControl.getLevel) {\n        context.level = this.treeControl.getLevel(nodeData);\n      } else if (typeof parentData !== 'undefined' && this._levels.has(parentData)) {\n        context.level =\n        /** @type {?} */\n        this._levels.get(parentData) + 1;\n      } else {\n        context.level = 0;\n      }\n\n      this._levels.set(nodeData, context.level); // Use default tree nodeOutlet, or nested node's nodeOutlet\n\n      /** @type {?} */\n\n\n      var container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;\n      container.createEmbeddedView(node.template, context, index); // Set the data to just created `CdkTreeNode`.\n      // The `CdkTreeNode` created from `createEmbeddedView` will be saved in static variable\n      //     `mostRecentTreeNode`. We get it from static variable and pass the node data to it.\n\n      if (CdkTreeNode.mostRecentTreeNode) {\n        CdkTreeNode.mostRecentTreeNode.data = nodeData;\n      }\n    }\n  }, {\n    key: \"dataSource\",\n    get: function get() {\n      return this._dataSource;\n    }\n    /**\n     * @param {?} dataSource\n     * @return {?}\n     */\n    ,\n    set: function set(dataSource) {\n      if (this._dataSource !== dataSource) {\n        this._switchDataSource(dataSource);\n      }\n    }\n  }]);\n\n  return CdkTree;\n}();\n\nCdkTree.ɵfac = function CdkTree_Factory(t) {\n  return new (t || CdkTree)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n};\n\nCdkTree.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n  type: CdkTree,\n  selectors: [[\"cdk-tree\"]],\n  contentQueries: function CdkTree_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵcontentQuery(dirIndex, CdkTreeNodeDef, 0);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._nodeDefs = _t);\n    }\n  },\n  viewQuery: function CdkTree_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(CdkTreeNodeOutlet, 3);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._nodeOutlet = _t.first);\n    }\n  },\n  hostAttrs: [\"role\", \"tree\", 1, \"cdk-tree\"],\n  inputs: {\n    dataSource: \"dataSource\",\n    treeControl: \"treeControl\",\n    trackBy: \"trackBy\"\n  },\n  exportAs: [\"cdkTree\"],\n  decls: 1,\n  vars: 0,\n  consts: [[\"cdkTreeNodeOutlet\", \"\"]],\n  template: function CdkTree_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵelementContainer(0, 0);\n    }\n  },\n  directives: [CdkTreeNodeOutlet],\n  encapsulation: 2\n});\n/** @nocollapse */\n\nCdkTree.ctorParameters = function () {\n  return [{\n    type: IterableDiffers\n  }, {\n    type: ChangeDetectorRef\n  }];\n};\n\nCdkTree.propDecorators = {\n  dataSource: [{\n    type: Input\n  }],\n  treeControl: [{\n    type: Input\n  }],\n  trackBy: [{\n    type: Input\n  }],\n  _nodeOutlet: [{\n    type: ViewChild,\n    args: [CdkTreeNodeOutlet, {\n      static: true\n    }]\n  }],\n  _nodeDefs: [{\n    type: ContentChildren,\n    args: [CdkTreeNodeDef]\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkTree, [{\n    type: Component,\n    args: [{\n      selector: 'cdk-tree',\n      exportAs: 'cdkTree',\n      template: \"<ng-container cdkTreeNodeOutlet></ng-container>\",\n      host: {\n        'class': 'cdk-tree',\n        'role': 'tree'\n      },\n      encapsulation: ViewEncapsulation.None,\n      // The \"OnPush\" status for the `CdkTree` component is effectively a noop, so we are removing it.\n      // The view for `CdkTree` consists entirely of templates declared in other views. As they are\n      // declared elsewhere, they are checked when their declaration points are checked.\n      // tslint:disable-next-line:validate-decorators\n      changeDetection: ChangeDetectionStrategy.Default\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.IterableDiffers\n    }, {\n      type: ɵngcc0.ChangeDetectorRef\n    }];\n  }, {\n    dataSource: [{\n      type: Input\n    }],\n    treeControl: [{\n      type: Input\n    }],\n    trackBy: [{\n      type: Input\n    }],\n    _nodeOutlet: [{\n      type: ViewChild,\n      args: [CdkTreeNodeOutlet, {\n        static: true\n      }]\n    }],\n    _nodeDefs: [{\n      type: ContentChildren,\n      args: [CdkTreeNodeDef]\n    }]\n  });\n})();\n/**\n * Tree node for CdkTree. It contains the data in the tree node.\n * @template T\n */\n\n\nvar CdkTreeNode = /*#__PURE__*/function () {\n  /**\n   * @param {?} _elementRef\n   * @param {?} _tree\n   */\n  function CdkTreeNode(_elementRef, _tree) {\n    _classCallCheck(this, CdkTreeNode);\n\n    this._elementRef = _elementRef;\n    this._tree = _tree;\n    /**\n     * Subject that emits when the component has been destroyed.\n     */\n\n    this._destroyed = new Subject();\n    /**\n     * Emits when the node's data has changed.\n     */\n\n    this._dataChanges = new Subject();\n    /**\n     * The role of the node should be 'group' if it's an internal node,\n     * and 'treeitem' if it's a leaf node.\n     */\n\n    this.role = 'treeitem';\n    CdkTreeNode.mostRecentTreeNode =\n    /** @type {?} */\n    this;\n  }\n  /**\n   * The tree node's data.\n   * @return {?}\n   */\n\n\n  _createClass(CdkTreeNode, [{\n    key: \"ngOnDestroy\",\n\n    /**\n     * @return {?}\n     */\n    value: function ngOnDestroy() {\n      // If this is the last tree node being destroyed,\n      // clear out the reference to avoid leaking memory.\n      if (CdkTreeNode.mostRecentTreeNode === this) {\n        CdkTreeNode.mostRecentTreeNode = null;\n      }\n\n      this._dataChanges.complete();\n\n      this._destroyed.next();\n\n      this._destroyed.complete();\n    }\n    /**\n     * Focuses the menu item. Implements for FocusableOption.\n     * @return {?}\n     */\n\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this._elementRef.nativeElement.focus();\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n\n  }, {\n    key: \"_setRoleFromData\",\n    value: function _setRoleFromData() {\n      var _this7 = this;\n\n      if (this._tree.treeControl.isExpandable) {\n        this.role = this._tree.treeControl.isExpandable(this._data) ? 'group' : 'treeitem';\n      } else {\n        if (!this._tree.treeControl.getChildren) {\n          throw getTreeControlFunctionsMissingError();\n        }\n        /** @type {?} */\n\n\n        var childrenNodes = this._tree.treeControl.getChildren(this._data);\n\n        if (Array.isArray(childrenNodes)) {\n          this._setRoleFromChildren(\n          /** @type {?} */\n          childrenNodes);\n        } else if (childrenNodes instanceof Observable) {\n          childrenNodes.pipe(takeUntil(this._destroyed)).subscribe(\n          /**\n          * @param {?} children\n          * @return {?}\n          */\n          function (children) {\n            return _this7._setRoleFromChildren(children);\n          });\n        }\n      }\n    }\n    /**\n     * @protected\n     * @param {?} children\n     * @return {?}\n     */\n\n  }, {\n    key: \"_setRoleFromChildren\",\n    value: function _setRoleFromChildren(children) {\n      this.role = children && children.length ? 'group' : 'treeitem';\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this._data;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      if (value !== this._data) {\n        this._data = value;\n\n        this._setRoleFromData();\n\n        this._dataChanges.next();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"isExpanded\",\n    get: function get() {\n      return this._tree.treeControl.isExpanded(this._data);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"level\",\n    get: function get() {\n      return this._tree.treeControl.getLevel ? this._tree.treeControl.getLevel(this._data) : 0;\n    }\n  }]);\n\n  return CdkTreeNode;\n}();\n\nCdkTreeNode.ɵfac = function CdkTreeNode_Factory(t) {\n  return new (t || CdkTreeNode)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(CdkTree));\n};\n\nCdkTreeNode.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: CdkTreeNode,\n  selectors: [[\"cdk-tree-node\"]],\n  hostAttrs: [1, \"cdk-tree-node\"],\n  hostVars: 3,\n  hostBindings: function CdkTreeNode_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"aria-expanded\", ctx.isExpanded)(\"aria-level\", ctx.role === \"treeitem\" ? ctx.level : null)(\"role\", ctx.role);\n    }\n  },\n  inputs: {\n    role: \"role\"\n  },\n  exportAs: [\"cdkTreeNode\"]\n});\n/**\n * The most recently created `CdkTreeNode`. We save it in static variable so we can retrieve it\n * in `CdkTree` and set the data to it.\n */\n\nCdkTreeNode.mostRecentTreeNode = null;\n/** @nocollapse */\n\nCdkTreeNode.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: CdkTree\n  }];\n};\n\nCdkTreeNode.propDecorators = {\n  role: [{\n    type: Input\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkTreeNode, [{\n    type: Directive,\n    args: [{\n      selector: 'cdk-tree-node',\n      exportAs: 'cdkTreeNode',\n      host: {\n        '[attr.aria-expanded]': 'isExpanded',\n        '[attr.aria-level]': 'role === \"treeitem\" ? level : null',\n        '[attr.role]': 'role',\n        'class': 'cdk-tree-node'\n      }\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: CdkTree\n    }];\n  }, {\n    role: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Nested node is a child of `<cdk-tree>`. It works with nested tree.\n * By using `cdk-nested-tree-node` component in tree node template, children of the parent node will\n * be added in the `cdkTreeNodeOutlet` in tree node template.\n * For example:\n *   ```html\n *   <cdk-nested-tree-node>\n *     {{node.name}}\n *     <ng-template cdkTreeNodeOutlet></ng-template>\n *   </cdk-nested-tree-node>\n *   ```\n * The children of node will be automatically added to `cdkTreeNodeOutlet`, the result dom will be\n * like this:\n *   ```html\n *   <cdk-nested-tree-node>\n *     {{node.name}}\n *      <cdk-nested-tree-node>{{child1.name}}</cdk-nested-tree-node>\n *      <cdk-nested-tree-node>{{child2.name}}</cdk-nested-tree-node>\n *   </cdk-nested-tree-node>\n *   ```\n * @template T\n */\n\n\nvar CdkNestedTreeNode = /*#__PURE__*/function (_CdkTreeNode) {\n  _inherits(CdkNestedTreeNode, _CdkTreeNode);\n\n  var _super3 = _createSuper(CdkNestedTreeNode);\n\n  /**\n   * @param {?} _elementRef\n   * @param {?} _tree\n   * @param {?} _differs\n   */\n  function CdkNestedTreeNode(_elementRef, _tree, _differs) {\n    var _this8;\n\n    _classCallCheck(this, CdkNestedTreeNode);\n\n    _this8 = _super3.call(this, _elementRef, _tree);\n    _this8._elementRef = _elementRef;\n    _this8._tree = _tree;\n    _this8._differs = _differs;\n    return _this8;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(CdkNestedTreeNode, [{\n    key: \"ngAfterContentInit\",\n    value: function ngAfterContentInit() {\n      var _this9 = this;\n\n      this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);\n\n      if (!this._tree.treeControl.getChildren) {\n        throw getTreeControlFunctionsMissingError();\n      }\n      /** @type {?} */\n\n\n      var childrenNodes = this._tree.treeControl.getChildren(this.data);\n\n      if (Array.isArray(childrenNodes)) {\n        this.updateChildrenNodes(\n        /** @type {?} */\n        childrenNodes);\n      } else if (childrenNodes instanceof Observable) {\n        childrenNodes.pipe(takeUntil(this._destroyed)).subscribe(\n        /**\n        * @param {?} result\n        * @return {?}\n        */\n        function (result) {\n          return _this9.updateChildrenNodes(result);\n        });\n      }\n\n      this.nodeOutlet.changes.pipe(takeUntil(this._destroyed)).subscribe(\n      /**\n      * @return {?}\n      */\n      function () {\n        return _this9.updateChildrenNodes();\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this._clear();\n\n      _get(_getPrototypeOf(CdkNestedTreeNode.prototype), \"ngOnDestroy\", this).call(this);\n    }\n    /**\n     * Add children dataNodes to the NodeOutlet\n     * @protected\n     * @param {?=} children\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateChildrenNodes\",\n    value: function updateChildrenNodes(children) {\n      /** @type {?} */\n      var outlet = this._getNodeOutlet();\n\n      if (children) {\n        this._children = children;\n      }\n\n      if (outlet && this._children) {\n        /** @type {?} */\n        var viewContainer = outlet.viewContainer;\n\n        this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);\n      } else {\n        // Reset the data differ if there's no children nodes displayed\n        this._dataDiffer.diff([]);\n      }\n    }\n    /**\n     * Clear the children dataNodes.\n     * @protected\n     * @return {?}\n     */\n\n  }, {\n    key: \"_clear\",\n    value: function _clear() {\n      /** @type {?} */\n      var outlet = this._getNodeOutlet();\n\n      if (outlet) {\n        outlet.viewContainer.clear();\n\n        this._dataDiffer.diff([]);\n      }\n    }\n    /**\n     * Gets the outlet for the current node.\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"_getNodeOutlet\",\n    value: function _getNodeOutlet() {\n      var _this10 = this;\n\n      /** @type {?} */\n      var outlets = this.nodeOutlet; // Note that since we use `descendants: true` on the query, we have to ensure\n      // that we don't pick up the outlet of a child node by accident.\n\n      return outlets && outlets.find(\n      /**\n      * @param {?} outlet\n      * @return {?}\n      */\n      function (outlet) {\n        return !outlet._node || outlet._node === _this10;\n      });\n    }\n  }]);\n\n  return CdkNestedTreeNode;\n}(CdkTreeNode);\n\nCdkNestedTreeNode.ɵfac = function CdkNestedTreeNode_Factory(t) {\n  return new (t || CdkNestedTreeNode)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(CdkTree), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers));\n};\n\nCdkNestedTreeNode.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: CdkNestedTreeNode,\n  selectors: [[\"cdk-nested-tree-node\"]],\n  contentQueries: function CdkNestedTreeNode_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵcontentQuery(dirIndex, CdkTreeNodeOutlet, 1);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nodeOutlet = _t);\n    }\n  },\n  hostAttrs: [1, \"cdk-tree-node\", \"cdk-nested-tree-node\"],\n  hostVars: 2,\n  hostBindings: function CdkNestedTreeNode_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"aria-expanded\", ctx.isExpanded)(\"role\", ctx.role);\n    }\n  },\n  exportAs: [\"cdkNestedTreeNode\"],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: CdkTreeNode,\n    useExisting: CdkNestedTreeNode\n  }, {\n    provide: CDK_TREE_NODE_OUTLET_NODE,\n    useExisting: CdkNestedTreeNode\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n/** @nocollapse */\n\nCdkNestedTreeNode.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: CdkTree\n  }, {\n    type: IterableDiffers\n  }];\n};\n\nCdkNestedTreeNode.propDecorators = {\n  nodeOutlet: [{\n    type: ContentChildren,\n    args: [CdkTreeNodeOutlet, {\n      // We need to use `descendants: true`, because Ivy will no longer match\n      // indirect descendants if it's left as false.\n      descendants: true\n    }]\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkNestedTreeNode, [{\n    type: Directive,\n    args: [{\n      selector: 'cdk-nested-tree-node',\n      exportAs: 'cdkNestedTreeNode',\n      host: {\n        '[attr.aria-expanded]': 'isExpanded',\n        '[attr.role]': 'role',\n        'class': 'cdk-tree-node cdk-nested-tree-node'\n      },\n      providers: [{\n        provide: CdkTreeNode,\n        useExisting: CdkNestedTreeNode\n      }, {\n        provide: CDK_TREE_NODE_OUTLET_NODE,\n        useExisting: CdkNestedTreeNode\n      }]\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: CdkTree\n    }, {\n      type: ɵngcc0.IterableDiffers\n    }];\n  }, {\n    nodeOutlet: [{\n      type: ContentChildren,\n      args: [CdkTreeNodeOutlet, {\n        // We need to use `descendants: true`, because Ivy will no longer match\n        // indirect descendants if it's left as false.\n        descendants: true\n      }]\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Regex used to split a string on its CSS units.\n * @type {?}\n */\n\n\nvar cssUnitPattern = /([A-Za-z%]+)$/;\n/**\n * Indent for the children tree dataNodes.\n * This directive will add left-padding to the node to show hierarchy.\n * @template T\n */\n\nvar CdkTreeNodePadding = /*#__PURE__*/function () {\n  /**\n   * @param {?} _treeNode\n   * @param {?} _tree\n   * @param {?} _renderer\n   * @param {?} _element\n   * @param {?} _dir\n   */\n  function CdkTreeNodePadding(_treeNode, _tree, _renderer, _element, _dir) {\n    var _this11 = this;\n\n    _classCallCheck(this, CdkTreeNodePadding);\n\n    this._treeNode = _treeNode;\n    this._tree = _tree;\n    this._renderer = _renderer;\n    this._element = _element;\n    this._dir = _dir;\n    /**\n     * Subject that emits when the component has been destroyed.\n     */\n\n    this._destroyed = new Subject();\n    /**\n     * CSS units used for the indentation value.\n     */\n\n    this.indentUnits = 'px';\n    this._indent = 40;\n\n    this._setPadding();\n\n    if (_dir) {\n      _dir.change.pipe(takeUntil(this._destroyed)).subscribe(\n      /**\n      * @return {?}\n      */\n      function () {\n        return _this11._setPadding(true);\n      });\n    } // In Ivy the indentation binding might be set before the tree node's data has been added,\n    // which means that we'll miss the first render. We have to subscribe to changes in the\n    // data to ensure that everything is up to date.\n\n\n    _treeNode._dataChanges.subscribe(\n    /**\n    * @return {?}\n    */\n    function () {\n      return _this11._setPadding();\n    });\n  }\n  /**\n   * The level of depth of the tree node. The padding will be `level * indent` pixels.\n   * @return {?}\n   */\n\n\n  _createClass(CdkTreeNodePadding, [{\n    key: \"ngOnDestroy\",\n\n    /**\n     * @return {?}\n     */\n    value: function ngOnDestroy() {\n      this._destroyed.next();\n\n      this._destroyed.complete();\n    }\n    /**\n     * The padding indent value for the tree node. Returns a string with px numbers if not null.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_paddingIndent\",\n    value: function _paddingIndent() {\n      /** @type {?} */\n      var nodeLevel = this._treeNode.data && this._tree.treeControl.getLevel ? this._tree.treeControl.getLevel(this._treeNode.data) : null;\n      /** @type {?} */\n\n      var level = this._level == null ? nodeLevel : this._level;\n      return typeof level === 'number' ? \"\".concat(level * this._indent).concat(this.indentUnits) : null;\n    }\n    /**\n     * @param {?=} forceChange\n     * @return {?}\n     */\n\n  }, {\n    key: \"_setPadding\",\n    value: function _setPadding() {\n      var forceChange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      /** @type {?} */\n      var padding = this._paddingIndent();\n\n      if (padding !== this._currentPadding || forceChange) {\n        /** @type {?} */\n        var element = this._element.nativeElement;\n        /** @type {?} */\n\n        var paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';\n        /** @type {?} */\n\n        var resetProp = paddingProp === 'paddingLeft' ? 'paddingRight' : 'paddingLeft';\n\n        this._renderer.setStyle(element, paddingProp, padding);\n\n        this._renderer.setStyle(element, resetProp, null);\n\n        this._currentPadding = padding;\n      }\n    }\n  }, {\n    key: \"level\",\n    get: function get() {\n      return this._level;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      // Set to null as the fallback value so that _setPadding can fall back to the node level if the\n      // consumer set the directive as `cdkTreeNodePadding=\"\"`. We still want to take this value if\n      // they set 0 explicitly.\n      this._level =\n      /** @type {?} */\n      coerceNumberProperty(value, null);\n\n      this._setPadding();\n    }\n    /**\n     * The indent for each level. Can be a number or a CSS string.\n     * Default number 40px from material design menu sub-menu spec.\n     * @return {?}\n     */\n\n  }, {\n    key: \"indent\",\n    get: function get() {\n      return this._indent;\n    }\n    /**\n     * @param {?} indent\n     * @return {?}\n     */\n    ,\n    set: function set(indent) {\n      /** @type {?} */\n      var value = indent;\n      /** @type {?} */\n\n      var units = 'px';\n\n      if (typeof indent === 'string') {\n        /** @type {?} */\n        var parts = indent.split(cssUnitPattern);\n        value = parts[0];\n        units = parts[1] || units;\n      }\n\n      this.indentUnits = units;\n      this._indent = coerceNumberProperty(value);\n\n      this._setPadding();\n    }\n  }]);\n\n  return CdkTreeNodePadding;\n}();\n\nCdkTreeNodePadding.ɵfac = function CdkTreeNodePadding_Factory(t) {\n  return new (t || CdkTreeNodePadding)(ɵngcc0.ɵɵdirectiveInject(CdkTreeNode), ɵngcc0.ɵɵdirectiveInject(CdkTree), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Directionality, 8));\n};\n\nCdkTreeNodePadding.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: CdkTreeNodePadding,\n  selectors: [[\"\", \"cdkTreeNodePadding\", \"\"]],\n  inputs: {\n    level: [\"cdkTreeNodePadding\", \"level\"],\n    indent: [\"cdkTreeNodePaddingIndent\", \"indent\"]\n  }\n});\n/** @nocollapse */\n\nCdkTreeNodePadding.ctorParameters = function () {\n  return [{\n    type: CdkTreeNode\n  }, {\n    type: CdkTree\n  }, {\n    type: Renderer2\n  }, {\n    type: ElementRef\n  }, {\n    type: Directionality,\n    decorators: [{\n      type: Optional\n    }]\n  }];\n};\n\nCdkTreeNodePadding.propDecorators = {\n  level: [{\n    type: Input,\n    args: ['cdkTreeNodePadding']\n  }],\n  indent: [{\n    type: Input,\n    args: ['cdkTreeNodePaddingIndent']\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkTreeNodePadding, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkTreeNodePadding]'\n    }]\n  }], function () {\n    return [{\n      type: CdkTreeNode\n    }, {\n      type: CdkTree\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc1.Directionality,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    level: [{\n      type: Input,\n      args: ['cdkTreeNodePadding']\n    }],\n    indent: [{\n      type: Input,\n      args: ['cdkTreeNodePaddingIndent']\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Node toggle to expand/collapse the node.\n * @template T\n */\n\n\nvar CdkTreeNodeToggle = /*#__PURE__*/function () {\n  /**\n   * @param {?} _tree\n   * @param {?} _treeNode\n   */\n  function CdkTreeNodeToggle(_tree, _treeNode) {\n    _classCallCheck(this, CdkTreeNodeToggle);\n\n    this._tree = _tree;\n    this._treeNode = _treeNode;\n    this._recursive = false;\n  }\n  /**\n   * Whether expand/collapse the node recursively.\n   * @return {?}\n   */\n\n\n  _createClass(CdkTreeNodeToggle, [{\n    key: \"_toggle\",\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n    // ViewEngine they're overwritten.\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n    // tslint:disable-next-line:no-host-decorator-in-concrete\n\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    value: function _toggle(event) {\n      this.recursive ? this._tree.treeControl.toggleDescendants(this._treeNode.data) : this._tree.treeControl.toggle(this._treeNode.data);\n      event.stopPropagation();\n    }\n  }, {\n    key: \"recursive\",\n    get: function get() {\n      return this._recursive;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      this._recursive = coerceBooleanProperty(value);\n    }\n  }]);\n\n  return CdkTreeNodeToggle;\n}();\n\nCdkTreeNodeToggle.ɵfac = function CdkTreeNodeToggle_Factory(t) {\n  return new (t || CdkTreeNodeToggle)(ɵngcc0.ɵɵdirectiveInject(CdkTree), ɵngcc0.ɵɵdirectiveInject(CdkTreeNode));\n};\n\nCdkTreeNodeToggle.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: CdkTreeNodeToggle,\n  selectors: [[\"\", \"cdkTreeNodeToggle\", \"\"]],\n  hostBindings: function CdkTreeNodeToggle_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"click\", function CdkTreeNodeToggle_click_HostBindingHandler($event) {\n        return ctx._toggle($event);\n      });\n    }\n  },\n  inputs: {\n    recursive: [\"cdkTreeNodeToggleRecursive\", \"recursive\"]\n  }\n});\n/** @nocollapse */\n\nCdkTreeNodeToggle.ctorParameters = function () {\n  return [{\n    type: CdkTree\n  }, {\n    type: CdkTreeNode\n  }];\n};\n\nCdkTreeNodeToggle.propDecorators = {\n  recursive: [{\n    type: Input,\n    args: ['cdkTreeNodeToggleRecursive']\n  }],\n  _toggle: [{\n    type: HostListener,\n    args: ['click', ['$event']]\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkTreeNodeToggle, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkTreeNodeToggle]'\n    }]\n  }], function () {\n    return [{\n      type: CdkTree\n    }, {\n      type: CdkTreeNode\n    }];\n  }, {\n    recursive: [{\n      type: Input,\n      args: ['cdkTreeNodeToggleRecursive']\n    }],\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n    // ViewEngine they're overwritten.\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n    // tslint:disable-next-line:no-host-decorator-in-concrete\n\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    _toggle: [{\n      type: HostListener,\n      args: ['click', ['$event']]\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar EXPORTED_DECLARATIONS = [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet];\n\nvar CdkTreeModule = function CdkTreeModule() {\n  _classCallCheck(this, CdkTreeModule);\n};\n\nCdkTreeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: CdkTreeModule\n});\nCdkTreeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function CdkTreeModule_Factory(t) {\n    return new (t || CdkTreeModule)();\n  },\n  providers: [FocusMonitor, CdkTreeNodeDef],\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CdkTreeModule, {\n    declarations: function declarations() {\n      return [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkTreeModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      exports: EXPORTED_DECLARATIONS,\n      declarations: EXPORTED_DECLARATIONS,\n      providers: [FocusMonitor, CdkTreeNodeDef]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { BaseTreeControl, FlatTreeControl, NestedTreeControl, CdkNestedTreeNode, CdkTreeNodeOutletContext, CdkTreeNodeDef, CdkTreeNodePadding, CDK_TREE_NODE_OUTLET_NODE, CdkTreeNodeOutlet, CdkTree, CdkTreeNode, getTreeNoValidDataSourceError, getTreeMultipleDefaultNodeDefsError, getTreeMissingMatchingNodeDefError, getTreeControlMissingError, getTreeControlFunctionsMissingError, CdkTreeModule, CdkTreeNodeToggle };","map":{"version":3,"sources":["../../../src/cdk/tree/control/base-tree-control.ts","../../../src/cdk/tree/control/flat-tree-control.ts","../../../src/cdk/tree/control/nested-tree-control.ts","../../../src/cdk/tree/outlet.ts","../../../src/cdk/tree/node.ts","../../../src/cdk/tree/tree-errors.ts","../../../src/cdk/tree/tree.ts","../../../src/cdk/tree/nested-node.ts","../../../src/cdk/tree/padding.ts","../../../src/cdk/tree/toggle.ts","../../../src/cdk/tree/tree-module.ts"],"names":["observableOf"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SelectionModel} from '@angular/cdk/collections';\nimport {Observable} from 'rxjs';\nimport {TreeControl} from './tree-control';\n\n/** Base tree control. It has basic toggle/expand/collapse operations on a single data node. */\nexport abstract class BaseTreeControl<T> implements TreeControl<T> {\n\n  /** Gets a list of descendent data nodes of a subtree rooted at given data node recursively. */\n  abstract getDescendants(dataNode: T): T[];\n\n  /** Expands all data nodes in the tree. */\n  abstract expandAll(): void;\n\n  /** Saved data node for `expandAll` action. */\n  dataNodes: T[];\n\n  /** A selection model with multi-selection to track expansion status. */\n  expansionModel: SelectionModel<T> = new SelectionModel<T>(true);\n\n  /** Get depth of a given data node, return the level number. This is for flat tree node. */\n  getLevel: (dataNode: T) => number;\n\n  /**\n   * Whether the data node is expandable. Returns true if expandable.\n   * This is for flat tree node.\n   */\n  isExpandable: (dataNode: T) => boolean;\n\n  /** Gets a stream that emits whenever the given data node's children change. */\n  getChildren: (dataNode: T) => (Observable<T[]> | T[] | undefined | null);\n\n  /** Toggles one single data node's expanded/collapsed state. */\n  toggle(dataNode: T): void {\n    this.expansionModel.toggle(dataNode);\n  }\n\n  /** Expands one single data node. */\n  expand(dataNode: T): void {\n    this.expansionModel.select(dataNode);\n  }\n\n  /** Collapses one single data node. */\n  collapse(dataNode: T): void {\n    this.expansionModel.deselect(dataNode);\n  }\n\n  /** Whether a given data node is expanded or not. Returns true if the data node is expanded. */\n  isExpanded(dataNode: T): boolean {\n    return this.expansionModel.isSelected(dataNode);\n  }\n\n  /** Toggles a subtree rooted at `node` recursively. */\n  toggleDescendants(dataNode: T): void {\n    this.expansionModel.isSelected(dataNode)\n        ? this.collapseDescendants(dataNode)\n        : this.expandDescendants(dataNode);\n  }\n\n  /** Collapse all dataNodes in the tree. */\n  collapseAll(): void {\n    this.expansionModel.clear();\n  }\n\n  /** Expands a subtree rooted at given data node recursively. */\n  expandDescendants(dataNode: T): void {\n    let toBeProcessed = [dataNode];\n    toBeProcessed.push(...this.getDescendants(dataNode));\n    this.expansionModel.select(...toBeProcessed);\n  }\n\n  /** Collapses a subtree rooted at given data node recursively. */\n  collapseDescendants(dataNode: T): void {\n    let toBeProcessed = [dataNode];\n    toBeProcessed.push(...this.getDescendants(dataNode));\n    this.expansionModel.deselect(...toBeProcessed);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BaseTreeControl} from './base-tree-control';\n\n/** Flat tree control. Able to expand/collapse a subtree recursively for flattened tree. */\nexport class FlatTreeControl<T> extends BaseTreeControl<T> {\n\n  /** Construct with flat tree data node functions getLevel and isExpandable. */\n  constructor(public getLevel: (dataNode: T) => number,\n              public isExpandable: (dataNode: T) => boolean) {\n    super();\n  }\n\n  /**\n   * Gets a list of the data node's subtree of descendent data nodes.\n   *\n   * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes\n   * with correct levels.\n   */\n  getDescendants(dataNode: T): T[] {\n    const startIndex = this.dataNodes.indexOf(dataNode);\n    const results: T[] = [];\n\n    // Goes through flattened tree nodes in the `dataNodes` array, and get all descendants.\n    // The level of descendants of a tree node must be greater than the level of the given\n    // tree node.\n    // If we reach a node whose level is equal to the level of the tree node, we hit a sibling.\n    // If we reach a node whose level is greater than the level of the tree node, we hit a\n    // sibling of an ancestor.\n    for (let i = startIndex + 1;\n        i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]);\n        i++) {\n      results.push(this.dataNodes[i]);\n    }\n    return results;\n  }\n\n  /**\n   * Expands all data nodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened\n   * data nodes of the tree.\n   */\n  expandAll(): void {\n    this.expansionModel.select(...this.dataNodes);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Observable} from 'rxjs';\nimport {take, filter} from 'rxjs/operators';\nimport {BaseTreeControl} from './base-tree-control';\n\n/** Nested tree control. Able to expand/collapse a subtree recursively for NestedNode type. */\nexport class NestedTreeControl<T> extends BaseTreeControl<T> {\n\n  /** Construct with nested tree function getChildren. */\n  constructor(public getChildren: (dataNode: T) => (Observable<T[]> | T[] | undefined | null)) {\n    super();\n  }\n\n  /**\n   * Expands all dataNodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all root level\n   * data nodes of the tree.\n   */\n  expandAll(): void {\n    this.expansionModel.clear();\n    const allNodes = this.dataNodes.reduce((accumulator: T[], dataNode) =>\n        [...accumulator, ...this.getDescendants(dataNode), dataNode], []);\n    this.expansionModel.select(...allNodes);\n  }\n\n  /** Gets a list of descendant dataNodes of a subtree rooted at given data node recursively. */\n  getDescendants(dataNode: T): T[] {\n    const descendants: T[] = [];\n\n    this._getDescendants(descendants, dataNode);\n    // Remove the node itself\n    return descendants.splice(1);\n  }\n\n  /** A helper function to get descendants recursively. */\n  protected _getDescendants(descendants: T[], dataNode: T): void {\n    descendants.push(dataNode);\n    const childrenNodes = this.getChildren(dataNode);\n    if (Array.isArray(childrenNodes)) {\n      childrenNodes.forEach((child: T) => this._getDescendants(descendants, child));\n    } else if (childrenNodes instanceof Observable) {\n      // TypeScript as of version 3.5 doesn't seem to treat `Boolean` like a function that\n      // returns a `boolean` specifically in the context of `filter`, so we manually clarify that.\n      childrenNodes.pipe(take(1), filter(Boolean as () => boolean))\n          .subscribe(children => {\n            for (const child of children) {\n              this._getDescendants(descendants, child);\n            }\n          });\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  Directive,\n  Inject,\n  InjectionToken,\n  Optional,\n  ViewContainerRef,\n} from '@angular/core';\n\n/**\n * Injection token used to provide a `CdkTreeNode` to its outlet.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nexport const CDK_TREE_NODE_OUTLET_NODE = new InjectionToken<{}>('CDK_TREE_NODE_OUTLET_NODE');\n\n/**\n * Outlet for nested CdkNode. Put `[cdkTreeNodeOutlet]` on a tag to place children dataNodes\n * inside the outlet.\n */\n@Directive({\n  selector: '[cdkTreeNodeOutlet]'\n})\nexport class CdkTreeNodeOutlet {\n  constructor(\n      public viewContainer: ViewContainerRef,\n      @Inject(CDK_TREE_NODE_OUTLET_NODE) @Optional() public _node?: any) {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, TemplateRef} from '@angular/core';\n\n\n/** Context provided to the tree node component. */\nexport class CdkTreeNodeOutletContext<T> {\n  /** Data for the node. */\n  $implicit: T;\n\n  /** Depth of the node. */\n  level: number;\n\n  /** Index location of the node. */\n  index?: number;\n\n  /** Length of the number of total dataNodes. */\n  count?: number;\n\n  constructor(data: T) {\n    this.$implicit = data;\n  }\n}\n\n/**\n * Data node definition for the CdkTree.\n * Captures the node's template and a when predicate that describes when this node should be used.\n */\n@Directive({\n  selector: '[cdkTreeNodeDef]',\n  inputs: [\n    'when: cdkTreeNodeDefWhen'\n  ],\n})\nexport class CdkTreeNodeDef<T> {\n  /**\n   * Function that should return true if this node template should be used for the provided node\n   * data and index. If left undefined, this node will be considered the default node template to\n   * use when no other when functions return true for the data.\n   * For every node, there must be at least one when function that passes or an undefined to\n   * default.\n   */\n  when: (index: number, nodeData: T) => boolean;\n\n  /** @docs-private */\n  constructor(public template: TemplateRef<any>) {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Returns an error to be thrown when there is no usable data.\n * @docs-private\n */\nexport function getTreeNoValidDataSourceError() {\n  return Error(`A valid data source must be provided.`);\n}\n\n/**\n * Returns an error to be thrown when there are multiple nodes that are missing a when function.\n * @docs-private\n */\nexport function getTreeMultipleDefaultNodeDefsError() {\n  return Error(`There can only be one default row without a when predicate function.`);\n}\n\n/**\n * Returns an error to be thrown when there are no matching node defs for a particular set of data.\n * @docs-private\n */\nexport function getTreeMissingMatchingNodeDefError() {\n  return Error(`Could not find a matching node definition for the provided node data.`);\n}\n\n/**\n * Returns an error to be thrown when there are tree control.\n * @docs-private\n */\nexport function getTreeControlMissingError() {\n  return Error(`Could not find a tree control for the tree.`);\n}\n\n/**\n * Returns an error to be thrown when tree control did not implement functions for flat/nested node.\n * @docs-private\n */\nexport function getTreeControlFunctionsMissingError() {\n  return Error(`Could not find functions for nested/flat tree in tree control.`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {FocusableOption} from '@angular/cdk/a11y';\nimport {CollectionViewer, DataSource, isDataSource} from '@angular/cdk/collections';\nimport {\n  AfterContentChecked,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  Directive,\n  ElementRef,\n  Input,\n  IterableChangeRecord,\n  IterableDiffer,\n  IterableDiffers,\n  OnDestroy,\n  OnInit,\n  QueryList,\n  ViewChild,\n  ViewContainerRef,\n  ViewEncapsulation,\n  TrackByFunction\n} from '@angular/core';\nimport {BehaviorSubject, Observable, of as observableOf, Subject, Subscription} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\nimport {TreeControl} from './control/tree-control';\nimport {CdkTreeNodeDef, CdkTreeNodeOutletContext} from './node';\nimport {CdkTreeNodeOutlet} from './outlet';\nimport {\n  getTreeControlFunctionsMissingError,\n  getTreeControlMissingError,\n  getTreeMissingMatchingNodeDefError,\n  getTreeMultipleDefaultNodeDefsError,\n  getTreeNoValidDataSourceError\n} from './tree-errors';\n\n/**\n * CDK tree component that connects with a data source to retrieve data of type `T` and renders\n * dataNodes with hierarchy. Updates the dataNodes when new data is provided by the data source.\n */\n@Component({\n  moduleId: module.id,\n  selector: 'cdk-tree',\n  exportAs: 'cdkTree',\n  template: `<ng-container cdkTreeNodeOutlet></ng-container>`,\n  host: {\n    'class': 'cdk-tree',\n    'role': 'tree',\n  },\n  encapsulation: ViewEncapsulation.None,\n\n  // The \"OnPush\" status for the `CdkTree` component is effectively a noop, so we are removing it.\n  // The view for `CdkTree` consists entirely of templates declared in other views. As they are\n  // declared elsewhere, they are checked when their declaration points are checked.\n  // tslint:disable-next-line:validate-decorators\n  changeDetection: ChangeDetectionStrategy.Default\n})\nexport class CdkTree<T> implements AfterContentChecked, CollectionViewer, OnDestroy, OnInit {\n  /** Subject that emits when the component has been destroyed. */\n  private _onDestroy = new Subject<void>();\n\n  /** Differ used to find the changes in the data provided by the data source. */\n  private _dataDiffer: IterableDiffer<T>;\n\n  /** Stores the node definition that does not have a when predicate. */\n  private _defaultNodeDef: CdkTreeNodeDef<T> | null;\n\n  /** Data subscription */\n  private _dataSubscription: Subscription | null;\n\n  /** Level of nodes */\n  private _levels: Map<T, number> = new Map<T, number>();\n\n  /**\n   * Provides a stream containing the latest data array to render. Influenced by the tree's\n   * stream of view window (what dataNodes are currently on screen).\n   * Data source can be an observable of data array, or a data array to render.\n   */\n  @Input()\n  get dataSource(): DataSource<T> | Observable<T[]> | T[] { return this._dataSource; }\n  set dataSource(dataSource: DataSource<T> | Observable<T[]> | T[]) {\n    if (this._dataSource !== dataSource) {\n      this._switchDataSource(dataSource);\n    }\n  }\n  private _dataSource: DataSource<T> | Observable<T[]> | T[];\n\n  /** The tree controller */\n  @Input() treeControl: TreeControl<T>;\n\n  /**\n   * Tracking function that will be used to check the differences in data changes. Used similarly\n   * to `ngFor` `trackBy` function. Optimize node operations by identifying a node based on its data\n   * relative to the function to know if a node should be added/removed/moved.\n   * Accepts a function that takes two parameters, `index` and `item`.\n   */\n  @Input() trackBy: TrackByFunction<T>;\n\n  // Outlets within the tree's template where the dataNodes will be inserted.\n  @ViewChild(CdkTreeNodeOutlet, {static: true}) _nodeOutlet: CdkTreeNodeOutlet;\n\n  /** The tree node template for the tree */\n  @ContentChildren(CdkTreeNodeDef) _nodeDefs: QueryList<CdkTreeNodeDef<T>>;\n\n  // TODO(tinayuangao): Setup a listener for scrolling, emit the calculated view to viewChange.\n  //     Remove the MAX_VALUE in viewChange\n  /**\n   * Stream containing the latest information on what rows are being displayed on screen.\n   * Can be used by the data source to as a heuristic of what data should be provided.\n   */\n  viewChange =\n    new BehaviorSubject<{start: number, end: number}>({start: 0, end: Number.MAX_VALUE});\n\n  constructor(private _differs: IterableDiffers,\n              private _changeDetectorRef: ChangeDetectorRef) {}\n\n  ngOnInit() {\n    this._dataDiffer = this._differs.find([]).create(this.trackBy);\n    if (!this.treeControl) {\n      throw getTreeControlMissingError();\n    }\n  }\n\n  ngOnDestroy() {\n    this._nodeOutlet.viewContainer.clear();\n\n    this._onDestroy.next();\n    this._onDestroy.complete();\n\n    if (this._dataSource && typeof (this._dataSource as DataSource<T>).disconnect === 'function') {\n      (this.dataSource as DataSource<T>).disconnect(this);\n    }\n\n    if (this._dataSubscription) {\n      this._dataSubscription.unsubscribe();\n      this._dataSubscription = null;\n    }\n  }\n\n  ngAfterContentChecked() {\n    const defaultNodeDefs = this._nodeDefs.filter(def => !def.when);\n    if (defaultNodeDefs.length > 1) {\n      throw getTreeMultipleDefaultNodeDefsError();\n    }\n    this._defaultNodeDef = defaultNodeDefs[0];\n\n    if (this.dataSource && this._nodeDefs && !this._dataSubscription) {\n      this._observeRenderChanges();\n    }\n  }\n\n\n  // TODO(tinayuangao): Work on keyboard traversal and actions, make sure it's working for RTL\n  //     and nested trees.\n\n  /**\n   * Switch to the provided data source by resetting the data and unsubscribing from the current\n   * render change subscription if one exists. If the data source is null, interpret this by\n   * clearing the node outlet. Otherwise start listening for new data.\n   */\n  private _switchDataSource(dataSource: DataSource<T> | Observable<T[]> | T[]) {\n    if (this._dataSource && typeof (this._dataSource as DataSource<T>).disconnect === 'function') {\n      (this.dataSource as DataSource<T>).disconnect(this);\n    }\n\n    if (this._dataSubscription) {\n      this._dataSubscription.unsubscribe();\n      this._dataSubscription = null;\n    }\n\n    // Remove the all dataNodes if there is now no data source\n    if (!dataSource) {\n      this._nodeOutlet.viewContainer.clear();\n    }\n\n    this._dataSource = dataSource;\n    if (this._nodeDefs) {\n      this._observeRenderChanges();\n    }\n  }\n\n  /** Set up a subscription for the data provided by the data source. */\n  private _observeRenderChanges() {\n    let dataStream: Observable<T[] | ReadonlyArray<T>> | undefined;\n\n    if (isDataSource(this._dataSource)) {\n      dataStream = this._dataSource.connect(this);\n    } else if (this._dataSource instanceof Observable) {\n      dataStream = this._dataSource;\n    } else if (Array.isArray(this._dataSource)) {\n      dataStream = observableOf(this._dataSource);\n    }\n\n    if (dataStream) {\n      this._dataSubscription = dataStream.pipe(takeUntil(this._onDestroy))\n        .subscribe(data => this.renderNodeChanges(data));\n    } else {\n      throw getTreeNoValidDataSourceError();\n    }\n  }\n\n  /** Check for changes made in the data and render each change (node added/removed/moved). */\n  renderNodeChanges(data: T[] | ReadonlyArray<T>, dataDiffer: IterableDiffer<T> = this._dataDiffer,\n                    viewContainer: ViewContainerRef = this._nodeOutlet.viewContainer,\n                    parentData?: T) {\n    const changes = dataDiffer.diff(data);\n    if (!changes) { return; }\n\n    changes.forEachOperation((item: IterableChangeRecord<T>,\n                              adjustedPreviousIndex: number | null,\n                              currentIndex: number | null) => {\n        if (item.previousIndex == null) {\n          this.insertNode(data[currentIndex!], currentIndex!, viewContainer, parentData);\n        } else if (currentIndex == null) {\n          viewContainer.remove(adjustedPreviousIndex!);\n          this._levels.delete(item.item);\n        } else {\n          const view = viewContainer.get(adjustedPreviousIndex!);\n          viewContainer.move(view!, currentIndex);\n        }\n      });\n\n    this._changeDetectorRef.detectChanges();\n  }\n\n  /**\n   * Finds the matching node definition that should be used for this node data. If there is only\n   * one node definition, it is returned. Otherwise, find the node definition that has a when\n   * predicate that returns true with the data. If none return true, return the default node\n   * definition.\n   */\n  _getNodeDef(data: T, i: number): CdkTreeNodeDef<T> {\n    if (this._nodeDefs.length === 1) { return this._nodeDefs.first; }\n\n    const nodeDef =\n      this._nodeDefs.find(def => def.when && def.when(i, data)) || this._defaultNodeDef;\n    if (!nodeDef) { throw getTreeMissingMatchingNodeDefError(); }\n\n    return nodeDef;\n  }\n\n  /**\n   * Create the embedded view for the data node template and place it in the correct index location\n   * within the data node view container.\n   */\n  insertNode(nodeData: T, index: number, viewContainer?: ViewContainerRef, parentData?: T) {\n    const node = this._getNodeDef(nodeData, index);\n\n    // Node context that will be provided to created embedded view\n    const context = new CdkTreeNodeOutletContext<T>(nodeData);\n\n    // If the tree is flat tree, then use the `getLevel` function in flat tree control\n    // Otherwise, use the level of parent node.\n    if (this.treeControl.getLevel) {\n      context.level = this.treeControl.getLevel(nodeData);\n    } else if (typeof parentData !== 'undefined' && this._levels.has(parentData)) {\n      context.level = this._levels.get(parentData)! + 1;\n    } else {\n      context.level = 0;\n    }\n    this._levels.set(nodeData, context.level);\n\n    // Use default tree nodeOutlet, or nested node's nodeOutlet\n    const container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;\n    container.createEmbeddedView(node.template, context, index);\n\n    // Set the data to just created `CdkTreeNode`.\n    // The `CdkTreeNode` created from `createEmbeddedView` will be saved in static variable\n    //     `mostRecentTreeNode`. We get it from static variable and pass the node data to it.\n    if (CdkTreeNode.mostRecentTreeNode) {\n      CdkTreeNode.mostRecentTreeNode.data = nodeData;\n    }\n  }\n}\n\n\n/**\n * Tree node for CdkTree. It contains the data in the tree node.\n */\n@Directive({\n  selector: 'cdk-tree-node',\n  exportAs: 'cdkTreeNode',\n  host: {\n    '[attr.aria-expanded]': 'isExpanded',\n    '[attr.aria-level]': 'role === \"treeitem\" ? level : null',\n    '[attr.role]': 'role',\n    'class': 'cdk-tree-node',\n  },\n})\nexport class CdkTreeNode<T> implements FocusableOption, OnDestroy {\n  /**\n   * The most recently created `CdkTreeNode`. We save it in static variable so we can retrieve it\n   * in `CdkTree` and set the data to it.\n   */\n  static mostRecentTreeNode: CdkTreeNode<any> | null = null;\n\n  /** Subject that emits when the component has been destroyed. */\n  protected _destroyed = new Subject<void>();\n\n  /** Emits when the node's data has changed. */\n  _dataChanges = new Subject<void>();\n\n  /** The tree node's data. */\n  get data(): T { return this._data; }\n  set data(value: T) {\n    if (value !== this._data) {\n      this._data = value;\n      this._setRoleFromData();\n      this._dataChanges.next();\n    }\n  }\n  protected _data: T;\n\n  get isExpanded(): boolean {\n    return this._tree.treeControl.isExpanded(this._data);\n  }\n\n  get level(): number {\n    return this._tree.treeControl.getLevel ? this._tree.treeControl.getLevel(this._data) : 0;\n  }\n\n  /**\n   * The role of the node should be 'group' if it's an internal node,\n   * and 'treeitem' if it's a leaf node.\n   */\n  @Input() role: 'treeitem' | 'group' = 'treeitem';\n\n  constructor(protected _elementRef: ElementRef<HTMLElement>,\n              protected _tree: CdkTree<T>) {\n    CdkTreeNode.mostRecentTreeNode = this as CdkTreeNode<T>;\n  }\n\n  ngOnDestroy() {\n    // If this is the last tree node being destroyed,\n    // clear out the reference to avoid leaking memory.\n    if (CdkTreeNode.mostRecentTreeNode === this) {\n      CdkTreeNode.mostRecentTreeNode = null;\n    }\n\n    this._dataChanges.complete();\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /** Focuses the menu item. Implements for FocusableOption. */\n  focus(): void {\n    this._elementRef.nativeElement.focus();\n  }\n\n  protected _setRoleFromData(): void {\n    if (this._tree.treeControl.isExpandable) {\n      this.role = this._tree.treeControl.isExpandable(this._data) ? 'group' : 'treeitem';\n    } else {\n      if (!this._tree.treeControl.getChildren) {\n        throw getTreeControlFunctionsMissingError();\n      }\n      const childrenNodes = this._tree.treeControl.getChildren(this._data);\n      if (Array.isArray(childrenNodes)) {\n        this._setRoleFromChildren(childrenNodes as T[]);\n      } else if (childrenNodes instanceof Observable) {\n        childrenNodes.pipe(takeUntil(this._destroyed))\n            .subscribe(children => this._setRoleFromChildren(children));\n      }\n    }\n  }\n\n  protected _setRoleFromChildren(children: T[]) {\n    this.role = children && children.length ? 'group' : 'treeitem';\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  AfterContentInit,\n  ContentChildren,\n  Directive,\n  ElementRef,\n  IterableDiffer,\n  IterableDiffers,\n  OnDestroy,\n  QueryList,\n} from '@angular/core';\nimport {Observable} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\n\nimport {CDK_TREE_NODE_OUTLET_NODE, CdkTreeNodeOutlet} from './outlet';\nimport {CdkTree, CdkTreeNode} from './tree';\nimport {getTreeControlFunctionsMissingError} from './tree-errors';\n\n/**\n * Nested node is a child of `<cdk-tree>`. It works with nested tree.\n * By using `cdk-nested-tree-node` component in tree node template, children of the parent node will\n * be added in the `cdkTreeNodeOutlet` in tree node template.\n * For example:\n *   ```html\n *   <cdk-nested-tree-node>\n *     {{node.name}}\n *     <ng-template cdkTreeNodeOutlet></ng-template>\n *   </cdk-nested-tree-node>\n *   ```\n * The children of node will be automatically added to `cdkTreeNodeOutlet`, the result dom will be\n * like this:\n *   ```html\n *   <cdk-nested-tree-node>\n *     {{node.name}}\n *      <cdk-nested-tree-node>{{child1.name}}</cdk-nested-tree-node>\n *      <cdk-nested-tree-node>{{child2.name}}</cdk-nested-tree-node>\n *   </cdk-nested-tree-node>\n *   ```\n */\n@Directive({\n  selector: 'cdk-nested-tree-node',\n  exportAs: 'cdkNestedTreeNode',\n  host: {\n    '[attr.aria-expanded]': 'isExpanded',\n    '[attr.role]': 'role',\n    'class': 'cdk-tree-node cdk-nested-tree-node',\n  },\n  providers: [\n    {provide: CdkTreeNode, useExisting: CdkNestedTreeNode},\n    {provide: CDK_TREE_NODE_OUTLET_NODE, useExisting: CdkNestedTreeNode}\n  ]\n})\nexport class CdkNestedTreeNode<T> extends CdkTreeNode<T> implements AfterContentInit, OnDestroy {\n  /** Differ used to find the changes in the data provided by the data source. */\n  private _dataDiffer: IterableDiffer<T>;\n\n  /** The children data dataNodes of current node. They will be placed in `CdkTreeNodeOutlet`. */\n  protected _children: T[];\n\n  /** The children node placeholder. */\n  @ContentChildren(CdkTreeNodeOutlet, {\n    // We need to use `descendants: true`, because Ivy will no longer match\n    // indirect descendants if it's left as false.\n    descendants: true\n  })\n  nodeOutlet: QueryList<CdkTreeNodeOutlet>;\n\n  constructor(protected _elementRef: ElementRef<HTMLElement>,\n              protected _tree: CdkTree<T>,\n              protected _differs: IterableDiffers) {\n    super(_elementRef, _tree);\n  }\n\n  ngAfterContentInit() {\n    this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);\n    if (!this._tree.treeControl.getChildren) {\n      throw getTreeControlFunctionsMissingError();\n    }\n    const childrenNodes = this._tree.treeControl.getChildren(this.data);\n    if (Array.isArray(childrenNodes)) {\n      this.updateChildrenNodes(childrenNodes as T[]);\n    } else if (childrenNodes instanceof Observable) {\n      childrenNodes.pipe(takeUntil(this._destroyed))\n        .subscribe(result => this.updateChildrenNodes(result));\n    }\n    this.nodeOutlet.changes.pipe(takeUntil(this._destroyed))\n        .subscribe(() => this.updateChildrenNodes());\n  }\n\n  ngOnDestroy() {\n    this._clear();\n    super.ngOnDestroy();\n  }\n\n  /** Add children dataNodes to the NodeOutlet */\n  protected updateChildrenNodes(children?: T[]): void {\n    const outlet = this._getNodeOutlet();\n    if (children) {\n      this._children = children;\n    }\n    if (outlet && this._children) {\n      const viewContainer = outlet.viewContainer;\n      this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);\n    } else {\n      // Reset the data differ if there's no children nodes displayed\n      this._dataDiffer.diff([]);\n    }\n  }\n\n  /** Clear the children dataNodes. */\n  protected _clear(): void {\n    const outlet = this._getNodeOutlet();\n    if (outlet) {\n      outlet.viewContainer.clear();\n      this._dataDiffer.diff([]);\n    }\n  }\n\n  /** Gets the outlet for the current node. */\n  private _getNodeOutlet() {\n    const outlets = this.nodeOutlet;\n\n    // Note that since we use `descendants: true` on the query, we have to ensure\n    // that we don't pick up the outlet of a child node by accident.\n    return outlets && outlets.find(outlet => !outlet._node || outlet._node === this);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directionality} from '@angular/cdk/bidi';\nimport {coerceNumberProperty} from '@angular/cdk/coercion';\nimport {Directive, ElementRef, Input, OnDestroy, Optional, Renderer2} from '@angular/core';\nimport {takeUntil} from 'rxjs/operators';\nimport {Subject} from 'rxjs';\nimport {CdkTree, CdkTreeNode} from './tree';\n\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n\n/**\n * Indent for the children tree dataNodes.\n * This directive will add left-padding to the node to show hierarchy.\n */\n@Directive({\n  selector: '[cdkTreeNodePadding]',\n})\nexport class CdkTreeNodePadding<T> implements OnDestroy {\n  /** Current padding value applied to the element. Used to avoid unnecessarily hitting the DOM. */\n  private _currentPadding: string|null;\n\n  /** Subject that emits when the component has been destroyed. */\n  private _destroyed = new Subject<void>();\n\n  /** CSS units used for the indentation value. */\n  indentUnits = 'px';\n\n  /** The level of depth of the tree node. The padding will be `level * indent` pixels. */\n  @Input('cdkTreeNodePadding')\n  get level(): number { return this._level; }\n  set level(value: number) {\n    // Set to null as the fallback value so that _setPadding can fall back to the node level if the\n    // consumer set the directive as `cdkTreeNodePadding=\"\"`. We still want to take this value if\n    // they set 0 explicitly.\n    this._level = coerceNumberProperty(value, null)!;\n    this._setPadding();\n  }\n  _level: number;\n\n  /**\n   * The indent for each level. Can be a number or a CSS string.\n   * Default number 40px from material design menu sub-menu spec.\n   */\n  @Input('cdkTreeNodePaddingIndent')\n  get indent(): number | string { return this._indent; }\n  set indent(indent: number | string) {\n    let value = indent;\n    let units = 'px';\n\n    if (typeof indent === 'string') {\n      const parts = indent.split(cssUnitPattern);\n      value = parts[0];\n      units = parts[1] || units;\n    }\n\n    this.indentUnits = units;\n    this._indent = coerceNumberProperty(value);\n    this._setPadding();\n  }\n  _indent: number = 40;\n\n  constructor(private _treeNode: CdkTreeNode<T>,\n              private _tree: CdkTree<T>,\n              private _renderer: Renderer2,\n              private _element: ElementRef<HTMLElement>,\n              @Optional() private _dir: Directionality) {\n    this._setPadding();\n    if (_dir) {\n      _dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => this._setPadding(true));\n    }\n\n    // In Ivy the indentation binding might be set before the tree node's data has been added,\n    // which means that we'll miss the first render. We have to subscribe to changes in the\n    // data to ensure that everything is up to date.\n    _treeNode._dataChanges.subscribe(() => this._setPadding());\n  }\n\n  ngOnDestroy() {\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /** The padding indent value for the tree node. Returns a string with px numbers if not null. */\n  _paddingIndent(): string|null {\n    const nodeLevel = (this._treeNode.data && this._tree.treeControl.getLevel)\n      ? this._tree.treeControl.getLevel(this._treeNode.data)\n      : null;\n    const level = this._level == null ? nodeLevel : this._level;\n    return typeof level === 'number' ? `${level * this._indent}${this.indentUnits}` : null;\n  }\n\n  _setPadding(forceChange = false) {\n    const padding = this._paddingIndent();\n\n    if (padding !== this._currentPadding || forceChange) {\n      const element = this._element.nativeElement;\n      const paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';\n      const resetProp = paddingProp === 'paddingLeft' ? 'paddingRight' : 'paddingLeft';\n      this._renderer.setStyle(element, paddingProp, padding);\n      this._renderer.setStyle(element, resetProp, null);\n      this._currentPadding = padding;\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {Directive, HostListener, Input} from '@angular/core';\n\nimport {CdkTree, CdkTreeNode} from './tree';\n\n/**\n * Node toggle to expand/collapse the node.\n */\n@Directive({selector: '[cdkTreeNodeToggle]'})\nexport class CdkTreeNodeToggle<T> {\n  /** Whether expand/collapse the node recursively. */\n  @Input('cdkTreeNodeToggleRecursive')\n  get recursive(): boolean { return this._recursive; }\n  set recursive(value: boolean) { this._recursive = coerceBooleanProperty(value); }\n  protected _recursive = false;\n\n  constructor(protected _tree: CdkTree<T>,\n              protected _treeNode: CdkTreeNode<T>) {}\n\n  // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n  // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n  // ViewEngine they're overwritten.\n  // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n  // tslint:disable-next-line:no-host-decorator-in-concrete\n  @HostListener('click', ['$event'])\n  _toggle(event: Event): void {\n    this.recursive\n      ? this._tree.treeControl.toggleDescendants(this._treeNode.data)\n      : this._tree.treeControl.toggle(this._treeNode.data);\n\n    event.stopPropagation();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {FocusMonitor} from '@angular/cdk/a11y';\nimport {CommonModule} from '@angular/common';\nimport {NgModule} from '@angular/core';\nimport {CdkTreeNodeOutlet} from './outlet';\nimport {CdkTreeNodePadding} from './padding';\nimport {CdkTreeNodeToggle} from './toggle';\nimport {CdkTree, CdkTreeNode} from './tree';\nimport {CdkTreeNodeDef} from './node';\nimport {CdkNestedTreeNode} from './nested-node';\n\nconst EXPORTED_DECLARATIONS = [\n  CdkNestedTreeNode,\n  CdkTreeNodeDef,\n  CdkTreeNodePadding,\n  CdkTreeNodeToggle,\n  CdkTree,\n  CdkTreeNode,\n  CdkTreeNodeOutlet,\n];\n\n@NgModule({\n  imports: [CommonModule],\n  exports: EXPORTED_DECLARATIONS,\n  declarations: EXPORTED_DECLARATIONS,\n  providers: [FocusMonitor, CdkTreeNodeDef]\n})\nexport class CdkTreeModule {}\n"]},"metadata":{},"sourceType":"module"}