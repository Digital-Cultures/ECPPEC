{"ast":null,"code":"import _inherits from \"/Users/ntws2/Dropbox/htdocs/ECCPEC_code/SITE_VERSIONS/ECPPEC/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/ntws2/Dropbox/htdocs/ECCPEC_code/SITE_VERSIONS/ECPPEC/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _createForOfIteratorHelper from \"/Users/ntws2/Dropbox/htdocs/ECCPEC_code/SITE_VERSIONS/ECPPEC/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _createClass from \"/Users/ntws2/Dropbox/htdocs/ECCPEC_code/SITE_VERSIONS/ECPPEC/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/ntws2/Dropbox/htdocs/ECCPEC_code/SITE_VERSIONS/ECPPEC/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { Subject } from 'rxjs/Subject';\nimport 'rxjs/Subscription';\nimport { Renderer2, Directive, ElementRef, HostBinding, Component, ViewChild, HostListener, Input, EventEmitter, Output, ContentChild, ChangeDetectorRef, forwardRef, NgZone, NgModule } from '@angular/core';\nimport { throttleTime, tap, distinctUntilChanged, filter } from 'rxjs/operators';\nimport detectPassiveEvents from 'detect-passive-events';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** @enum {number} */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nvar _c0 = [\"tooltipTemplate\"];\nvar _c1 = [\"leftOuterSelectionBar\"];\nvar _c2 = [\"rightOuterSelectionBar\"];\nvar _c3 = [\"fullBar\"];\nvar _c4 = [\"selectionBar\"];\nvar _c5 = [\"minHandle\"];\nvar _c6 = [\"maxHandle\"];\nvar _c7 = [\"floorLabel\"];\nvar _c8 = [\"ceilLabel\"];\nvar _c9 = [\"minHandleLabel\"];\nvar _c10 = [\"maxHandleLabel\"];\nvar _c11 = [\"combinedLabel\"];\nvar _c12 = [\"ticksElement\"];\n\nfunction SliderComponent_span_28_ng5_slider_tooltip_wrapper_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"ng5-slider-tooltip-wrapper\", 31);\n  }\n\n  if (rf & 2) {\n    var t_r13 = ɵngcc0.ɵɵnextContext().$implicit;\n    var ctx_r14 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"template\", ctx_r14.tooltipTemplate)(\"tooltip\", t_r13.valueTooltip)(\"placement\", t_r13.valueTooltipPlacement)(\"content\", t_r13.value);\n  }\n}\n\nfunction SliderComponent_span_28_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 32);\n  }\n\n  if (rf & 2) {\n    var t_r13 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵproperty(\"innerHTML\", t_r13.legend, ɵngcc0.ɵɵsanitizeHtml);\n  }\n}\n\nvar _c13 = function _c13(a0) {\n  return {\n    \"ng5-slider-selected\": a0\n  };\n};\n\nfunction SliderComponent_span_28_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 27);\n    ɵngcc0.ɵɵelement(1, \"ng5-slider-tooltip-wrapper\", 28);\n    ɵngcc0.ɵɵtemplate(2, SliderComponent_span_28_ng5_slider_tooltip_wrapper_2_Template, 1, 4, \"ng5-slider-tooltip-wrapper\", 29);\n    ɵngcc0.ɵɵtemplate(3, SliderComponent_span_28_span_3_Template, 1, 1, \"span\", 30);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var t_r13 = ctx.$implicit;\n    var ctx_r12 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(7, _c13, t_r13.selected))(\"ngStyle\", t_r13.style);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"template\", ctx_r12.tooltipTemplate)(\"tooltip\", t_r13.tooltip)(\"placement\", t_r13.tooltipPlacement);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", t_r13.value != null);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", t_r13.legend != null);\n  }\n}\n\nfunction TooltipWrapperComponent_ng_container_0_1_ng_template_0_Template(rf, ctx) {}\n\nfunction TooltipWrapperComponent_ng_container_0_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, TooltipWrapperComponent_ng_container_0_1_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nvar _c14 = function _c14(a0, a1, a2) {\n  return {\n    tooltip: a0,\n    placement: a1,\n    content: a2\n  };\n};\n\nfunction TooltipWrapperComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TooltipWrapperComponent_ng_container_0_1_Template, 1, 0, undefined, 1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction3(2, _c14, ctx_r0.tooltip, ctx_r0.placement, ctx_r0.content));\n  }\n}\n\nfunction TooltipWrapperComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"div\", 2);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵattribute(\"title\", ctx_r1.tooltip)(\"data-tooltip-placement\", ctx_r1.placement);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r1.content, \" \");\n  }\n}\n\nvar PointerType = {\n  /** Low pointer */\n  Min: 0,\n\n  /** High pointer */\n  Max: 1\n};\nPointerType[PointerType.Min] = \"Min\";\nPointerType[PointerType.Max] = \"Max\";\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** @enum {number} */\n\nvar LabelType = {\n  /** Label above low pointer */\n  Low: 0,\n\n  /** Label above high pointer */\n  High: 1,\n\n  /** Label for minimum slider value */\n  Floor: 2,\n\n  /** Label for maximum slider value */\n  Ceil: 3,\n\n  /** Label below legend tick */\n  TickValue: 4\n};\nLabelType[LabelType.Low] = \"Low\";\nLabelType[LabelType.High] = \"High\";\nLabelType[LabelType.Floor] = \"Floor\";\nLabelType[LabelType.Ceil] = \"Ceil\";\nLabelType[LabelType.TickValue] = \"TickValue\";\n/**\n * Custom step definition\n *\n * This can be used to specify custom values and legend values for slider ticks\n * @record\n */\n\n/**\n * Slider options\n */\n\nvar Options = function Options() {\n  _classCallCheck(this, Options);\n\n  /**\n   * Minimum value for a slider.\n   * Not applicable when using stepsArray.\n   */\n  this.floor = 0;\n  /**\n   * Maximum value for a slider.\n   * Not applicable when using stepsArray.\n   */\n\n  this.ceil = null;\n  /**\n   * Step between each value.\n   * Not applicable when using stepsArray.\n   */\n\n  this.step = 1;\n  /**\n   * The minimum range authorized on the slider.\n   * Applies to range slider only.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n\n  this.minRange = null;\n  /**\n   * The maximum range authorized on the slider.\n   * Applies to range slider only.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n\n  this.maxRange = null;\n  /**\n   * Set to true to have a push behavior. When the min handle goes above the max,\n   * the max is moved as well (and vice-versa). The range between min and max is\n   * defined by the step option (defaults to 1) and can also be overriden by\n   * the minRange option. Applies to range slider only.\n   */\n\n  this.pushRange = false;\n  /**\n   * The minimum value authorized on the slider.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n\n  this.minLimit = null;\n  /**\n   * The maximum value authorized on the slider.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n\n  this.maxLimit = null;\n  /**\n   * Custom translate function. Use this if you want to translate values displayed\n   * on the slider.\n   */\n\n  this.translate = null;\n  /**\n   * Custom function for combining overlapping labels in range slider.\n   * It takes the min and max values (already translated with translate fuction)\n   * and should return how these two values should be combined.\n   * If not provided, the default function will join the two values with\n   * ' - ' as separator.\n   */\n\n  this.combineLabels = null;\n  /**\n   * Use to display legend under ticks (thus, it needs to be used along with\n   * showTicks or showTicksValues). The function will be called with each tick\n   * value and returned content will be displayed under the tick as a legend.\n   * If the returned value is null, then no legend is displayed under\n   * the corresponding tick.You can also directly provide the legend values\n   * in the stepsArray option.\n   */\n\n  this.getLegend = null;\n  /**\n   * If you want to display a slider with non linear/number steps.\n   * Just pass an array with each slider value and that's it; the floor, ceil and step settings\n   * of the slider will be computed automatically.\n   * By default, the value model and valueHigh model values will be the value of the selected item\n   * in the stepsArray.\n   * They can also be bound to the index of the selected item by setting the bindIndexForStepsArray\n   * option to true.\n   */\n\n  this.stepsArray = null;\n  /**\n   * Set to true to bind the index of the selected item to value model and valueHigh model.\n   */\n\n  this.bindIndexForStepsArray = false;\n  /**\n   * When set to true and using a range slider, the range can be dragged by the selection bar.\n   * Applies to range slider only.\n   */\n\n  this.draggableRange = false;\n  /**\n   * Same as draggableRange but the slider range can't be changed.\n   * Applies to range slider only.\n   */\n\n  this.draggableRangeOnly = false;\n  /**\n   * Set to true to always show the selection bar before the slider handle.\n   */\n\n  this.showSelectionBar = false;\n  /**\n   * Set to true to always show the selection bar after the slider handle.\n   */\n\n  this.showSelectionBarEnd = false;\n  /**\n   * Set a number to draw the selection bar between this value and the slider handle.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n\n  this.showSelectionBarFromValue = null;\n  /**\n   * Only for range slider. Set to true to visualize in different colour the areas\n   * on the left/right (top/bottom for vertical range slider) of selection bar between the handles.\n   */\n\n  this.showOuterSelectionBars = false;\n  /**\n   * Set to true to hide pointer labels\n   */\n\n  this.hidePointerLabels = false;\n  /**\n   * Set to true to hide min / max labels\n   */\n\n  this.hideLimitLabels = false;\n  /**\n   * Set to false to disable the auto-hiding behavior of the limit labels.\n   */\n\n  this.autoHideLimitLabels = true;\n  /**\n   * Set to true to make the slider read-only.\n   */\n\n  this.readOnly = false;\n  /**\n   * Set to true to disable the slider.\n   */\n\n  this.disabled = false;\n  /**\n   * Throttle interval for mouse events in milliseconds.\n   * This is provided to avoid a flood of events when moving the slider with mouse.\n   */\n\n  this.mouseEventsInterval = 50;\n  /**\n   * Throttle interval for touch events in milliseconds.\n   * This is provided to avoid a flood of events when moving the slider with touch gesture.\n   */\n\n  this.touchEventsInterval = 50;\n  /**\n   * Throttle interval for input changes (changes to bindings or reactive form inputs)\n   * This is provided to avoid a flood of events on frequent input binding changes affecting performance.\n   */\n\n  this.inputEventsInterval = 100;\n  /**\n   * Throttle interval for output changes (signalling changes to output bindings and user callbacks)\n   * This is provided to avoid a flood of outgoing events affecting Angular app performance.\n   */\n\n  this.outputEventsInterval = 100;\n  /**\n   * Set to true to display a tick for each step of the slider.\n   */\n\n  this.showTicks = false;\n  /**\n   * Set to true to display a tick and the step value for each step of the slider..\n   */\n\n  this.showTicksValues = false;\n  /* The step between each tick to display. If not set, the step value is used.\n      Not used when ticksArray is specified. */\n\n  this.tickStep = null;\n  /* The step between displaying each tick step value. */\n\n  this.tickValueStep = 1;\n  /**\n   * Use to display ticks at specific positions.\n   * The array contains the index of the ticks that should be displayed.\n   * For example, [0, 1, 5] will display a tick for the first, second and sixth values.\n   */\n\n  this.ticksArray = null;\n  /**\n   * Used to display a tooltip when a tick is hovered.\n   * Set to a function that returns the tooltip content for a given value.\n   */\n\n  this.ticksTooltip = null;\n  /**\n   * Same as ticksTooltip but for ticks values.\n   */\n\n  this.ticksValuesTooltip = null;\n  /**\n   * Set to true to display the slider vertically.\n   * The slider will take the full height of its parent.\n   * Changing this value at runtime is not currently supported.\n   */\n\n  this.vertical = false;\n  /**\n   * Function that returns the current color of the selection bar.\n   * If your color won't change, don't use this option but set it through CSS.\n   * If the returned color depends on a model value (either value or valueHigh),\n   * you should use the argument passed to the function.\n   * Indeed, when the function is called, there is no certainty that the model\n   * has already been updated.\n   */\n\n  this.getSelectionBarColor = null;\n  /**\n   * Function that returns the color of a tick. showTicks must be enabled.\n   */\n\n  this.getTickColor = null;\n  /**\n   * Function that returns the current color of a pointer.\n   * If your color won't change, don't use this option but set it through CSS.\n   * If the returned color depends on a model value (either value or valueHigh),\n   * you should use the argument passed to the function.\n   * Indeed, when the function is called, there is no certainty that the model has already been updated.\n   * To handle range slider pointers independently, you should evaluate pointerType within the given\n   * function where \"min\" stands for value model and \"max\" for valueHigh model values.\n   */\n\n  this.getPointerColor = null;\n  /**\n   * Handles are focusable (on click or with tab) and can be modified using the following keyboard controls:\n   * Left/bottom arrows: -1\n   * Right/top arrows: +1\n   * Page-down: -10%\n   * Page-up: +10%\n   * Home: minimum value\n   * End: maximum value\n   */\n\n  this.keyboardSupport = true;\n  /**\n   * If you display the slider in an element that uses transform: scale(0.5), set the scale value to 2\n   * so that the slider is rendered properly and the events are handled correctly.\n   */\n\n  this.scale = 1;\n  /**\n   * Set to true to force the value to be rounded to the step, even when modified from the outside.\n   * When set to false, if the model values are modified from outside the slider, they are not rounded\n   * and can be between two steps.\n   */\n\n  this.enforceStep = true;\n  /**\n   * Set to true to force the value to be normalised to allowed range (floor to ceil), even when modified from the outside.\n   * When set to false, if the model values are modified from outside the slider, and they are outside allowed range,\n   * the slider may be rendered incorrectly. However, setting this to false may be useful if you want to perform custom normalisation.\n   */\n\n  this.enforceRange = true;\n  /**\n   * Set to true to prevent to user from switching the min and max handles. Applies to range slider only.\n   */\n\n  this.noSwitching = false;\n  /**\n   * Set to true to only bind events on slider handles.\n   */\n\n  this.onlyBindHandles = false;\n  /**\n   * Set to true to show graphs right to left.\n   * If vertical is true it will be from top to bottom and left / right arrow functions reversed.\n   */\n\n  this.rightToLeft = false;\n  /**\n   * Set to true to reverse keyboard navigation:\n   * Right/top arrows: -1\n   * Left/bottom arrows: +1\n   * Page-up: -10%\n   * Page-down: +10%\n   * End: minimum value\n   * Home: maximum value\n   */\n\n  this.reversedControls = false;\n  /**\n   * Set to true to keep the slider labels inside the slider bounds.\n   */\n\n  this.boundPointerLabels = true;\n  /**\n   * Set to true to use a logarithmic scale to display the slider.\n   */\n\n  this.logScale = false;\n  /**\n   * Function that returns the position on the slider for a given value.\n   * The position must be a percentage between 0 and 1.\n   * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.\n   */\n\n  this.customValueToPosition = null;\n  /**\n   * Function that returns the value for a given position on the slider.\n   * The position is a percentage between 0 and 1.\n   * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.\n   */\n\n  this.customPositionToValue = null;\n  /**\n   * Precision limit for calculated values.\n   * Values used in calculations will be rounded to this number of significant digits\n   * to prevent accumulating small floating-point errors.\n   */\n\n  this.precisionLimit = 12;\n  /**\n   * Use to display the selection bar as a gradient.\n   * The given object must contain from and to properties which are colors.\n   */\n\n  this.selectionBarGradient = null;\n  /**\n   * Use to add a label directly to the slider for accessibility. Adds the aria-label attribute.\n   */\n\n  this.ariaLabel = null;\n  /**\n   * Use instead of ariaLabel to reference the id of an element which will be used to label the slider.\n   * Adds the aria-labelledby attribute.\n   */\n\n  this.ariaLabelledBy = null;\n  /**\n   * Use to add a label directly to the slider range for accessibility. Adds the aria-label attribute.\n   */\n\n  this.ariaLabelHigh = null;\n  /**\n   * Use instead of ariaLabelHigh to reference the id of an element which will be used to label the slider range.\n   * Adds the aria-labelledby attribute.\n   */\n\n  this.ariaLabelledByHigh = null;\n  /**\n   * Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the handle\n   */\n\n  this.handleDimension = null;\n  /**\n   * Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the bar\n   */\n\n  this.barDimension = null;\n  /**\n   * Enable/disable CSS animations\n   */\n\n  this.animate = true;\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar ChangeContext = function ChangeContext() {\n  _classCallCheck(this, ChangeContext);\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n *  Collection of functions to handle conversions/lookups of values\n */\n\n\nvar ValueHelper = /*#__PURE__*/function () {\n  function ValueHelper() {\n    _classCallCheck(this, ValueHelper);\n  }\n\n  _createClass(ValueHelper, null, [{\n    key: \"isNullOrUndefined\",\n\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    value: function isNullOrUndefined(value) {\n      return value === undefined || value === null;\n    }\n    /**\n     * @param {?} val\n     * @param {?} minVal\n     * @param {?} maxVal\n     * @return {?}\n     */\n\n  }, {\n    key: \"linearValueToPosition\",\n    value: function linearValueToPosition(val, minVal, maxVal) {\n      var\n      /** @type {?} */\n      range = maxVal - minVal;\n      return (val - minVal) / range;\n    }\n    /**\n     * @param {?} val\n     * @param {?} minVal\n     * @param {?} maxVal\n     * @return {?}\n     */\n\n  }, {\n    key: \"logValueToPosition\",\n    value: function logValueToPosition(val, minVal, maxVal) {\n      val = Math.log(val);\n      minVal = Math.log(minVal);\n      maxVal = Math.log(maxVal);\n      var\n      /** @type {?} */\n      range = maxVal - minVal;\n      return (val - minVal) / range;\n    }\n    /**\n     * @param {?} percent\n     * @param {?} minVal\n     * @param {?} maxVal\n     * @return {?}\n     */\n\n  }, {\n    key: \"linearPositionToValue\",\n    value: function linearPositionToValue(percent, minVal, maxVal) {\n      return percent * (maxVal - minVal) + minVal;\n    }\n    /**\n     * @param {?} percent\n     * @param {?} minVal\n     * @param {?} maxVal\n     * @return {?}\n     */\n\n  }, {\n    key: \"logPositionToValue\",\n    value: function logPositionToValue(percent, minVal, maxVal) {\n      minVal = Math.log(minVal);\n      maxVal = Math.log(maxVal);\n      var\n      /** @type {?} */\n      value = percent * (maxVal - minVal) + minVal;\n      return Math.exp(value);\n    }\n    /**\n     * @param {?} modelValue\n     * @param {?} stepsArray\n     * @return {?}\n     */\n\n  }, {\n    key: \"findStepIndex\",\n    value: function findStepIndex(modelValue, stepsArray) {\n      var\n      /** @type {?} */\n      differences = stepsArray.map(function (step) {\n        return Math.abs(modelValue - step.value);\n      });\n      var\n      /** @type {?} */\n      minDifferenceIndex = 0;\n\n      for (var\n      /** @type {?} */\n      index = 0; index < stepsArray.length; index++) {\n        if (differences[index] !== differences[minDifferenceIndex] && differences[index] < differences[minDifferenceIndex]) {\n          minDifferenceIndex = index;\n        }\n      }\n\n      return minDifferenceIndex;\n    }\n  }]);\n\n  return ValueHelper;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Helper with compatibility functions to support different browsers\n */\n\n\nvar CompatibilityHelper = /*#__PURE__*/function () {\n  function CompatibilityHelper() {\n    _classCallCheck(this, CompatibilityHelper);\n  }\n\n  _createClass(CompatibilityHelper, null, [{\n    key: \"isTouchEvent\",\n\n    /**\n     * Workaround for TouchEvent constructor sadly not being available on all browsers (e.g. Firefox, Safari)\n     * @param {?} event\n     * @return {?}\n     */\n    value: function isTouchEvent(event) {\n      if (\n      /** @type {?} */\n      window.TouchEvent !== undefined) {\n        return event instanceof TouchEvent;\n      }\n\n      return event.touches !== undefined;\n    }\n    /**\n     * Detect presence of ResizeObserver API\n     * @return {?}\n     */\n\n  }, {\n    key: \"isResizeObserverAvailable\",\n    value: function isResizeObserverAvailable() {\n      return (\n        /** @type {?} */\n        window.ResizeObserver !== undefined\n      );\n    }\n  }]);\n\n  return CompatibilityHelper;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Helper with mathematical functions\n */\n\n\nvar MathHelper = /*#__PURE__*/function () {\n  function MathHelper() {\n    _classCallCheck(this, MathHelper);\n  }\n\n  _createClass(MathHelper, null, [{\n    key: \"roundToPrecisionLimit\",\n\n    /**\n     * @param {?} value\n     * @param {?} precisionLimit\n     * @return {?}\n     */\n    value: function roundToPrecisionLimit(value, precisionLimit) {\n      return +value.toPrecision(precisionLimit);\n    }\n    /**\n     * @param {?} value\n     * @param {?} floor\n     * @param {?} ceil\n     * @return {?}\n     */\n\n  }, {\n    key: \"clampToRange\",\n    value: function clampToRange(value, floor, ceil) {\n      return Math.min(Math.max(value, floor), ceil);\n    }\n  }]);\n\n  return MathHelper;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar EventListener = function EventListener() {\n  _classCallCheck(this, EventListener);\n\n  this.eventName = null;\n  this.events = null;\n  this.eventsSubscription = null;\n  this.teardownCallback = null;\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Helper class to attach event listeners to DOM elements with debounce support using rxjs\n */\n\n\nvar EventListenerHelper = /*#__PURE__*/function () {\n  /**\n   * @param {?} renderer\n   */\n  function EventListenerHelper(renderer) {\n    _classCallCheck(this, EventListenerHelper);\n\n    this.renderer = renderer;\n  }\n  /**\n   * @param {?} nativeElement\n   * @param {?} eventName\n   * @param {?} callback\n   * @param {?=} throttleInterval\n   * @return {?}\n   */\n\n\n  _createClass(EventListenerHelper, [{\n    key: \"attachPassiveEventListener\",\n    value: function attachPassiveEventListener(nativeElement, eventName, callback, throttleInterval) {\n      // Only use passive event listeners if the browser supports it\n      if (detectPassiveEvents.hasSupport !== true) {\n        return this.attachEventListener(nativeElement, eventName, callback, throttleInterval);\n      } // Angular doesn't support passive event handlers (yet), so we need to roll our own code using native functions\n\n\n      var\n      /** @type {?} */\n      listener = new EventListener();\n      listener.eventName = eventName;\n      listener.events = new Subject();\n\n      var\n      /** @type {?} */\n      observerCallback = function observerCallback(event) {\n        listener.events.next(event);\n      };\n\n      nativeElement.addEventListener(eventName, observerCallback, {\n        passive: true,\n        capture: false\n      });\n\n      listener.teardownCallback = function () {\n        nativeElement.removeEventListener(eventName, observerCallback, {\n          passive: true,\n          capture: false\n        });\n      };\n\n      listener.eventsSubscription = listener.events.pipe(!ValueHelper.isNullOrUndefined(throttleInterval) ? throttleTime(throttleInterval, undefined, {\n        leading: true,\n        trailing: true\n      }) : tap(function () {}) // no-op\n      ).subscribe(function (event) {\n        callback(event);\n      });\n      return listener;\n    }\n    /**\n     * @param {?} eventListener\n     * @return {?}\n     */\n\n  }, {\n    key: \"detachEventListener\",\n    value: function detachEventListener(eventListener) {\n      if (!ValueHelper.isNullOrUndefined(eventListener.eventsSubscription)) {\n        eventListener.eventsSubscription.unsubscribe();\n        eventListener.eventsSubscription = null;\n      }\n\n      if (!ValueHelper.isNullOrUndefined(eventListener.events)) {\n        eventListener.events.complete();\n        eventListener.events = null;\n      }\n\n      if (!ValueHelper.isNullOrUndefined(eventListener.teardownCallback)) {\n        eventListener.teardownCallback();\n        eventListener.teardownCallback = null;\n      }\n    }\n    /**\n     * @param {?} nativeElement\n     * @param {?} eventName\n     * @param {?} callback\n     * @param {?=} throttleInterval\n     * @return {?}\n     */\n\n  }, {\n    key: \"attachEventListener\",\n    value: function attachEventListener(nativeElement, eventName, callback, throttleInterval) {\n      var\n      /** @type {?} */\n      listener = new EventListener();\n      listener.eventName = eventName;\n      listener.events = new Subject();\n\n      var\n      /** @type {?} */\n      observerCallback = function observerCallback(event) {\n        listener.events.next(event);\n      };\n\n      listener.teardownCallback = this.renderer.listen(nativeElement, eventName, observerCallback);\n      listener.eventsSubscription = listener.events.pipe(!ValueHelper.isNullOrUndefined(throttleInterval) ? throttleTime(throttleInterval, undefined, {\n        leading: true,\n        trailing: true\n      }) : tap(function () {}) // no-op\n      ).subscribe(function (event) {\n        callback(event);\n      });\n      return listener;\n    }\n  }]);\n\n  return EventListenerHelper;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar SliderElementDirective = /*#__PURE__*/function () {\n  /**\n   * @param {?} elemRef\n   * @param {?} renderer\n   */\n  function SliderElementDirective(elemRef, renderer) {\n    _classCallCheck(this, SliderElementDirective);\n\n    this.elemRef = elemRef;\n    this.renderer = renderer;\n    this._position = 0;\n    this._dimension = 0;\n    this._alwaysHide = false;\n    this._vertical = false;\n    this._scale = 1;\n    this.opacity = 1;\n    this.visibility = 'visible';\n    this.left = '';\n    this.bottom = '';\n    this.height = '';\n    this.width = '';\n    this.eventListeners = [];\n    this.eventListenerHelper = new EventListenerHelper(this.renderer);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(SliderElementDirective, [{\n    key: \"setAlwaysHide\",\n\n    /**\n     * @param {?} hide\n     * @return {?}\n     */\n    value: function setAlwaysHide(hide) {\n      this._alwaysHide = hide;\n\n      if (hide) {\n        this.visibility = 'hidden';\n      } else {\n        this.visibility = 'visible';\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      this.opacity = 0;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"show\",\n    value: function show() {\n      if (this.alwaysHide) {\n        return;\n      }\n\n      this.opacity = 1;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      if (this.alwaysHide) {\n        return false;\n      }\n\n      return this.opacity !== 0;\n    }\n    /**\n     * @param {?} vertical\n     * @return {?}\n     */\n\n  }, {\n    key: \"setVertical\",\n    value: function setVertical(vertical) {\n      this._vertical = vertical;\n\n      if (this._vertical) {\n        this.left = '';\n        this.width = '';\n      } else {\n        this.bottom = '';\n        this.height = '';\n      }\n    }\n    /**\n     * @param {?} scale\n     * @return {?}\n     */\n\n  }, {\n    key: \"setScale\",\n    value: function setScale(scale) {\n      this._scale = scale;\n    }\n    /**\n     * @param {?} pos\n     * @return {?}\n     */\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(pos) {\n      this._position = pos;\n\n      if (this._vertical) {\n        this.bottom = Math.round(pos) + 'px';\n      } else {\n        this.left = Math.round(pos) + 'px';\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"calculateDimension\",\n    value: function calculateDimension() {\n      var\n      /** @type {?} */\n      val = this.getBoundingClientRect();\n\n      if (this.vertical) {\n        this._dimension = (val.bottom - val.top) * this.scale;\n      } else {\n        this._dimension = (val.right - val.left) * this.scale;\n      }\n    }\n    /**\n     * @param {?} dim\n     * @return {?}\n     */\n\n  }, {\n    key: \"setDimension\",\n    value: function setDimension(dim) {\n      this._dimension = dim;\n\n      if (this._vertical) {\n        this.height = Math.round(dim) + 'px';\n      } else {\n        this.width = Math.round(dim) + 'px';\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"getBoundingClientRect\",\n    value: function getBoundingClientRect() {\n      return this.elemRef.nativeElement.getBoundingClientRect();\n    }\n    /**\n     * @param {?} eventName\n     * @param {?} callback\n     * @param {?=} debounceInterval\n     * @return {?}\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(eventName, callback, debounceInterval) {\n      var\n      /** @type {?} */\n      listener = this.eventListenerHelper.attachEventListener(this.elemRef.nativeElement, eventName, callback, debounceInterval);\n      this.eventListeners.push(listener);\n    }\n    /**\n     * @param {?} eventName\n     * @param {?} callback\n     * @param {?=} debounceInterval\n     * @return {?}\n     */\n\n  }, {\n    key: \"onPassive\",\n    value: function onPassive(eventName, callback, debounceInterval) {\n      var\n      /** @type {?} */\n      listener = this.eventListenerHelper.attachPassiveEventListener(this.elemRef.nativeElement, eventName, callback, debounceInterval);\n      this.eventListeners.push(listener);\n    }\n    /**\n     * @param {?=} eventName\n     * @return {?}\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(eventName) {\n      var\n      /** @type {?} */\n      listenersToKeep;\n      var\n      /** @type {?} */\n      listenersToRemove;\n\n      if (!ValueHelper.isNullOrUndefined(eventName)) {\n        listenersToKeep = this.eventListeners.filter(function (event) {\n          return event.eventName !== eventName;\n        });\n        listenersToRemove = this.eventListeners.filter(function (event) {\n          return event.eventName === eventName;\n        });\n      } else {\n        listenersToKeep = [];\n        listenersToRemove = this.eventListeners;\n      }\n\n      var _iterator = _createForOfIteratorHelper(listenersToRemove),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var listener = _step.value;\n          this.eventListenerHelper.detachEventListener(listener);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.eventListeners = listenersToKeep;\n    }\n  }, {\n    key: \"position\",\n    get: function get() {\n      return this._position;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"dimension\",\n    get: function get() {\n      return this._dimension;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"alwaysHide\",\n    get: function get() {\n      return this._alwaysHide;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"vertical\",\n    get: function get() {\n      return this._vertical;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"scale\",\n    get: function get() {\n      return this._scale;\n    }\n  }]);\n\n  return SliderElementDirective;\n}();\n\nSliderElementDirective.ɵfac = function SliderElementDirective_Factory(t) {\n  return new (t || SliderElementDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n};\n\nSliderElementDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: SliderElementDirective,\n  selectors: [[\"\", \"ng5SliderElement\", \"\"]],\n  hostVars: 12,\n  hostBindings: function SliderElementDirective_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵstyleProp(\"opacity\", ctx.opacity)(\"visibility\", ctx.visibility)(\"left\", ctx.left)(\"bottom\", ctx.bottom)(\"height\", ctx.height)(\"width\", ctx.width);\n    }\n  }\n});\n/** @nocollapse */\n\nSliderElementDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: Renderer2\n  }];\n};\n\nSliderElementDirective.propDecorators = {\n  \"opacity\": [{\n    type: HostBinding,\n    args: ['style.opacity']\n  }],\n  \"visibility\": [{\n    type: HostBinding,\n    args: ['style.visibility']\n  }],\n  \"left\": [{\n    type: HostBinding,\n    args: ['style.left']\n  }],\n  \"bottom\": [{\n    type: HostBinding,\n    args: ['style.bottom']\n  }],\n  \"height\": [{\n    type: HostBinding,\n    args: ['style.height']\n  }],\n  \"width\": [{\n    type: HostBinding,\n    args: ['style.width']\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SliderElementDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ng5SliderElement]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.Renderer2\n    }];\n  }, {\n    opacity: [{\n      type: HostBinding,\n      args: ['style.opacity']\n    }],\n    visibility: [{\n      type: HostBinding,\n      args: ['style.visibility']\n    }],\n    left: [{\n      type: HostBinding,\n      args: ['style.left']\n    }],\n    bottom: [{\n      type: HostBinding,\n      args: ['style.bottom']\n    }],\n    height: [{\n      type: HostBinding,\n      args: ['style.height']\n    }],\n    width: [{\n      type: HostBinding,\n      args: ['style.width']\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar SliderHandleDirective = /*#__PURE__*/function (_SliderElementDirecti) {\n  _inherits(SliderHandleDirective, _SliderElementDirecti);\n\n  var _super = _createSuper(SliderHandleDirective);\n\n  /**\n   * @param {?} elemRef\n   * @param {?} renderer\n   */\n  function SliderHandleDirective(elemRef, renderer) {\n    var _this;\n\n    _classCallCheck(this, SliderHandleDirective);\n\n    _this = _super.call(this, elemRef, renderer);\n    _this.active = false;\n    _this.role = '';\n    _this.tabindex = '';\n    _this.ariaOrientation = '';\n    _this.ariaLabel = '';\n    _this.ariaLabelledBy = '';\n    _this.ariaValueNow = '';\n    _this.ariaValueText = '';\n    _this.ariaValueMin = '';\n    _this.ariaValueMax = '';\n    return _this;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(SliderHandleDirective, [{\n    key: \"focus\",\n    value: function focus() {\n      this.elemRef.nativeElement.focus();\n    }\n  }]);\n\n  return SliderHandleDirective;\n}(SliderElementDirective);\n\nSliderHandleDirective.ɵfac = function SliderHandleDirective_Factory(t) {\n  return new (t || SliderHandleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n};\n\nSliderHandleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: SliderHandleDirective,\n  selectors: [[\"\", \"ng5SliderHandle\", \"\"]],\n  hostVars: 11,\n  hostBindings: function SliderHandleDirective_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"role\", ctx.role)(\"tabindex\", ctx.tabindex)(\"aria-orientation\", ctx.ariaOrientation)(\"aria-label\", ctx.ariaLabel)(\"aria-labelledby\", ctx.ariaLabelledBy)(\"aria-valuenow\", ctx.ariaValueNow)(\"aria-valuetext\", ctx.ariaValueText)(\"aria-valuemin\", ctx.ariaValueMin)(\"aria-valuemax\", ctx.ariaValueMax);\n      ɵngcc0.ɵɵclassProp(\"ng5-slider-active\", ctx.active);\n    }\n  },\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n/** @nocollapse */\n\nSliderHandleDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: Renderer2\n  }];\n};\n\nSliderHandleDirective.propDecorators = {\n  \"active\": [{\n    type: HostBinding,\n    args: ['class.ng5-slider-active']\n  }],\n  \"role\": [{\n    type: HostBinding,\n    args: ['attr.role']\n  }],\n  \"tabindex\": [{\n    type: HostBinding,\n    args: ['attr.tabindex']\n  }],\n  \"ariaOrientation\": [{\n    type: HostBinding,\n    args: ['attr.aria-orientation']\n  }],\n  \"ariaLabel\": [{\n    type: HostBinding,\n    args: ['attr.aria-label']\n  }],\n  \"ariaLabelledBy\": [{\n    type: HostBinding,\n    args: ['attr.aria-labelledby']\n  }],\n  \"ariaValueNow\": [{\n    type: HostBinding,\n    args: ['attr.aria-valuenow']\n  }],\n  \"ariaValueText\": [{\n    type: HostBinding,\n    args: ['attr.aria-valuetext']\n  }],\n  \"ariaValueMin\": [{\n    type: HostBinding,\n    args: ['attr.aria-valuemin']\n  }],\n  \"ariaValueMax\": [{\n    type: HostBinding,\n    args: ['attr.aria-valuemax']\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SliderHandleDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ng5SliderHandle]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.Renderer2\n    }];\n  }, {\n    active: [{\n      type: HostBinding,\n      args: ['class.ng5-slider-active']\n    }],\n    role: [{\n      type: HostBinding,\n      args: ['attr.role']\n    }],\n    tabindex: [{\n      type: HostBinding,\n      args: ['attr.tabindex']\n    }],\n    ariaOrientation: [{\n      type: HostBinding,\n      args: ['attr.aria-orientation']\n    }],\n    ariaLabel: [{\n      type: HostBinding,\n      args: ['attr.aria-label']\n    }],\n    ariaLabelledBy: [{\n      type: HostBinding,\n      args: ['attr.aria-labelledby']\n    }],\n    ariaValueNow: [{\n      type: HostBinding,\n      args: ['attr.aria-valuenow']\n    }],\n    ariaValueText: [{\n      type: HostBinding,\n      args: ['attr.aria-valuetext']\n    }],\n    ariaValueMin: [{\n      type: HostBinding,\n      args: ['attr.aria-valuemin']\n    }],\n    ariaValueMax: [{\n      type: HostBinding,\n      args: ['attr.aria-valuemax']\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar SliderLabelDirective = /*#__PURE__*/function (_SliderElementDirecti2) {\n  _inherits(SliderLabelDirective, _SliderElementDirecti2);\n\n  var _super2 = _createSuper(SliderLabelDirective);\n\n  /**\n   * @param {?} elemRef\n   * @param {?} renderer\n   */\n  function SliderLabelDirective(elemRef, renderer) {\n    var _this2;\n\n    _classCallCheck(this, SliderLabelDirective);\n\n    _this2 = _super2.call(this, elemRef, renderer);\n    _this2._value = null;\n    return _this2;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(SliderLabelDirective, [{\n    key: \"setValue\",\n\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    value: function setValue(value) {\n      var\n      /** @type {?} */\n      recalculateDimension = false;\n\n      if (!this.alwaysHide && (ValueHelper.isNullOrUndefined(this.value) || this.value.length !== value.length || this.value.length > 0 && this.dimension === 0)) {\n        recalculateDimension = true;\n      }\n\n      this._value = value;\n      this.elemRef.nativeElement.innerHTML = value; // Update dimension only when length of the label have changed\n\n      if (recalculateDimension) {\n        this.calculateDimension();\n      }\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    }\n  }]);\n\n  return SliderLabelDirective;\n}(SliderElementDirective);\n\nSliderLabelDirective.ɵfac = function SliderLabelDirective_Factory(t) {\n  return new (t || SliderLabelDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n};\n\nSliderLabelDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: SliderLabelDirective,\n  selectors: [[\"\", \"ng5SliderLabel\", \"\"]],\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n/** @nocollapse */\n\nSliderLabelDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: Renderer2\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SliderLabelDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ng5SliderLabel]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.Renderer2\n    }];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar Tick = function Tick() {\n  _classCallCheck(this, Tick);\n\n  this.selected = false;\n  this.style = {};\n  this.tooltip = null;\n  this.tooltipPlacement = null;\n  this.value = null;\n  this.valueTooltip = null;\n  this.valueTooltipPlacement = null;\n  this.legend = null;\n};\n\nvar Dragging = function Dragging() {\n  _classCallCheck(this, Dragging);\n\n  this.active = false;\n  this.value = 0;\n  this.difference = 0;\n  this.position = 0;\n  this.lowLimit = 0;\n  this.highLimit = 0;\n};\n\nvar ModelValues = /*#__PURE__*/function () {\n  function ModelValues() {\n    _classCallCheck(this, ModelValues);\n  }\n\n  _createClass(ModelValues, null, [{\n    key: \"compare\",\n\n    /**\n     * @param {?=} x\n     * @param {?=} y\n     * @return {?}\n     */\n    value: function compare(x, y) {\n      if (ValueHelper.isNullOrUndefined(x) && ValueHelper.isNullOrUndefined(y)) {\n        return false;\n      }\n\n      if (ValueHelper.isNullOrUndefined(x) !== ValueHelper.isNullOrUndefined(y)) {\n        return false;\n      }\n\n      return x.value === y.value && x.highValue === y.highValue;\n    }\n  }]);\n\n  return ModelValues;\n}();\n\nvar ModelChange = /*#__PURE__*/function (_ModelValues) {\n  _inherits(ModelChange, _ModelValues);\n\n  var _super3 = _createSuper(ModelChange);\n\n  function ModelChange() {\n    _classCallCheck(this, ModelChange);\n\n    return _super3.apply(this, arguments);\n  }\n\n  _createClass(ModelChange, null, [{\n    key: \"compare\",\n\n    /**\n     * @param {?=} x\n     * @param {?=} y\n     * @return {?}\n     */\n    value: function compare(x, y) {\n      if (ValueHelper.isNullOrUndefined(x) && ValueHelper.isNullOrUndefined(y)) {\n        return false;\n      }\n\n      if (ValueHelper.isNullOrUndefined(x) !== ValueHelper.isNullOrUndefined(y)) {\n        return false;\n      }\n\n      return x.value === y.value && x.highValue === y.highValue && x.forceChange === y.forceChange;\n    }\n  }]);\n\n  return ModelChange;\n}(ModelValues);\n\nvar NG5_SLIDER_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n\n  /* tslint:disable-next-line: no-use-before-declare */\n  useExisting: forwardRef(function () {\n    return SliderComponent;\n  }),\n  multi: true\n};\n\nvar SliderComponent = /*#__PURE__*/function () {\n  /**\n   * @param {?} renderer\n   * @param {?} elementRef\n   * @param {?} changeDetectionRef\n   * @param {?} zone\n   */\n  function SliderComponent(renderer, elementRef, changeDetectionRef, zone) {\n    _classCallCheck(this, SliderComponent);\n\n    this.renderer = renderer;\n    this.elementRef = elementRef;\n    this.changeDetectionRef = changeDetectionRef;\n    this.zone = zone; // Model for low value of slider. For simple slider, this is the only input. For range slider, this is the low value.\n\n    this.value = null; // Output for low value slider to support two-way bindings\n\n    this.valueChange = new EventEmitter(); // Model for high value of slider. Not used in simple slider. For range slider, this is the high value.\n\n    this.highValue = null; // Output for high value slider to support two-way bindings\n\n    this.highValueChange = new EventEmitter(); // An object with all the other options of the slider.\n    // Each option can be updated at runtime and the slider will automatically be re-rendered.\n\n    this.options = new Options(); // Event emitted when user starts interaction with the slider\n\n    this.userChangeStart = new EventEmitter(); // Event emitted on each change coming from user interaction\n\n    this.userChange = new EventEmitter(); // Event emitted when user finishes interaction with the slider\n\n    this.userChangeEnd = new EventEmitter();\n    this.initHasRun = false;\n    this.inputModelChangeSubject = new Subject();\n    this.inputModelChangeSubscription = null;\n    this.outputModelChangeSubject = new Subject();\n    this.outputModelChangeSubscription = null;\n    this.viewLowValue = null;\n    this.viewHighValue = null;\n    this.viewOptions = new Options();\n    this.handleHalfDimension = 0;\n    this.maxHandlePosition = 0;\n    this.currentTrackingPointer = null;\n    this.currentFocusPointer = null;\n    this.firstKeyDown = false;\n    this.touchId = null;\n    this.dragging = new Dragging(); // Host element class bindings\n\n    this.sliderElementVerticalClass = false;\n    this.sliderElementAnimateClass = false;\n    this.sliderElementDisabledAttr = null;\n    this.barStyle = {};\n    this.minPointerStyle = {};\n    this.maxPointerStyle = {};\n    this.fullBarTransparentClass = false;\n    this.selectionBarDraggableClass = false;\n    this.ticksUnderValuesClass = false;\n    this.intermediateTicks = false;\n    this.ticks = [];\n    this.eventListenerHelper = null;\n    this.onMoveEventListener = null;\n    this.onEndEventListener = null;\n    this.resizeObserver = null;\n    this.onTouchedCallback = null;\n    this.onChangeCallback = null;\n    this.eventListenerHelper = new EventListenerHelper(this.renderer);\n  }\n  /**\n   * @param {?} manualRefresh\n   * @return {?}\n   */\n\n\n  _createClass(SliderComponent, [{\n    key: \"ngOnInit\",\n\n    /**\n     * @return {?}\n     */\n    value: function ngOnInit() {\n      this.viewOptions = new Options();\n      Object.assign(this.viewOptions, this.options); // We need to run these two things first, before the rest of the init in ngAfterViewInit(),\n      // because these two settings are set through @HostBinding and Angular change detection\n      // mechanism doesn't like them changing in ngAfterViewInit()\n\n      this.updateDisabledState();\n      this.updateVerticalState();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngAfterViewInit\",\n    value: function ngAfterViewInit() {\n      this.applyOptions();\n      this.subscribeInputModelChangeSubject(this.viewOptions.inputEventsInterval);\n      this.subscribeOutputModelChangeSubject(this.viewOptions.outputEventsInterval); // Once we apply options, we need to normalise model values for the first time\n\n      this.renormaliseModelValues();\n      this.viewLowValue = this.modelValueToViewValue(this.value);\n\n      if (this.range) {\n        this.viewHighValue = this.modelValueToViewValue(this.highValue);\n      } else {\n        this.viewHighValue = null;\n      }\n\n      this.updateVerticalState(); // need to run this again to cover changes to slider elements\n\n      this.manageElementsStyle();\n      this.updateDisabledState();\n      this.calculateViewDimensions();\n      this.addAccessibility();\n      this.updateCeilLabel();\n      this.updateFloorLabel();\n      this.initHandles();\n      this.manageEventsBindings();\n      this.subscribeResizeObserver();\n      this.initHasRun = true; // Run change detection manually to resolve some issues when init procedure changes values used in the view\n\n      this.changeDetectionRef.detectChanges();\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(changes) {\n      // Always apply options first\n      if (!ValueHelper.isNullOrUndefined(changes[\"options\"])) {\n        this.onChangeOptions();\n      } // Then value changes\n\n\n      if (!ValueHelper.isNullOrUndefined(changes[\"value\"]) || !ValueHelper.isNullOrUndefined(changes[\"highValue\"])) {\n        this.inputModelChangeSubject.next({\n          value: this.value,\n          highValue: this.highValue,\n          forceChange: false,\n          internalChange: false\n        });\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.unbindEvents();\n      this.unsubscribeResizeObserver();\n      this.unsubscribeInputModelChangeSubject();\n      this.unsubscribeOutputModelChangeSubject();\n      this.unsubscribeManualRefresh();\n      this.unsubscribeTriggerFocus();\n    }\n    /**\n     * @param {?} obj\n     * @return {?}\n     */\n\n  }, {\n    key: \"writeValue\",\n    value: function writeValue(obj) {\n      if (obj instanceof Array) {\n        this.value = obj[0];\n        this.highValue = obj[1];\n      } else {\n        this.value = obj;\n      } // ngOnChanges() is not called in this instance, so we need to communicate the change manually\n\n\n      this.inputModelChangeSubject.next({\n        value: this.value,\n        highValue: this.highValue,\n        forceChange: false,\n        internalChange: false\n      });\n    }\n    /**\n     * @param {?} onChangeCallback\n     * @return {?}\n     */\n\n  }, {\n    key: \"registerOnChange\",\n    value: function registerOnChange(onChangeCallback) {\n      this.onChangeCallback = onChangeCallback;\n    }\n    /**\n     * @param {?} onTouchedCallback\n     * @return {?}\n     */\n\n  }, {\n    key: \"registerOnTouched\",\n    value: function registerOnTouched(onTouchedCallback) {\n      this.onTouchedCallback = onTouchedCallback;\n    }\n    /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n\n  }, {\n    key: \"setDisabledState\",\n    value: function setDisabledState(isDisabled) {\n      this.viewOptions.disabled = isDisabled;\n      this.updateDisabledState();\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onResize\",\n    value: function onResize(event) {\n      this.calculateViewDimensionsAndDetectChanges();\n    }\n    /**\n     * @param {?=} interval\n     * @return {?}\n     */\n\n  }, {\n    key: \"subscribeInputModelChangeSubject\",\n    value: function subscribeInputModelChangeSubject(interval) {\n      var _this3 = this;\n\n      this.inputModelChangeSubscription = this.inputModelChangeSubject.pipe(distinctUntilChanged(ModelChange.compare), // Hack to reset the status of the distinctUntilChanged() - if a \"fake\" event comes through with forceChange=true,\n      // we forcefully by-pass distinctUntilChanged(), but otherwise drop the event\n      filter(function (modelChange) {\n        return !modelChange.forceChange && !modelChange.internalChange;\n      }), !ValueHelper.isNullOrUndefined(interval) ? throttleTime(interval, undefined, {\n        leading: true,\n        trailing: true\n      }) : tap(function () {}) // no-op\n      ).subscribe(function (modelChange) {\n        return _this3.applyInputModelChange(modelChange);\n      });\n    }\n    /**\n     * @param {?=} interval\n     * @return {?}\n     */\n\n  }, {\n    key: \"subscribeOutputModelChangeSubject\",\n    value: function subscribeOutputModelChangeSubject(interval) {\n      var _this4 = this;\n\n      this.outputModelChangeSubscription = this.outputModelChangeSubject.pipe(distinctUntilChanged(ModelChange.compare), !ValueHelper.isNullOrUndefined(interval) ? throttleTime(interval, undefined, {\n        leading: true,\n        trailing: true\n      }) : tap(function () {}) // no-op\n      ).subscribe(function (modelChange) {\n        return _this4.publishOutputModelChange(modelChange);\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"subscribeResizeObserver\",\n    value: function subscribeResizeObserver() {\n      var _this5 = this;\n\n      if (CompatibilityHelper.isResizeObserverAvailable()) {\n        this.resizeObserver = new ResizeObserver(function () {\n          return _this5.calculateViewDimensionsAndDetectChanges();\n        });\n        this.resizeObserver.observe(this.elementRef.nativeElement);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"unsubscribeResizeObserver\",\n    value: function unsubscribeResizeObserver() {\n      if (CompatibilityHelper.isResizeObserverAvailable() && this.resizeObserver !== null) {\n        this.resizeObserver.disconnect();\n        this.resizeObserver = null;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"unsubscribeOnMove\",\n    value: function unsubscribeOnMove() {\n      if (!ValueHelper.isNullOrUndefined(this.onMoveEventListener)) {\n        this.eventListenerHelper.detachEventListener(this.onMoveEventListener);\n        this.onMoveEventListener = null;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"unsubscribeOnEnd\",\n    value: function unsubscribeOnEnd() {\n      if (!ValueHelper.isNullOrUndefined(this.onEndEventListener)) {\n        this.eventListenerHelper.detachEventListener(this.onEndEventListener);\n        this.onEndEventListener = null;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"unsubscribeInputModelChangeSubject\",\n    value: function unsubscribeInputModelChangeSubject() {\n      if (!ValueHelper.isNullOrUndefined(this.inputModelChangeSubscription)) {\n        this.inputModelChangeSubscription.unsubscribe();\n        this.inputModelChangeSubscription = null;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"unsubscribeOutputModelChangeSubject\",\n    value: function unsubscribeOutputModelChangeSubject() {\n      if (!ValueHelper.isNullOrUndefined(this.outputModelChangeSubscription)) {\n        this.outputModelChangeSubscription.unsubscribe();\n        this.outputModelChangeSubscription = null;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"unsubscribeManualRefresh\",\n    value: function unsubscribeManualRefresh() {\n      if (!ValueHelper.isNullOrUndefined(this.manualRefreshSubscription)) {\n        this.manualRefreshSubscription.unsubscribe();\n        this.manualRefreshSubscription = null;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"unsubscribeTriggerFocus\",\n    value: function unsubscribeTriggerFocus() {\n      if (!ValueHelper.isNullOrUndefined(this.triggerFocusSubscription)) {\n        this.triggerFocusSubscription.unsubscribe();\n        this.triggerFocusSubscription = null;\n      }\n    }\n    /**\n     * @param {?} pointerType\n     * @return {?}\n     */\n\n  }, {\n    key: \"getPointerElement\",\n    value: function getPointerElement(pointerType) {\n      if (pointerType === PointerType.Min) {\n        return this.minHandleElement;\n      } else if (pointerType === PointerType.Max) {\n        return this.maxHandleElement;\n      }\n\n      return null;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"getCurrentTrackingValue\",\n    value: function getCurrentTrackingValue() {\n      if (this.currentTrackingPointer === PointerType.Min) {\n        return this.viewLowValue;\n      } else if (this.currentTrackingPointer === PointerType.Max) {\n        return this.viewHighValue;\n      }\n\n      return null;\n    }\n    /**\n     * @param {?} modelValue\n     * @return {?}\n     */\n\n  }, {\n    key: \"modelValueToViewValue\",\n    value: function modelValueToViewValue(modelValue) {\n      if (ValueHelper.isNullOrUndefined(modelValue)) {\n        return NaN;\n      }\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n        return ValueHelper.findStepIndex(+modelValue, this.viewOptions.stepsArray);\n      }\n\n      return +modelValue;\n    }\n    /**\n     * @param {?} viewValue\n     * @return {?}\n     */\n\n  }, {\n    key: \"viewValueToModelValue\",\n    value: function viewValueToModelValue(viewValue) {\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n        return this.getStepValue(viewValue);\n      }\n\n      return viewValue;\n    }\n    /**\n     * @param {?} sliderValue\n     * @return {?}\n     */\n\n  }, {\n    key: \"getStepValue\",\n    value: function getStepValue(sliderValue) {\n      var\n      /** @type {?} */\n      step = this.viewOptions.stepsArray[sliderValue];\n      return !ValueHelper.isNullOrUndefined(step) ? step.value : NaN;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"applyViewChange\",\n    value: function applyViewChange() {\n      this.value = this.viewValueToModelValue(this.viewLowValue);\n\n      if (this.range) {\n        this.highValue = this.viewValueToModelValue(this.viewHighValue);\n      }\n\n      this.outputModelChangeSubject.next({\n        value: this.value,\n        highValue: this.highValue,\n        userEventInitiated: true,\n        forceChange: false\n      }); // At this point all changes are applied and outputs are emitted, so we should be done.\n      // However, input changes are communicated in different stream and we need to be ready to\n      // act on the next input change even if it is exactly the same as last input change.\n      // Therefore, we send a special event to reset the stream.\n\n      this.inputModelChangeSubject.next({\n        value: this.value,\n        highValue: this.highValue,\n        forceChange: false,\n        internalChange: true\n      });\n    }\n    /**\n     * @param {?} modelChange\n     * @return {?}\n     */\n\n  }, {\n    key: \"applyInputModelChange\",\n    value: function applyInputModelChange(modelChange) {\n      var\n      /** @type {?} */\n      normalisedModelChange = this.normaliseModelValues(modelChange); // If normalised model change is different, apply the change to the model values\n\n      var\n      /** @type {?} */\n      normalisationChange = !ModelValues.compare(modelChange, normalisedModelChange);\n\n      if (normalisationChange) {\n        this.value = normalisedModelChange.value;\n        this.highValue = normalisedModelChange.highValue;\n      }\n\n      this.viewLowValue = this.modelValueToViewValue(normalisedModelChange.value);\n\n      if (this.range) {\n        this.viewHighValue = this.modelValueToViewValue(normalisedModelChange.highValue);\n      } else {\n        this.viewHighValue = null;\n      }\n\n      this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n\n      if (this.range) {\n        this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n      }\n\n      this.updateSelectionBar();\n      this.updateTicksScale();\n      this.updateAriaAttributes();\n\n      if (this.range) {\n        this.updateCombinedLabel();\n      } // At the end, we need to communicate the model change to the outputs as well\n      // Normalisation changes are also always forced out to ensure that subscribers always end up in correct state\n\n\n      this.outputModelChangeSubject.next({\n        value: normalisedModelChange.value,\n        highValue: normalisedModelChange.highValue,\n        forceChange: normalisationChange,\n        userEventInitiated: false\n      });\n    }\n    /**\n     * @param {?} modelChange\n     * @return {?}\n     */\n\n  }, {\n    key: \"publishOutputModelChange\",\n    value: function publishOutputModelChange(modelChange) {\n      var _this6 = this;\n\n      var\n      /** @type {?} */\n      emitOutputs = function emitOutputs() {\n        _this6.valueChange.emit(modelChange.value);\n\n        if (_this6.range) {\n          _this6.highValueChange.emit(modelChange.highValue);\n        }\n\n        if (!ValueHelper.isNullOrUndefined(_this6.onChangeCallback)) {\n          if (_this6.range) {\n            _this6.onChangeCallback([modelChange.value, modelChange.highValue]);\n          } else {\n            _this6.onChangeCallback(modelChange.value);\n          }\n        }\n\n        if (!ValueHelper.isNullOrUndefined(_this6.onTouchedCallback)) {\n          if (_this6.range) {\n            _this6.onTouchedCallback([modelChange.value, modelChange.highValue]);\n          } else {\n            _this6.onTouchedCallback(modelChange.value);\n          }\n        }\n      };\n\n      if (modelChange.userEventInitiated) {\n        // If this change was initiated by a user event, we can emit outputs in the same tick\n        emitOutputs();\n        this.userChange.emit(this.getChangeContext());\n      } else {\n        // But, if the change was initated by something else like a change in input bindings,\n        // we need to wait until next tick to emit the outputs to keep Angular change detection happy\n        setTimeout(function () {\n          emitOutputs();\n        });\n      }\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n\n  }, {\n    key: \"normaliseModelValues\",\n    value: function normaliseModelValues(input) {\n      var\n      /** @type {?} */\n      normalisedInput = new ModelValues();\n      normalisedInput.value = input.value;\n      normalisedInput.highValue = input.highValue;\n\n      if (this.viewOptions.enforceStep) {\n        normalisedInput.value = this.roundStep(normalisedInput.value);\n\n        if (this.range) {\n          normalisedInput.highValue = this.roundStep(normalisedInput.highValue);\n        }\n      } // Don't attempt to normalise further when using steps array (steps may be out of order and that is perfectly fine)\n\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) || !this.viewOptions.enforceRange) {\n        return normalisedInput;\n      }\n\n      normalisedInput.value = MathHelper.clampToRange(normalisedInput.value, this.viewOptions.floor, this.viewOptions.ceil);\n\n      if (this.range) {\n        normalisedInput.highValue = MathHelper.clampToRange(normalisedInput.highValue, this.viewOptions.floor, this.viewOptions.ceil);\n      } // Make sure that range slider invariant (value <= highValue) is always satisfied\n\n\n      if (this.range && input.value > input.highValue) {\n        // We know that both values are now clamped correctly, they may just be in the wrong order\n        // So the easy solution is to swap them... except swapping is sometimes disabled in options, so we make the two values the same\n        if (this.viewOptions.noSwitching) {\n          normalisedInput.value = normalisedInput.highValue;\n        } else {\n          var\n          /** @type {?} */\n          tempValue = input.value;\n          normalisedInput.value = input.highValue;\n          normalisedInput.highValue = tempValue;\n        }\n      }\n\n      return normalisedInput;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"renormaliseModelValues\",\n    value: function renormaliseModelValues() {\n      var\n      /** @type {?} */\n      previousModelValues = {\n        value: this.value,\n        highValue: this.highValue\n      };\n      var\n      /** @type {?} */\n      normalisedModelValues = this.normaliseModelValues(previousModelValues);\n\n      if (!ModelValues.compare(normalisedModelValues, previousModelValues)) {\n        this.value = normalisedModelValues.value;\n        this.highValue = normalisedModelValues.highValue;\n        this.outputModelChangeSubject.next({\n          value: this.value,\n          highValue: this.highValue,\n          forceChange: true,\n          userEventInitiated: false\n        });\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"onChangeOptions\",\n    value: function onChangeOptions() {\n      if (!this.initHasRun) {\n        return;\n      }\n\n      var\n      /** @type {?} */\n      previousInputEventsInterval = this.viewOptions.inputEventsInterval;\n      var\n      /** @type {?} */\n      previousOutputEventsInterval = this.viewOptions.outputEventsInterval;\n      this.applyOptions();\n\n      if (previousInputEventsInterval !== this.viewOptions.inputEventsInterval) {\n        this.unsubscribeInputModelChangeSubject();\n        this.subscribeInputModelChangeSubject(this.viewOptions.inputEventsInterval);\n      }\n\n      if (previousOutputEventsInterval !== this.viewOptions.outputEventsInterval) {\n        this.unsubscribeInputModelChangeSubject();\n        this.subscribeInputModelChangeSubject(this.viewOptions.outputEventsInterval);\n      } // With new options, we need to re-normalise model values if necessary\n\n\n      this.renormaliseModelValues();\n      this.viewLowValue = this.modelValueToViewValue(this.value);\n\n      if (this.range) {\n        this.viewHighValue = this.modelValueToViewValue(this.highValue);\n      } else {\n        this.viewHighValue = null;\n      }\n\n      this.resetSlider();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"applyOptions\",\n    value: function applyOptions() {\n      this.viewOptions = new Options();\n      Object.assign(this.viewOptions, this.options);\n      this.viewOptions.draggableRange = this.range && this.viewOptions.draggableRange;\n      this.viewOptions.draggableRangeOnly = this.range && this.viewOptions.draggableRangeOnly;\n\n      if (this.viewOptions.draggableRangeOnly) {\n        this.viewOptions.draggableRange = true;\n      }\n\n      this.viewOptions.showTicks = this.viewOptions.showTicks || this.viewOptions.showTicksValues || !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray);\n\n      if (this.viewOptions.showTicks && (!ValueHelper.isNullOrUndefined(this.viewOptions.tickStep) || !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray))) {\n        this.intermediateTicks = true;\n      }\n\n      this.viewOptions.showSelectionBar = this.viewOptions.showSelectionBar || this.viewOptions.showSelectionBarEnd || !ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue);\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray)) {\n        this.applyStepsArrayOptions();\n      } else {\n        this.applyFloorCeilOptions();\n      }\n\n      if (ValueHelper.isNullOrUndefined(this.viewOptions.combineLabels)) {\n        this.viewOptions.combineLabels = function (minValue, maxValue) {\n          return minValue + ' - ' + maxValue;\n        };\n      }\n\n      if (this.viewOptions.logScale && this.viewOptions.floor === 0) {\n        throw Error('Can\\'t use floor=0 with logarithmic scale');\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"applyStepsArrayOptions\",\n    value: function applyStepsArrayOptions() {\n      var _this7 = this;\n\n      this.viewOptions.floor = 0;\n      this.viewOptions.ceil = this.viewOptions.stepsArray.length - 1;\n      this.viewOptions.step = 1;\n\n      if (ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {\n        this.viewOptions.translate = function (modelValue) {\n          if (_this7.viewOptions.bindIndexForStepsArray) {\n            return String(_this7.getStepValue(modelValue));\n          }\n\n          return String(modelValue);\n        };\n      }\n\n      this.viewOptions.getLegend = function (index) {\n        var\n        /** @type {?} */\n        step = _this7.viewOptions.stepsArray[index];\n        return step.legend;\n      };\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"applyFloorCeilOptions\",\n    value: function applyFloorCeilOptions() {\n      if (ValueHelper.isNullOrUndefined(this.viewOptions.step)) {\n        this.viewOptions.step = 1;\n      } else {\n        this.viewOptions.step = +this.viewOptions.step;\n\n        if (this.viewOptions.step <= 0) {\n          this.viewOptions.step = 1;\n        }\n      }\n\n      if (ValueHelper.isNullOrUndefined(this.viewOptions.ceil) || ValueHelper.isNullOrUndefined(this.viewOptions.floor)) {\n        throw Error('floor and ceil options must be supplied');\n      }\n\n      this.viewOptions.ceil = +this.viewOptions.ceil;\n      this.viewOptions.floor = +this.viewOptions.floor;\n\n      if (ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {\n        this.viewOptions.translate = function (value) {\n          return String(value);\n        };\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"resetSlider\",\n    value: function resetSlider() {\n      this.manageElementsStyle();\n      this.addAccessibility();\n      this.updateCeilLabel();\n      this.updateFloorLabel();\n      this.unbindEvents();\n      this.manageEventsBindings();\n      this.updateDisabledState();\n      this.calculateViewDimensions();\n      this.refocusPointerIfNeeded();\n    }\n    /**\n     * @param {?} pointerType\n     * @return {?}\n     */\n\n  }, {\n    key: \"focusPointer\",\n    value: function focusPointer(pointerType) {\n      // If not supplied, use min pointer as default\n      if (pointerType !== PointerType.Min && pointerType !== PointerType.Max) {\n        pointerType = PointerType.Min;\n      }\n\n      if (pointerType === PointerType.Min) {\n        this.minHandleElement.focus();\n      } else if (this.range && pointerType === PointerType.Max) {\n        this.maxHandleElement.focus();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"refocusPointerIfNeeded\",\n    value: function refocusPointerIfNeeded() {\n      if (!ValueHelper.isNullOrUndefined(this.currentFocusPointer)) {\n        this.onPointerFocus(this.currentFocusPointer);\n        var\n        /** @type {?} */\n        element = this.getPointerElement(this.currentFocusPointer);\n        element.focus();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"manageElementsStyle\",\n    value: function manageElementsStyle() {\n      var _this8 = this;\n\n      this.updateScale();\n      this.floorLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n      this.ceilLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n      var\n      /** @type {?} */\n      hideLabelsForTicks = this.viewOptions.showTicksValues && !this.intermediateTicks;\n      this.minHandleLabelElement.setAlwaysHide(hideLabelsForTicks || this.viewOptions.hidePointerLabels);\n      this.maxHandleLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n      this.combinedLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n      this.selectionBarElement.setAlwaysHide(!this.range && !this.viewOptions.showSelectionBar);\n      this.leftOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);\n      this.rightOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);\n      this.fullBarTransparentClass = this.range && this.viewOptions.showOuterSelectionBars;\n      this.selectionBarDraggableClass = this.viewOptions.draggableRange && !this.viewOptions.onlyBindHandles;\n      this.ticksUnderValuesClass = this.intermediateTicks && this.options.showTicksValues;\n\n      if (this.sliderElementVerticalClass !== this.viewOptions.vertical) {\n        this.updateVerticalState(); // The above change in host component class will not be applied until the end of this cycle\n        // However, functions calculating the slider position expect the slider to be already styled as vertical\n        // So as a workaround, we need to reset the slider once again to compute the correct values\n\n        setTimeout(function () {\n          _this8.resetSlider();\n        });\n      } // Changing animate class may interfere with slider reset/initialisation, so we should set it separately,\n      // after all is properly set up\n\n\n      if (this.sliderElementAnimateClass !== this.viewOptions.animate) {\n        setTimeout(function () {\n          _this8.sliderElementAnimateClass = _this8.viewOptions.animate;\n        });\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"manageEventsBindings\",\n    value: function manageEventsBindings() {\n      if (this.viewOptions.disabled || this.viewOptions.readOnly) {\n        this.unbindEvents();\n      } else {\n        this.bindEvents();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateDisabledState\",\n    value: function updateDisabledState() {\n      this.sliderElementDisabledAttr = this.viewOptions.disabled ? 'disabled' : null;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateVerticalState\",\n    value: function updateVerticalState() {\n      this.sliderElementVerticalClass = this.viewOptions.vertical;\n\n      var _iterator2 = _createForOfIteratorHelper(this.getAllSliderElements()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var element = _step2.value;\n\n          // This is also called before ngAfterInit, so need to check that view child bindings work\n          if (!ValueHelper.isNullOrUndefined(element)) {\n            element.setVertical(this.viewOptions.vertical);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateScale\",\n    value: function updateScale() {\n      var _iterator3 = _createForOfIteratorHelper(this.getAllSliderElements()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var element = _step3.value;\n          element.setScale(this.viewOptions.scale);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"getAllSliderElements\",\n    value: function getAllSliderElements() {\n      return [this.leftOuterSelectionBarElement, this.rightOuterSelectionBarElement, this.fullBarElement, this.selectionBarElement, this.minHandleElement, this.maxHandleElement, this.floorLabelElement, this.ceilLabelElement, this.minHandleLabelElement, this.maxHandleLabelElement, this.combinedLabelElement, this.ticksElement];\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"initHandles\",\n    value: function initHandles() {\n      this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n      /*\n         the order here is important since the selection bar should be\n         updated after the high handle but before the combined label\n         */\n\n      if (this.range) {\n        this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n      }\n\n      this.updateSelectionBar();\n\n      if (this.range) {\n        this.updateCombinedLabel();\n      }\n\n      this.updateTicksScale();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"addAccessibility\",\n    value: function addAccessibility() {\n      this.updateAriaAttributes();\n      this.minHandleElement.role = 'slider';\n\n      if (this.viewOptions.keyboardSupport && !(this.viewOptions.readOnly || this.viewOptions.disabled)) {\n        this.minHandleElement.tabindex = '0';\n      } else {\n        this.minHandleElement.tabindex = '';\n      }\n\n      if (this.viewOptions.vertical) {\n        this.minHandleElement.ariaOrientation = 'vertical';\n      }\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabel)) {\n        this.minHandleElement.ariaLabel = this.viewOptions.ariaLabel;\n      } else if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledBy)) {\n        this.minHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledBy;\n      }\n\n      if (this.range) {\n        this.maxHandleElement.role = 'slider';\n\n        if (this.viewOptions.keyboardSupport && !(this.viewOptions.readOnly || this.viewOptions.disabled)) {\n          this.maxHandleElement.tabindex = '0';\n        } else {\n          this.maxHandleElement.tabindex = '';\n        }\n\n        this.maxHandleElement.ariaOrientation = this.viewOptions.vertical ? 'vertical' : 'horizontal';\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelHigh)) {\n          this.maxHandleElement.ariaLabel = this.viewOptions.ariaLabelHigh;\n        } else if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledByHigh)) {\n          this.maxHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledByHigh;\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateAriaAttributes\",\n    value: function updateAriaAttributes() {\n      this.minHandleElement.ariaValueNow = (+this.value).toString();\n      this.minHandleElement.ariaValueText = this.viewOptions.translate(+this.value, LabelType.Low);\n      this.minHandleElement.ariaValueMin = this.viewOptions.floor.toString();\n      this.minHandleElement.ariaValueMax = this.viewOptions.ceil.toString();\n\n      if (this.range) {\n        this.maxHandleElement.ariaValueNow = (+this.highValue).toString();\n        this.maxHandleElement.ariaValueText = this.viewOptions.translate(+this.highValue, LabelType.High);\n        this.maxHandleElement.ariaValueMin = this.viewOptions.floor.toString();\n        this.maxHandleElement.ariaValueMax = this.viewOptions.ceil.toString();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"calculateViewDimensions\",\n    value: function calculateViewDimensions() {\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.handleDimension)) {\n        this.minHandleElement.setDimension(this.viewOptions.handleDimension);\n      } else {\n        this.minHandleElement.calculateDimension();\n      }\n\n      var\n      /** @type {?} */\n      handleWidth = this.minHandleElement.dimension;\n      this.handleHalfDimension = handleWidth / 2;\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.barDimension)) {\n        this.fullBarElement.setDimension(this.viewOptions.barDimension);\n      } else {\n        this.fullBarElement.calculateDimension();\n      }\n\n      this.maxHandlePosition = this.fullBarElement.dimension - handleWidth;\n\n      if (this.initHasRun) {\n        this.updateFloorLabel();\n        this.updateCeilLabel();\n        this.initHandles();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"calculateViewDimensionsAndDetectChanges\",\n    value: function calculateViewDimensionsAndDetectChanges() {\n      this.calculateViewDimensions();\n      this.changeDetectionRef.detectChanges();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateTicksScale\",\n    value: function updateTicksScale() {\n      var _this9 = this;\n\n      if (!this.viewOptions.showTicks) {\n        return;\n      }\n\n      var\n      /** @type {?} */\n      ticksArray = !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray) ? this.viewOptions.ticksArray : this.getTicksArray();\n      var\n      /** @type {?} */\n      translate = this.viewOptions.vertical ? 'translateY' : 'translateX';\n\n      if (this.viewOptions.rightToLeft) {\n        ticksArray.reverse();\n      }\n\n      var\n      /** @type {?} */\n      newTicks = ticksArray.map(function (value) {\n        var\n        /** @type {?} */\n        position = _this9.valueToPosition(value);\n\n        if (_this9.viewOptions.vertical) {\n          position = _this9.maxHandlePosition - position;\n        }\n\n        var\n        /** @type {?} */\n        translation = translate + '(' + Math.round(position) + 'px)';\n        var\n        /** @type {?} */\n        tick = new Tick();\n        tick.selected = _this9.isTickSelected(value);\n        tick.style = {\n          '-webkit-transform': translation,\n          '-moz-transform': translation,\n          '-o-transform': translation,\n          '-ms-transform': translation,\n          transform: translation\n        };\n\n        if (tick.selected && !ValueHelper.isNullOrUndefined(_this9.viewOptions.getSelectionBarColor)) {\n          tick.style['background-color'] = _this9.getSelectionBarColor();\n        }\n\n        if (!tick.selected && !ValueHelper.isNullOrUndefined(_this9.viewOptions.getTickColor)) {\n          tick.style['background-color'] = _this9.getTickColor(value);\n        }\n\n        if (!ValueHelper.isNullOrUndefined(_this9.viewOptions.ticksTooltip)) {\n          tick.tooltip = _this9.viewOptions.ticksTooltip(value);\n          tick.tooltipPlacement = _this9.viewOptions.vertical ? 'right' : 'top';\n        }\n\n        if (_this9.viewOptions.showTicksValues && value % _this9.viewOptions.tickValueStep === 0) {\n          tick.value = _this9.getDisplayValue(value, LabelType.TickValue);\n\n          if (!ValueHelper.isNullOrUndefined(_this9.viewOptions.ticksValuesTooltip)) {\n            tick.valueTooltip = _this9.viewOptions.ticksValuesTooltip(value);\n            tick.valueTooltipPlacement = _this9.viewOptions.vertical ? 'right' : 'top';\n          }\n        }\n\n        if (!ValueHelper.isNullOrUndefined(_this9.viewOptions.getLegend)) {\n          var\n          /** @type {?} */\n          legend = _this9.viewOptions.getLegend(value);\n\n          if (!ValueHelper.isNullOrUndefined(legend)) {\n            tick.legend = legend;\n          }\n        }\n\n        return tick;\n      }); // We should avoid re-creating the ticks array if possible\n      // This both improves performance and makes CSS animations work correctly\n\n      if (!ValueHelper.isNullOrUndefined(this.ticks) && this.ticks.length === newTicks.length) {\n        for (var\n        /** @type {?} */\n        i = 0; i < newTicks.length; ++i) {\n          Object.assign(this.ticks[i], newTicks[i]);\n        }\n      } else {\n        this.ticks = newTicks;\n      }\n\n      this.changeDetectionRef.detectChanges();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"getTicksArray\",\n    value: function getTicksArray() {\n      var\n      /** @type {?} */\n      step = !ValueHelper.isNullOrUndefined(this.viewOptions.tickStep) ? this.viewOptions.tickStep : this.viewOptions.step;\n      var\n      /** @type {?} */\n      ticksArray = [];\n\n      for (var\n      /** @type {?} */\n      value = this.viewOptions.floor; value <= this.viewOptions.ceil; value += step) {\n        ticksArray.push(value);\n      }\n\n      return ticksArray;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n  }, {\n    key: \"isTickSelected\",\n    value: function isTickSelected(value) {\n      if (!this.range) {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {\n          var\n          /** @type {?} */\n          center = this.viewOptions.showSelectionBarFromValue;\n\n          if (this.viewLowValue > center && value >= center && value <= this.viewLowValue) {\n            return true;\n          } else if (this.viewLowValue < center && value <= center && value >= this.viewLowValue) {\n            return true;\n          }\n        } else if (this.viewOptions.showSelectionBarEnd) {\n          if (value >= this.viewLowValue) {\n            return true;\n          }\n        } else if (this.viewOptions.showSelectionBar && value <= this.viewLowValue) {\n          return true;\n        }\n      }\n\n      if (this.range && value >= this.viewLowValue && value <= this.viewHighValue) {\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateFloorLabel\",\n    value: function updateFloorLabel() {\n      if (!this.floorLabelElement.alwaysHide) {\n        this.floorLabelElement.setValue(this.getDisplayValue(this.viewOptions.floor, LabelType.Floor));\n        this.floorLabelElement.calculateDimension();\n        var\n        /** @type {?} */\n        position = this.viewOptions.rightToLeft ? this.fullBarElement.dimension - this.floorLabelElement.dimension : 0;\n        this.floorLabelElement.setPosition(position);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateCeilLabel\",\n    value: function updateCeilLabel() {\n      if (!this.ceilLabelElement.alwaysHide) {\n        this.ceilLabelElement.setValue(this.getDisplayValue(this.viewOptions.ceil, LabelType.Ceil));\n        this.ceilLabelElement.calculateDimension();\n        var\n        /** @type {?} */\n        position = this.viewOptions.rightToLeft ? 0 : this.fullBarElement.dimension - this.ceilLabelElement.dimension;\n        this.ceilLabelElement.setPosition(position);\n      }\n    }\n    /**\n     * @param {?} which\n     * @param {?} newPos\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateHandles\",\n    value: function updateHandles(which, newPos) {\n      if (which === PointerType.Min) {\n        this.updateLowHandle(newPos);\n      } else if (which === PointerType.Max) {\n        this.updateHighHandle(newPos);\n      }\n\n      this.updateSelectionBar();\n      this.updateTicksScale();\n\n      if (this.range) {\n        this.updateCombinedLabel();\n      }\n    }\n    /**\n     * @param {?} labelType\n     * @param {?} newPos\n     * @return {?}\n     */\n\n  }, {\n    key: \"getHandleLabelPos\",\n    value: function getHandleLabelPos(labelType, newPos) {\n      var\n      /** @type {?} */\n      labelDimension = labelType === PointerType.Min ? this.minHandleLabelElement.dimension : this.maxHandleLabelElement.dimension;\n      var\n      /** @type {?} */\n      nearHandlePos = newPos - labelDimension / 2 + this.handleHalfDimension;\n      var\n      /** @type {?} */\n      endOfBarPos = this.fullBarElement.dimension - labelDimension;\n\n      if (!this.viewOptions.boundPointerLabels) {\n        return nearHandlePos;\n      }\n\n      if (this.viewOptions.rightToLeft && labelType === PointerType.Min || !this.viewOptions.rightToLeft && labelType === PointerType.Max) {\n        return Math.min(nearHandlePos, endOfBarPos);\n      } else {\n        return Math.min(Math.max(nearHandlePos, 0), endOfBarPos);\n      }\n    }\n    /**\n     * @param {?} newPos\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateLowHandle\",\n    value: function updateLowHandle(newPos) {\n      this.minHandleElement.setPosition(newPos);\n      this.minHandleLabelElement.setValue(this.getDisplayValue(this.viewLowValue, LabelType.Low));\n      this.minHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Min, newPos));\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {\n        this.minPointerStyle = {\n          backgroundColor: this.getPointerColor(PointerType.Min)\n        };\n      }\n\n      if (this.viewOptions.autoHideLimitLabels) {\n        this.updateFloorAndCeilLabelsVisibility();\n      }\n    }\n    /**\n     * @param {?} newPos\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateHighHandle\",\n    value: function updateHighHandle(newPos) {\n      this.maxHandleElement.setPosition(newPos);\n      this.maxHandleLabelElement.setValue(this.getDisplayValue(this.viewHighValue, LabelType.High));\n      this.maxHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Max, newPos));\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {\n        this.maxPointerStyle = {\n          backgroundColor: this.getPointerColor(PointerType.Max)\n        };\n      }\n\n      if (this.viewOptions.autoHideLimitLabels) {\n        this.updateFloorAndCeilLabelsVisibility();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateFloorAndCeilLabelsVisibility\",\n    value: function updateFloorAndCeilLabelsVisibility() {\n      // Show based only on hideLimitLabels if pointer labels are hidden\n      if (this.viewOptions.hidePointerLabels) {\n        return;\n      }\n\n      var\n      /** @type {?} */\n      floorLabelHidden = false;\n      var\n      /** @type {?} */\n      ceilLabelHidden = false;\n      var\n      /** @type {?} */\n      isMinLabelAtFloor = this.isLabelBelowFloorLabel(this.minHandleLabelElement);\n      var\n      /** @type {?} */\n      isMinLabelAtCeil = this.isLabelAboveCeilLabel(this.minHandleLabelElement);\n      var\n      /** @type {?} */\n      isMaxLabelAtCeil = this.isLabelAboveCeilLabel(this.maxHandleLabelElement);\n      var\n      /** @type {?} */\n      isCombinedLabelAtFloor = this.isLabelBelowFloorLabel(this.combinedLabelElement);\n      var\n      /** @type {?} */\n      isCombinedLabelAtCeil = this.isLabelAboveCeilLabel(this.combinedLabelElement);\n\n      if (isMinLabelAtFloor) {\n        floorLabelHidden = true;\n        this.floorLabelElement.hide();\n      } else {\n        floorLabelHidden = false;\n        this.floorLabelElement.show();\n      }\n\n      if (isMinLabelAtCeil) {\n        ceilLabelHidden = true;\n        this.ceilLabelElement.hide();\n      } else {\n        ceilLabelHidden = false;\n        this.ceilLabelElement.show();\n      }\n\n      if (this.range) {\n        var\n        /** @type {?} */\n        hideCeil = this.combinedLabelElement.isVisible() ? isCombinedLabelAtCeil : isMaxLabelAtCeil;\n        var\n        /** @type {?} */\n        hideFloor = this.combinedLabelElement.isVisible() ? isCombinedLabelAtFloor : isMinLabelAtFloor;\n\n        if (hideCeil) {\n          this.ceilLabelElement.hide();\n        } else if (!ceilLabelHidden) {\n          this.ceilLabelElement.show();\n        } // Hide or show floor label\n\n\n        if (hideFloor) {\n          this.floorLabelElement.hide();\n        } else if (!floorLabelHidden) {\n          this.floorLabelElement.show();\n        }\n      }\n    }\n    /**\n     * @param {?} label\n     * @return {?}\n     */\n\n  }, {\n    key: \"isLabelBelowFloorLabel\",\n    value: function isLabelBelowFloorLabel(label) {\n      var\n      /** @type {?} */\n      pos = label.position;\n      var\n      /** @type {?} */\n      dim = label.dimension;\n      var\n      /** @type {?} */\n      floorPos = this.floorLabelElement.position;\n      var\n      /** @type {?} */\n      floorDim = this.floorLabelElement.dimension;\n      return this.viewOptions.rightToLeft ? pos + dim >= floorPos - 2 : pos <= floorPos + floorDim + 2;\n    }\n    /**\n     * @param {?} label\n     * @return {?}\n     */\n\n  }, {\n    key: \"isLabelAboveCeilLabel\",\n    value: function isLabelAboveCeilLabel(label) {\n      var\n      /** @type {?} */\n      pos = label.position;\n      var\n      /** @type {?} */\n      dim = label.dimension;\n      var\n      /** @type {?} */\n      ceilPos = this.ceilLabelElement.position;\n      var\n      /** @type {?} */\n      ceilDim = this.ceilLabelElement.dimension;\n      return this.viewOptions.rightToLeft ? pos <= ceilPos + ceilDim + 2 : pos + dim >= ceilPos - 2;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateSelectionBar\",\n    value: function updateSelectionBar() {\n      var\n      /** @type {?} */\n      position = 0;\n      var\n      /** @type {?} */\n      dimension = 0;\n      var\n      /** @type {?} */\n      isSelectionBarFromRight = this.viewOptions.rightToLeft ? !this.viewOptions.showSelectionBarEnd : this.viewOptions.showSelectionBarEnd;\n      var\n      /** @type {?} */\n      positionForRange = this.viewOptions.rightToLeft ? this.maxHandleElement.position + this.handleHalfDimension : this.minHandleElement.position + this.handleHalfDimension;\n\n      if (this.range) {\n        dimension = Math.abs(this.maxHandleElement.position - this.minHandleElement.position);\n        position = positionForRange;\n      } else {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {\n          var\n          /** @type {?} */\n          center = this.viewOptions.showSelectionBarFromValue;\n          var\n          /** @type {?} */\n          centerPosition = this.valueToPosition(center);\n          var\n          /** @type {?} */\n          isModelGreaterThanCenter = this.viewOptions.rightToLeft ? this.viewLowValue <= center : this.viewLowValue > center;\n\n          if (isModelGreaterThanCenter) {\n            dimension = this.minHandleElement.position - centerPosition;\n            position = centerPosition + this.handleHalfDimension;\n          } else {\n            dimension = centerPosition - this.minHandleElement.position;\n            position = this.minHandleElement.position + this.handleHalfDimension;\n          }\n        } else if (isSelectionBarFromRight) {\n          dimension = Math.ceil(Math.abs(this.maxHandlePosition - this.minHandleElement.position) + this.handleHalfDimension);\n          position = Math.floor(this.minHandleElement.position + this.handleHalfDimension);\n        } else {\n          dimension = this.minHandleElement.position + this.handleHalfDimension;\n          position = 0;\n        }\n      }\n\n      this.selectionBarElement.setDimension(dimension);\n      this.selectionBarElement.setPosition(position);\n\n      if (this.range && this.viewOptions.showOuterSelectionBars) {\n        if (this.viewOptions.rightToLeft) {\n          this.rightOuterSelectionBarElement.setDimension(position);\n          this.rightOuterSelectionBarElement.setPosition(0);\n          this.fullBarElement.calculateDimension();\n          this.leftOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));\n          this.leftOuterSelectionBarElement.setPosition(position + dimension);\n        } else {\n          this.leftOuterSelectionBarElement.setDimension(position);\n          this.leftOuterSelectionBarElement.setPosition(0);\n          this.fullBarElement.calculateDimension();\n          this.rightOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));\n          this.rightOuterSelectionBarElement.setPosition(position + dimension);\n        }\n      }\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.getSelectionBarColor)) {\n        var\n        /** @type {?} */\n        color = this.getSelectionBarColor();\n        this.barStyle = {\n          backgroundColor: color\n        };\n      } else if (!ValueHelper.isNullOrUndefined(this.viewOptions.selectionBarGradient)) {\n        var\n        /** @type {?} */\n        offset = !ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue) ? this.valueToPosition(this.viewOptions.showSelectionBarFromValue) : 0;\n        var\n        /** @type {?} */\n        reversed = offset - position > 0 && !isSelectionBarFromRight || offset - position <= 0 && isSelectionBarFromRight;\n        var\n        /** @type {?} */\n        direction = this.viewOptions.vertical ? reversed ? 'bottom' : 'top' : reversed ? 'left' : 'right';\n        this.barStyle = {\n          backgroundImage: 'linear-gradient(to ' + direction + ', ' + this.viewOptions.selectionBarGradient.from + ' 0%,' + this.viewOptions.selectionBarGradient.to + ' 100%)'\n        };\n\n        if (this.viewOptions.vertical) {\n          this.barStyle.backgroundPosition = 'center ' + (offset + dimension + position + (reversed ? -this.handleHalfDimension : 0)) + 'px';\n          this.barStyle.backgroundSize = '100% ' + (this.fullBarElement.dimension - this.handleHalfDimension) + 'px';\n        } else {\n          this.barStyle.backgroundPosition = offset - position + (reversed ? this.handleHalfDimension : 0) + 'px center';\n          this.barStyle.backgroundSize = this.fullBarElement.dimension - this.handleHalfDimension + 'px 100%';\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"getSelectionBarColor\",\n    value: function getSelectionBarColor() {\n      if (this.range) {\n        return this.viewOptions.getSelectionBarColor(this.value, this.highValue);\n      }\n\n      return this.viewOptions.getSelectionBarColor(this.value);\n    }\n    /**\n     * @param {?} pointerType\n     * @return {?}\n     */\n\n  }, {\n    key: \"getPointerColor\",\n    value: function getPointerColor(pointerType) {\n      if (pointerType === PointerType.Max) {\n        return this.viewOptions.getPointerColor(this.highValue, pointerType);\n      }\n\n      return this.viewOptions.getPointerColor(this.value, pointerType);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n  }, {\n    key: \"getTickColor\",\n    value: function getTickColor(value) {\n      return this.viewOptions.getTickColor(value);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateCombinedLabel\",\n    value: function updateCombinedLabel() {\n      var\n      /** @type {?} */\n      isLabelOverlap = null;\n\n      if (this.viewOptions.rightToLeft) {\n        isLabelOverlap = this.minHandleLabelElement.position - this.minHandleLabelElement.dimension - 10 <= this.maxHandleLabelElement.position;\n      } else {\n        isLabelOverlap = this.minHandleLabelElement.position + this.minHandleLabelElement.dimension + 10 >= this.maxHandleLabelElement.position;\n      }\n\n      if (isLabelOverlap) {\n        var\n        /** @type {?} */\n        lowDisplayValue = this.getDisplayValue(this.viewLowValue, LabelType.Low);\n        var\n        /** @type {?} */\n        highDisplayValue = this.getDisplayValue(this.viewHighValue, LabelType.High);\n        var\n        /** @type {?} */\n        combinedLabelValue = this.viewOptions.rightToLeft ? this.viewOptions.combineLabels(highDisplayValue, lowDisplayValue) : this.viewOptions.combineLabels(lowDisplayValue, highDisplayValue);\n        this.combinedLabelElement.setValue(combinedLabelValue);\n        var\n        /** @type {?} */\n        pos = this.viewOptions.boundPointerLabels ? Math.min(Math.max(this.selectionBarElement.position + this.selectionBarElement.dimension / 2 - this.combinedLabelElement.dimension / 2, 0), this.fullBarElement.dimension - this.combinedLabelElement.dimension) : this.selectionBarElement.position + this.selectionBarElement.dimension / 2 - this.combinedLabelElement.dimension / 2;\n        this.combinedLabelElement.setPosition(pos);\n        this.minHandleLabelElement.hide();\n        this.maxHandleLabelElement.hide();\n        this.combinedLabelElement.show();\n      } else {\n        this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n        this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n        this.maxHandleLabelElement.show();\n        this.minHandleLabelElement.show();\n        this.combinedLabelElement.hide();\n      }\n\n      if (this.viewOptions.autoHideLimitLabels) {\n        this.updateFloorAndCeilLabelsVisibility();\n      }\n    }\n    /**\n     * @param {?} value\n     * @param {?} which\n     * @return {?}\n     */\n\n  }, {\n    key: \"getDisplayValue\",\n    value: function getDisplayValue(value, which) {\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n        value = this.getStepValue(value);\n      }\n\n      return this.viewOptions.translate(value, which);\n    }\n    /**\n     * @param {?} value\n     * @param {?=} customStep\n     * @return {?}\n     */\n\n  }, {\n    key: \"roundStep\",\n    value: function roundStep(value, customStep) {\n      var\n      /** @type {?} */\n      step = !ValueHelper.isNullOrUndefined(customStep) ? customStep : this.viewOptions.step;\n      var\n      /** @type {?} */\n      steppedDifference = MathHelper.roundToPrecisionLimit((value - this.viewOptions.floor) / step, this.viewOptions.precisionLimit);\n      steppedDifference = Math.round(steppedDifference) * step;\n      return MathHelper.roundToPrecisionLimit(this.viewOptions.floor + steppedDifference, this.viewOptions.precisionLimit);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n\n  }, {\n    key: \"valueToPosition\",\n    value: function valueToPosition(val) {\n      var\n      /** @type {?} */\n      fn = ValueHelper.linearValueToPosition;\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.customValueToPosition)) {\n        fn = this.viewOptions.customValueToPosition;\n      } else if (this.viewOptions.logScale) {\n        fn = ValueHelper.logValueToPosition;\n      }\n\n      val = MathHelper.clampToRange(val, this.viewOptions.floor, this.viewOptions.ceil);\n      var\n      /** @type {?} */\n      percent = fn(val, this.viewOptions.floor, this.viewOptions.ceil);\n\n      if (ValueHelper.isNullOrUndefined(percent)) {\n        percent = 0;\n      }\n\n      if (this.viewOptions.rightToLeft) {\n        percent = 1 - percent;\n      }\n\n      return percent * this.maxHandlePosition;\n    }\n    /**\n     * @param {?} position\n     * @return {?}\n     */\n\n  }, {\n    key: \"positionToValue\",\n    value: function positionToValue(position) {\n      var\n      /** @type {?} */\n      percent = position / this.maxHandlePosition;\n\n      if (this.viewOptions.rightToLeft) {\n        percent = 1 - percent;\n      }\n\n      var\n      /** @type {?} */\n      fn = ValueHelper.linearPositionToValue;\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.customPositionToValue)) {\n        fn = this.viewOptions.customPositionToValue;\n      } else if (this.viewOptions.logScale) {\n        fn = ValueHelper.logPositionToValue;\n      }\n\n      var\n      /** @type {?} */\n      value = fn(percent, this.viewOptions.floor, this.viewOptions.ceil);\n      return !ValueHelper.isNullOrUndefined(value) ? value : 0;\n    }\n    /**\n     * @param {?} event\n     * @param {?=} targetTouchId\n     * @return {?}\n     */\n\n  }, {\n    key: \"getEventXY\",\n    value: function getEventXY(event, targetTouchId) {\n      if (event instanceof MouseEvent) {\n        return this.viewOptions.vertical ? event.clientY : event.clientX;\n      }\n\n      var\n      /** @type {?} */\n      touchIndex = 0;\n      var\n      /** @type {?} */\n      touches = event.touches;\n\n      if (!ValueHelper.isNullOrUndefined(targetTouchId)) {\n        for (var\n        /** @type {?} */\n        i = 0; i < touches.length; i++) {\n          if (touches[i].identifier === targetTouchId) {\n            touchIndex = i;\n            break;\n          }\n        }\n      } // Return the target touch or if the target touch was not found in the event\n      // returns the coordinates of the first touch\n\n\n      return this.viewOptions.vertical ? touches[touchIndex].clientY : touches[touchIndex].clientX;\n    }\n    /**\n     * @param {?} event\n     * @param {?=} targetTouchId\n     * @return {?}\n     */\n\n  }, {\n    key: \"getEventPosition\",\n    value: function getEventPosition(event, targetTouchId) {\n      var\n      /** @type {?} */\n      sliderElementBoundingRect = this.elementRef.nativeElement.getBoundingClientRect();\n      var\n      /** @type {?} */\n      sliderPos = this.viewOptions.vertical ? sliderElementBoundingRect.bottom : sliderElementBoundingRect.left;\n      var\n      /** @type {?} */\n      eventPos = 0;\n\n      if (this.viewOptions.vertical) {\n        eventPos = -this.getEventXY(event, targetTouchId) + sliderPos;\n      } else {\n        eventPos = this.getEventXY(event, targetTouchId) - sliderPos;\n      }\n\n      return eventPos * this.viewOptions.scale - this.handleHalfDimension;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"getNearestHandle\",\n    value: function getNearestHandle(event) {\n      if (!this.range) {\n        return PointerType.Min;\n      }\n\n      var\n      /** @type {?} */\n      position = this.getEventPosition(event);\n      var\n      /** @type {?} */\n      distanceMin = Math.abs(position - this.minHandleElement.position);\n      var\n      /** @type {?} */\n      distanceMax = Math.abs(position - this.maxHandleElement.position);\n\n      if (distanceMin < distanceMax) {\n        return PointerType.Min;\n      } else if (distanceMin > distanceMax) {\n        return PointerType.Max;\n      } else if (!this.viewOptions.rightToLeft) {\n        // if event is at the same distance from min/max then if it's at left of minH, we return minH else maxH\n        return position < this.minHandleElement.position ? PointerType.Min : PointerType.Max;\n      } // reverse in rtl\n\n\n      return position > this.minHandleElement.position ? PointerType.Min : PointerType.Max;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"bindEvents\",\n    value: function bindEvents() {\n      var _this10 = this;\n\n      var\n      /** @type {?} */\n      draggableRange = this.viewOptions.draggableRange;\n\n      if (!this.viewOptions.onlyBindHandles) {\n        this.selectionBarElement.on('mousedown', function (event) {\n          return _this10.onBarStart(null, draggableRange, event, true, true, true);\n        });\n      }\n\n      if (this.viewOptions.draggableRangeOnly) {\n        this.minHandleElement.on('mousedown', function (event) {\n          return _this10.onBarStart(PointerType.Min, draggableRange, event, true, true);\n        });\n        this.maxHandleElement.on('mousedown', function (event) {\n          return _this10.onBarStart(PointerType.Max, draggableRange, event, true, true);\n        });\n      } else {\n        this.minHandleElement.on('mousedown', function (event) {\n          return _this10.onStart(PointerType.Min, event, true, true);\n        });\n\n        if (this.range) {\n          this.maxHandleElement.on('mousedown', function (event) {\n            return _this10.onStart(PointerType.Max, event, true, true);\n          });\n        }\n\n        if (!this.viewOptions.onlyBindHandles) {\n          this.fullBarElement.on('mousedown', function (event) {\n            return _this10.onStart(null, event, true, true, true);\n          });\n          this.ticksElement.on('mousedown', function (event) {\n            return _this10.onStart(null, event, true, true, true, true);\n          });\n        }\n      }\n\n      if (!this.viewOptions.onlyBindHandles) {\n        this.selectionBarElement.onPassive('touchstart', function (event) {\n          return _this10.onBarStart(null, draggableRange, event, true, true, true);\n        });\n      }\n\n      if (this.viewOptions.draggableRangeOnly) {\n        this.minHandleElement.onPassive('touchstart', function (event) {\n          return _this10.onBarStart(PointerType.Min, draggableRange, event, true, true);\n        });\n        this.maxHandleElement.onPassive('touchstart', function (event) {\n          return _this10.onBarStart(PointerType.Max, draggableRange, event, true, true);\n        });\n      } else {\n        this.minHandleElement.onPassive('touchstart', function (event) {\n          return _this10.onStart(PointerType.Min, event, true, true);\n        });\n\n        if (this.range) {\n          this.maxHandleElement.onPassive('touchstart', function (event) {\n            return _this10.onStart(PointerType.Max, event, true, true);\n          });\n        }\n\n        if (!this.viewOptions.onlyBindHandles) {\n          this.fullBarElement.onPassive('touchstart', function (event) {\n            return _this10.onStart(null, event, true, true, true);\n          });\n          this.ticksElement.onPassive('touchstart', function (event) {\n            return _this10.onStart(null, event, false, false, true, true);\n          });\n        }\n      }\n\n      if (this.viewOptions.keyboardSupport) {\n        this.minHandleElement.on('focus', function () {\n          return _this10.onPointerFocus(PointerType.Min);\n        });\n\n        if (this.range) {\n          this.maxHandleElement.on('focus', function () {\n            return _this10.onPointerFocus(PointerType.Max);\n          });\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"unbindEvents\",\n    value: function unbindEvents() {\n      this.unsubscribeOnMove();\n      this.unsubscribeOnEnd();\n\n      var _iterator4 = _createForOfIteratorHelper(this.getAllSliderElements()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var element = _step4.value;\n          element.off();\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n    /**\n     * @param {?} pointerType\n     * @param {?} draggableRange\n     * @param {?} event\n     * @param {?} bindMove\n     * @param {?} bindEnd\n     * @param {?=} simulateImmediateMove\n     * @param {?=} simulateImmediateEnd\n     * @return {?}\n     */\n\n  }, {\n    key: \"onBarStart\",\n    value: function onBarStart(pointerType, draggableRange, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {\n      if (draggableRange) {\n        this.onDragStart(pointerType, event, bindMove, bindEnd);\n      } else {\n        this.onStart(pointerType, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd);\n      }\n    }\n    /**\n     * @param {?} pointerType\n     * @param {?} event\n     * @param {?} bindMove\n     * @param {?} bindEnd\n     * @param {?=} simulateImmediateMove\n     * @param {?=} simulateImmediateEnd\n     * @return {?}\n     */\n\n  }, {\n    key: \"onStart\",\n    value: function onStart(pointerType, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {\n      var _this11 = this;\n\n      event.stopPropagation(); // Only call preventDefault() when handling non-passive events (passive events don't need it)\n\n      if (!CompatibilityHelper.isTouchEvent(event) || !detectPassiveEvents.hasSupport) {\n        event.preventDefault();\n      } // We have to do this in case the HTML where the sliders are on\n      // have been animated into view.\n\n\n      this.calculateViewDimensions();\n\n      if (ValueHelper.isNullOrUndefined(pointerType)) {\n        pointerType = this.getNearestHandle(event);\n      }\n\n      this.currentTrackingPointer = pointerType;\n      var\n      /** @type {?} */\n      pointerElement = this.getPointerElement(pointerType);\n      pointerElement.active = true;\n\n      if (this.viewOptions.keyboardSupport) {\n        pointerElement.focus();\n      }\n\n      if (bindMove) {\n        this.unsubscribeOnMove();\n\n        var\n        /** @type {?} */\n        onMoveCallback = function onMoveCallback(e) {\n          return _this11.dragging.active ? _this11.onDragMove(e) : _this11.onMove(e);\n        };\n\n        if (CompatibilityHelper.isTouchEvent(event)) {\n          this.onMoveEventListener = this.eventListenerHelper.attachPassiveEventListener(document, 'touchmove', onMoveCallback, this.viewOptions.touchEventsInterval);\n        } else {\n          this.onMoveEventListener = this.eventListenerHelper.attachEventListener(document, 'mousemove', onMoveCallback, this.viewOptions.mouseEventsInterval);\n        }\n      }\n\n      if (bindEnd) {\n        this.unsubscribeOnEnd();\n\n        var\n        /** @type {?} */\n        onEndCallback = function onEndCallback(e) {\n          return _this11.onEnd(e);\n        };\n\n        if (CompatibilityHelper.isTouchEvent(event)) {\n          this.onEndEventListener = this.eventListenerHelper.attachPassiveEventListener(document, 'touchend', onEndCallback);\n        } else {\n          this.onEndEventListener = this.eventListenerHelper.attachEventListener(document, 'mouseup', onEndCallback);\n        }\n      }\n\n      this.userChangeStart.emit(this.getChangeContext());\n\n      if (CompatibilityHelper.isTouchEvent(event) && !ValueHelper.isNullOrUndefined(\n      /** @type {?} */\n      event.changedTouches)) {\n        // Store the touch identifier\n        if (ValueHelper.isNullOrUndefined(this.touchId)) {\n          this.touchId =\n          /** @type {?} */\n          event.changedTouches[0].identifier;\n        }\n      } // Click events, either with mouse or touch gesture are weird. Sometimes they result in full\n      // start, move, end sequence, and sometimes, they don't - they only invoke mousedown\n      // As a workaround, we simulate the first move event and the end event if it's necessary\n\n\n      if (simulateImmediateMove) {\n        this.onMove(event, true);\n      }\n\n      if (simulateImmediateEnd) {\n        this.onEnd(event);\n      }\n    }\n    /**\n     * @param {?} event\n     * @param {?=} fromTick\n     * @return {?}\n     */\n\n  }, {\n    key: \"onMove\",\n    value: function onMove(event, fromTick) {\n      var\n      /** @type {?} */\n      touchForThisSlider = null;\n\n      if (CompatibilityHelper.isTouchEvent(event)) {\n        var\n        /** @type {?} */\n        changedTouches =\n        /** @type {?} */\n        event.changedTouches;\n\n        for (var\n        /** @type {?} */\n        i = 0; i < changedTouches.length; i++) {\n          if (changedTouches[i].identifier === this.touchId) {\n            touchForThisSlider = changedTouches[i];\n            break;\n          }\n        }\n\n        if (ValueHelper.isNullOrUndefined(touchForThisSlider)) {\n          return;\n        }\n      }\n\n      var\n      /** @type {?} */\n      newPos = !ValueHelper.isNullOrUndefined(touchForThisSlider) ? this.getEventPosition(event, touchForThisSlider.identifier) : this.getEventPosition(event);\n      var\n      /** @type {?} */\n      newValue;\n      var\n      /** @type {?} */\n      ceilValue = this.viewOptions.rightToLeft ? this.viewOptions.floor : this.viewOptions.ceil;\n      var\n      /** @type {?} */\n      floorValue = this.viewOptions.rightToLeft ? this.viewOptions.ceil : this.viewOptions.floor;\n\n      if (newPos <= 0) {\n        newValue = floorValue;\n      } else if (newPos >= this.maxHandlePosition) {\n        newValue = ceilValue;\n      } else {\n        newValue = this.positionToValue(newPos);\n\n        if (fromTick && !ValueHelper.isNullOrUndefined(this.viewOptions.tickStep)) {\n          newValue = this.roundStep(newValue, this.viewOptions.tickStep);\n        } else {\n          newValue = this.roundStep(newValue);\n        }\n      }\n\n      this.positionTrackingHandle(newValue);\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onEnd\",\n    value: function onEnd(event) {\n      if (CompatibilityHelper.isTouchEvent(event)) {\n        var\n        /** @type {?} */\n        changedTouches =\n        /** @type {?} */\n        event.changedTouches;\n\n        if (changedTouches[0].identifier !== this.touchId) {\n          return;\n        }\n      }\n\n      this.touchId = null;\n\n      if (!this.viewOptions.keyboardSupport) {\n        this.minHandleElement.active = false;\n        this.maxHandleElement.active = false;\n        this.currentTrackingPointer = null;\n      }\n\n      this.dragging.active = false;\n      this.unsubscribeOnMove();\n      this.unsubscribeOnEnd();\n      this.userChangeEnd.emit(this.getChangeContext());\n    }\n    /**\n     * @param {?} pointerType\n     * @return {?}\n     */\n\n  }, {\n    key: \"onPointerFocus\",\n    value: function onPointerFocus(pointerType) {\n      var _this12 = this;\n\n      var\n      /** @type {?} */\n      pointerElement = this.getPointerElement(pointerType);\n      pointerElement.on('blur', function () {\n        return _this12.onPointerBlur(pointerElement);\n      });\n      pointerElement.on('keydown', function (event) {\n        return _this12.onKeyboardEvent(event);\n      });\n      pointerElement.on('keyup', function () {\n        return _this12.onKeyUp();\n      });\n      pointerElement.active = true;\n      this.currentTrackingPointer = pointerType;\n      this.currentFocusPointer = pointerType;\n      this.firstKeyDown = true;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"onKeyUp\",\n    value: function onKeyUp() {\n      this.firstKeyDown = true;\n      this.userChangeEnd.emit(this.getChangeContext());\n    }\n    /**\n     * @param {?} pointer\n     * @return {?}\n     */\n\n  }, {\n    key: \"onPointerBlur\",\n    value: function onPointerBlur(pointer) {\n      pointer.off('blur');\n      pointer.off('keydown');\n      pointer.off('keyup');\n      pointer.active = false;\n\n      if (ValueHelper.isNullOrUndefined(this.touchId)) {\n        this.currentTrackingPointer = null;\n        this.currentFocusPointer = null;\n      }\n    }\n    /**\n     * @param {?} currentValue\n     * @return {?}\n     */\n\n  }, {\n    key: \"getKeyActions\",\n    value: function getKeyActions(currentValue) {\n      var\n      /** @type {?} */\n      valueRange = this.viewOptions.ceil - this.viewOptions.floor;\n      var\n      /** @type {?} */\n      increaseStep = currentValue + this.viewOptions.step;\n      var\n      /** @type {?} */\n      decreaseStep = currentValue - this.viewOptions.step;\n      var\n      /** @type {?} */\n      increasePage = currentValue + valueRange / 10;\n      var\n      /** @type {?} */\n      decreasePage = currentValue - valueRange / 10;\n\n      if (this.viewOptions.reversedControls) {\n        increaseStep = currentValue - this.viewOptions.step;\n        decreaseStep = currentValue + this.viewOptions.step;\n        increasePage = currentValue - valueRange / 10;\n        decreasePage = currentValue + valueRange / 10;\n      } // Left to right default actions\n\n\n      var\n      /** @type {?} */\n      actions = {\n        UP: increaseStep,\n        DOWN: decreaseStep,\n        LEFT: decreaseStep,\n        RIGHT: increaseStep,\n        PAGEUP: increasePage,\n        PAGEDOWN: decreasePage,\n        HOME: this.viewOptions.reversedControls ? this.viewOptions.ceil : this.viewOptions.floor,\n        END: this.viewOptions.reversedControls ? this.viewOptions.floor : this.viewOptions.ceil\n      }; // right to left means swapping right and left arrows\n\n      if (this.viewOptions.rightToLeft) {\n        actions[\"LEFT\"] = increaseStep;\n        actions[\"RIGHT\"] = decreaseStep; // right to left and vertical means we also swap up and down\n\n        if (this.viewOptions.vertical) {\n          actions[\"UP\"] = decreaseStep;\n          actions[\"DOWN\"] = increaseStep;\n        }\n      }\n\n      return actions;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onKeyboardEvent\",\n    value: function onKeyboardEvent(event) {\n      var\n      /** @type {?} */\n      currentValue = this.getCurrentTrackingValue();\n      var\n      /** @type {?} */\n      keyCode = !ValueHelper.isNullOrUndefined(event.keyCode) ? event.keyCode : event.which;\n      var\n      /** @type {?} */\n      keys = {\n        38: 'UP',\n        40: 'DOWN',\n        37: 'LEFT',\n        39: 'RIGHT',\n        33: 'PAGEUP',\n        34: 'PAGEDOWN',\n        36: 'HOME',\n        35: 'END'\n      };\n      var\n      /** @type {?} */\n      actions = this.getKeyActions(currentValue);\n      var\n      /** @type {?} */\n      key = keys[keyCode];\n      var\n      /** @type {?} */\n      action = actions[key];\n\n      if (ValueHelper.isNullOrUndefined(action) || ValueHelper.isNullOrUndefined(this.currentTrackingPointer)) {\n        return;\n      }\n\n      event.preventDefault();\n\n      if (this.firstKeyDown) {\n        this.firstKeyDown = false;\n        this.userChangeStart.emit(this.getChangeContext());\n      }\n\n      var\n      /** @type {?} */\n      actionValue = MathHelper.clampToRange(action, this.viewOptions.floor, this.viewOptions.ceil);\n      var\n      /** @type {?} */\n      newValue = this.roundStep(actionValue);\n\n      if (!this.viewOptions.draggableRangeOnly) {\n        this.positionTrackingHandle(newValue);\n      } else {\n        var\n        /** @type {?} */\n        difference = this.viewHighValue - this.viewLowValue;\n        var\n        /** @type {?} */\n        newMinValue;\n        var\n        /** @type {?} */\n        newMaxValue;\n\n        if (this.currentTrackingPointer === PointerType.Min) {\n          newMinValue = newValue;\n          newMaxValue = newValue + difference;\n\n          if (newMaxValue > this.viewOptions.ceil) {\n            newMaxValue = this.viewOptions.ceil;\n            newMinValue = newMaxValue - difference;\n          }\n        } else if (this.currentTrackingPointer === PointerType.Max) {\n          newMaxValue = newValue;\n          newMinValue = newValue - difference;\n\n          if (newMinValue < this.viewOptions.floor) {\n            newMinValue = this.viewOptions.floor;\n            newMaxValue = newMinValue + difference;\n          }\n        }\n\n        this.positionTrackingBar(newMinValue, newMaxValue);\n      }\n    }\n    /**\n     * @param {?} pointerType\n     * @param {?} event\n     * @param {?} bindMove\n     * @param {?} bindEnd\n     * @return {?}\n     */\n\n  }, {\n    key: \"onDragStart\",\n    value: function onDragStart(pointerType, event, bindMove, bindEnd) {\n      var\n      /** @type {?} */\n      position = this.getEventPosition(event);\n      this.dragging = new Dragging();\n      this.dragging.active = true;\n      this.dragging.value = this.positionToValue(position);\n      this.dragging.difference = this.viewHighValue - this.viewLowValue;\n      this.dragging.lowLimit = this.viewOptions.rightToLeft ? this.minHandleElement.position - position : position - this.minHandleElement.position;\n      this.dragging.highLimit = this.viewOptions.rightToLeft ? position - this.maxHandleElement.position : this.maxHandleElement.position - position;\n      this.onStart(pointerType, event, bindMove, bindEnd);\n    }\n    /**\n     * Get min value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft\n     * @param {?} newPos\n     * @param {?} outOfBounds\n     * @param {?} isAbove\n     * @return {?}\n     */\n\n  }, {\n    key: \"getMinValue\",\n    value: function getMinValue(newPos, outOfBounds, isAbove) {\n      var\n      /** @type {?} */\n      isRTL = this.viewOptions.rightToLeft;\n      var\n      /** @type {?} */\n      value = null;\n\n      if (outOfBounds) {\n        if (isAbove) {\n          value = isRTL ? this.viewOptions.floor : this.viewOptions.ceil - this.dragging.difference;\n        } else {\n          value = isRTL ? this.viewOptions.ceil - this.dragging.difference : this.viewOptions.floor;\n        }\n      } else {\n        value = isRTL ? this.positionToValue(newPos + this.dragging.lowLimit) : this.positionToValue(newPos - this.dragging.lowLimit);\n      }\n\n      return this.roundStep(value);\n    }\n    /**\n     * Get max value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft\n     * @param {?} newPos\n     * @param {?} outOfBounds\n     * @param {?} isAbove\n     * @return {?}\n     */\n\n  }, {\n    key: \"getMaxValue\",\n    value: function getMaxValue(newPos, outOfBounds, isAbove) {\n      var\n      /** @type {?} */\n      isRTL = this.viewOptions.rightToLeft;\n      var\n      /** @type {?} */\n      value = null;\n\n      if (outOfBounds) {\n        if (isAbove) {\n          value = isRTL ? this.viewOptions.floor + this.dragging.difference : this.viewOptions.ceil;\n        } else {\n          value = isRTL ? this.viewOptions.ceil : this.viewOptions.floor + this.dragging.difference;\n        }\n      } else {\n        if (isRTL) {\n          value = this.positionToValue(newPos + this.dragging.lowLimit) + this.dragging.difference;\n        } else {\n          value = this.positionToValue(newPos - this.dragging.lowLimit) + this.dragging.difference;\n        }\n      }\n\n      return this.roundStep(value);\n    }\n    /**\n     * @param {?=} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onDragMove\",\n    value: function onDragMove(event) {\n      var\n      /** @type {?} */\n      newPos = this.getEventPosition(event);\n      var\n      /** @type {?} */\n      ceilLimit,\n      /** @type {?} */\n      floorLimit,\n      /** @type {?} */\n      floorHandleElement,\n      /** @type {?} */\n      ceilHandleElement;\n\n      if (this.viewOptions.rightToLeft) {\n        ceilLimit = this.dragging.lowLimit;\n        floorLimit = this.dragging.highLimit;\n        floorHandleElement = this.maxHandleElement;\n        ceilHandleElement = this.minHandleElement;\n      } else {\n        ceilLimit = this.dragging.highLimit;\n        floorLimit = this.dragging.lowLimit;\n        floorHandleElement = this.minHandleElement;\n        ceilHandleElement = this.maxHandleElement;\n      }\n\n      var\n      /** @type {?} */\n      isUnderFloorLimit = newPos <= floorLimit;\n      var\n      /** @type {?} */\n      isOverCeilLimit = newPos >= this.maxHandlePosition - ceilLimit;\n      var\n      /** @type {?} */\n      newMinValue;\n      var\n      /** @type {?} */\n      newMaxValue;\n\n      if (isUnderFloorLimit) {\n        if (floorHandleElement.position === 0) {\n          return;\n        }\n\n        newMinValue = this.getMinValue(newPos, true, false);\n        newMaxValue = this.getMaxValue(newPos, true, false);\n      } else if (isOverCeilLimit) {\n        if (ceilHandleElement.position === this.maxHandlePosition) {\n          return;\n        }\n\n        newMaxValue = this.getMaxValue(newPos, true, true);\n        newMinValue = this.getMinValue(newPos, true, true);\n      } else {\n        newMinValue = this.getMinValue(newPos, false, false);\n        newMaxValue = this.getMaxValue(newPos, false, false);\n      }\n\n      this.positionTrackingBar(newMinValue, newMaxValue);\n    }\n    /**\n     * @param {?} newMinValue\n     * @param {?} newMaxValue\n     * @return {?}\n     */\n\n  }, {\n    key: \"positionTrackingBar\",\n    value: function positionTrackingBar(newMinValue, newMaxValue) {\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) && newMinValue < this.viewOptions.minLimit) {\n        newMinValue = this.viewOptions.minLimit;\n        newMaxValue = MathHelper.roundToPrecisionLimit(newMinValue + this.dragging.difference, this.viewOptions.precisionLimit);\n      }\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) && newMaxValue > this.viewOptions.maxLimit) {\n        newMaxValue = this.viewOptions.maxLimit;\n        newMinValue = MathHelper.roundToPrecisionLimit(newMaxValue - this.dragging.difference, this.viewOptions.precisionLimit);\n      }\n\n      this.viewLowValue = newMinValue;\n      this.viewHighValue = newMaxValue;\n      this.applyViewChange();\n      this.updateHandles(PointerType.Min, this.valueToPosition(newMinValue));\n      this.updateHandles(PointerType.Max, this.valueToPosition(newMaxValue));\n    }\n    /**\n     * @param {?} newValue\n     * @return {?}\n     */\n\n  }, {\n    key: \"positionTrackingHandle\",\n    value: function positionTrackingHandle(newValue) {\n      newValue = this.applyMinMaxLimit(newValue);\n\n      if (this.range) {\n        if (this.viewOptions.pushRange) {\n          newValue = this.applyPushRange(newValue);\n        } else {\n          if (this.viewOptions.noSwitching) {\n            if (this.currentTrackingPointer === PointerType.Min && newValue > this.viewHighValue) {\n              newValue = this.applyMinMaxRange(this.viewHighValue);\n            } else if (this.currentTrackingPointer === PointerType.Max && newValue < this.viewLowValue) {\n              newValue = this.applyMinMaxRange(this.viewLowValue);\n            }\n          }\n\n          newValue = this.applyMinMaxRange(newValue);\n          /* This is to check if we need to switch the min and max handles */\n\n          if (this.currentTrackingPointer === PointerType.Min && newValue > this.viewHighValue) {\n            this.viewLowValue = this.viewHighValue;\n            this.applyViewChange();\n            this.updateHandles(PointerType.Min, this.maxHandleElement.position);\n            this.updateAriaAttributes();\n            this.currentTrackingPointer = PointerType.Max;\n            this.minHandleElement.active = false;\n            this.maxHandleElement.active = true;\n\n            if (this.viewOptions.keyboardSupport) {\n              this.maxHandleElement.focus();\n            }\n          } else if (this.currentTrackingPointer === PointerType.Max && newValue < this.viewLowValue) {\n            this.viewHighValue = this.viewLowValue;\n            this.applyViewChange();\n            this.updateHandles(PointerType.Max, this.minHandleElement.position);\n            this.updateAriaAttributes();\n            this.currentTrackingPointer = PointerType.Min;\n            this.maxHandleElement.active = false;\n            this.minHandleElement.active = true;\n\n            if (this.viewOptions.keyboardSupport) {\n              this.minHandleElement.focus();\n            }\n          }\n        }\n      }\n\n      if (this.getCurrentTrackingValue() !== newValue) {\n        if (this.currentTrackingPointer === PointerType.Min) {\n          this.viewLowValue = newValue;\n          this.applyViewChange();\n        } else if (this.currentTrackingPointer === PointerType.Max) {\n          this.viewHighValue = newValue;\n          this.applyViewChange();\n        }\n\n        this.updateHandles(this.currentTrackingPointer, this.valueToPosition(newValue));\n        this.updateAriaAttributes();\n      }\n    }\n    /**\n     * @param {?} newValue\n     * @return {?}\n     */\n\n  }, {\n    key: \"applyMinMaxLimit\",\n    value: function applyMinMaxLimit(newValue) {\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) && newValue < this.viewOptions.minLimit) {\n        return this.viewOptions.minLimit;\n      }\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) && newValue > this.viewOptions.maxLimit) {\n        return this.viewOptions.maxLimit;\n      }\n\n      return newValue;\n    }\n    /**\n     * @param {?} newValue\n     * @return {?}\n     */\n\n  }, {\n    key: \"applyMinMaxRange\",\n    value: function applyMinMaxRange(newValue) {\n      var\n      /** @type {?} */\n      oppositeValue = this.currentTrackingPointer === PointerType.Min ? this.viewHighValue : this.viewLowValue;\n      var\n      /** @type {?} */\n      difference = Math.abs(newValue - oppositeValue);\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.minRange)) {\n        if (difference < this.viewOptions.minRange) {\n          if (this.currentTrackingPointer === PointerType.Min) {\n            return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.minRange, this.viewOptions.precisionLimit);\n          } else if (this.currentTrackingPointer === PointerType.Max) {\n            return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.minRange, this.viewOptions.precisionLimit);\n          }\n        }\n      }\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxRange)) {\n        if (difference > this.viewOptions.maxRange) {\n          if (this.currentTrackingPointer === PointerType.Min) {\n            return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.maxRange, this.viewOptions.precisionLimit);\n          } else if (this.currentTrackingPointer === PointerType.Max) {\n            return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.maxRange, this.viewOptions.precisionLimit);\n          }\n        }\n      }\n\n      return newValue;\n    }\n    /**\n     * @param {?} newValue\n     * @return {?}\n     */\n\n  }, {\n    key: \"applyPushRange\",\n    value: function applyPushRange(newValue) {\n      var\n      /** @type {?} */\n      difference = this.currentTrackingPointer === PointerType.Min ? this.viewHighValue - newValue : newValue - this.viewLowValue;\n      var\n      /** @type {?} */\n      minRange = !ValueHelper.isNullOrUndefined(this.viewOptions.minRange) ? this.viewOptions.minRange : this.viewOptions.step;\n      var\n      /** @type {?} */\n      maxRange = this.viewOptions.maxRange; // if smaller than minRange\n\n      if (difference < minRange) {\n        if (this.currentTrackingPointer === PointerType.Min) {\n          this.viewHighValue = MathHelper.roundToPrecisionLimit(Math.min(newValue + minRange, this.viewOptions.ceil), this.viewOptions.precisionLimit);\n          newValue = MathHelper.roundToPrecisionLimit(this.viewHighValue - minRange, this.viewOptions.precisionLimit);\n          this.applyViewChange();\n          this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue));\n        } else if (this.currentTrackingPointer === PointerType.Max) {\n          this.viewLowValue = MathHelper.roundToPrecisionLimit(Math.max(newValue - minRange, this.viewOptions.floor), this.viewOptions.precisionLimit);\n          newValue = MathHelper.roundToPrecisionLimit(this.viewLowValue + minRange, this.viewOptions.precisionLimit);\n          this.applyViewChange();\n          this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));\n        }\n\n        this.updateAriaAttributes();\n      } else if (!ValueHelper.isNullOrUndefined(maxRange) && difference > maxRange) {\n        // if greater than maxRange\n        if (this.currentTrackingPointer === PointerType.Min) {\n          this.viewHighValue = MathHelper.roundToPrecisionLimit(newValue + maxRange, this.viewOptions.precisionLimit);\n          this.applyViewChange();\n          this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue));\n        } else if (this.currentTrackingPointer === PointerType.Max) {\n          this.viewLowValue = MathHelper.roundToPrecisionLimit(newValue - maxRange, this.viewOptions.precisionLimit);\n          this.applyViewChange();\n          this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));\n        }\n\n        this.updateAriaAttributes();\n      }\n\n      return newValue;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"getChangeContext\",\n    value: function getChangeContext() {\n      var\n      /** @type {?} */\n      changeContext = new ChangeContext();\n      changeContext.pointerType = this.currentTrackingPointer;\n      changeContext.value = +this.value;\n\n      if (this.range) {\n        changeContext.highValue = +this.highValue;\n      }\n\n      return changeContext;\n    }\n  }, {\n    key: \"manualRefresh\",\n    set: function set(manualRefresh) {\n      var _this13 = this;\n\n      this.unsubscribeManualRefresh();\n      this.manualRefreshSubscription = manualRefresh.subscribe(function () {\n        setTimeout(function () {\n          return _this13.calculateViewDimensionsAndDetectChanges();\n        });\n      });\n    }\n    /**\n     * @param {?} triggerFocus\n     * @return {?}\n     */\n\n  }, {\n    key: \"triggerFocus\",\n    set: function set(triggerFocus) {\n      var _this14 = this;\n\n      this.unsubscribeTriggerFocus();\n      this.triggerFocusSubscription = triggerFocus.subscribe(function (pointerType) {\n        _this14.focusPointer(pointerType);\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"range\",\n    get: function get() {\n      return !ValueHelper.isNullOrUndefined(this.value) && !ValueHelper.isNullOrUndefined(this.highValue);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"showTicks\",\n    get: function get() {\n      return this.viewOptions.showTicks;\n    }\n  }]);\n\n  return SliderComponent;\n}();\n\nSliderComponent.ɵfac = function SliderComponent_Factory(t) {\n  return new (t || SliderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n};\n\nSliderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n  type: SliderComponent,\n  selectors: [[\"ng5-slider\"]],\n  contentQueries: function SliderComponent_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵcontentQuery(dirIndex, _c0, 1);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);\n    }\n  },\n  viewQuery: function SliderComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(_c1, 1, SliderElementDirective);\n      ɵngcc0.ɵɵviewQuery(_c2, 1, SliderElementDirective);\n      ɵngcc0.ɵɵviewQuery(_c3, 1, SliderElementDirective);\n      ɵngcc0.ɵɵviewQuery(_c4, 1, SliderElementDirective);\n      ɵngcc0.ɵɵviewQuery(_c5, 1, SliderHandleDirective);\n      ɵngcc0.ɵɵviewQuery(_c6, 1, SliderHandleDirective);\n      ɵngcc0.ɵɵviewQuery(_c7, 1, SliderLabelDirective);\n      ɵngcc0.ɵɵviewQuery(_c8, 1, SliderLabelDirective);\n      ɵngcc0.ɵɵviewQuery(_c9, 1, SliderLabelDirective);\n      ɵngcc0.ɵɵviewQuery(_c10, 1, SliderLabelDirective);\n      ɵngcc0.ɵɵviewQuery(_c11, 1, SliderLabelDirective);\n      ɵngcc0.ɵɵviewQuery(_c12, 1, SliderElementDirective);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.leftOuterSelectionBarElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rightOuterSelectionBarElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fullBarElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.selectionBarElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.minHandleElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.maxHandleElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.floorLabelElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ceilLabelElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.minHandleLabelElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.maxHandleLabelElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.combinedLabelElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksElement = _t.first);\n    }\n  },\n  hostAttrs: [1, \"ng5-slider\"],\n  hostVars: 5,\n  hostBindings: function SliderComponent_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"resize\", function SliderComponent_resize_HostBindingHandler($event) {\n        return ctx.onResize($event);\n      }, false, ɵngcc0.ɵɵresolveWindow);\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"disabled\", ctx.sliderElementDisabledAttr);\n      ɵngcc0.ɵɵclassProp(\"vertical\", ctx.sliderElementVerticalClass)(\"animate\", ctx.sliderElementAnimateClass);\n    }\n  },\n  inputs: {\n    value: \"value\",\n    highValue: \"highValue\",\n    options: \"options\",\n    manualRefresh: \"manualRefresh\",\n    triggerFocus: \"triggerFocus\"\n  },\n  outputs: {\n    valueChange: \"valueChange\",\n    highValueChange: \"highValueChange\",\n    userChangeStart: \"userChangeStart\",\n    userChange: \"userChange\",\n    userChangeEnd: \"userChangeEnd\"\n  },\n  features: [ɵngcc0.ɵɵProvidersFeature([NG5_SLIDER_CONTROL_VALUE_ACCESSOR]), ɵngcc0.ɵɵNgOnChangesFeature],\n  decls: 29,\n  vars: 13,\n  consts: [[\"ng5SliderElement\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bar-wrapper\", \"ng5-slider-left-out-selection\"], [\"leftOuterSelectionBar\", \"\"], [1, \"ng5-slider-span\", \"ng5-slider-bar\"], [\"ng5SliderElement\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bar-wrapper\", \"ng5-slider-right-out-selection\"], [\"rightOuterSelectionBar\", \"\"], [\"ng5SliderElement\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bar-wrapper\", \"ng5-slider-full-bar\"], [\"fullBar\", \"\"], [\"ng5SliderElement\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bar-wrapper\", \"ng5-slider-selection-bar\"], [\"selectionBar\", \"\"], [1, \"ng5-slider-span\", \"ng5-slider-bar\", \"ng5-slider-selection\", 3, \"ngStyle\"], [\"ng5SliderHandle\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-pointer\", \"ng5-slider-pointer-min\", 3, \"ngStyle\"], [\"minHandle\", \"\"], [\"ng5SliderHandle\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-pointer\", \"ng5-slider-pointer-max\", 3, \"ngStyle\"], [\"maxHandle\", \"\"], [\"ng5SliderLabel\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bubble\", \"ng5-slider-limit\", \"ng5-slider-floor\"], [\"floorLabel\", \"\"], [\"ng5SliderLabel\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bubble\", \"ng5-slider-limit\", \"ng5-slider-ceil\"], [\"ceilLabel\", \"\"], [\"ng5SliderLabel\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bubble\", \"ng5-slider-model-value\"], [\"minHandleLabel\", \"\"], [\"ng5SliderLabel\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bubble\", \"ng5-slider-model-high\"], [\"maxHandleLabel\", \"\"], [\"ng5SliderLabel\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bubble\", \"ng5-slider-combined\"], [\"combinedLabel\", \"\"], [\"ng5SliderElement\", \"\", 1, \"ng5-slider-ticks\", 3, \"hidden\"], [\"ticksElement\", \"\"], [\"class\", \"ng5-slider-tick\", 3, \"ngClass\", \"ngStyle\", 4, \"ngFor\", \"ngForOf\"], [1, \"ng5-slider-tick\", 3, \"ngClass\", \"ngStyle\"], [3, \"template\", \"tooltip\", \"placement\"], [\"class\", \"ng5-slider-span ng5-slider-tick-value\", 3, \"template\", \"tooltip\", \"placement\", \"content\", 4, \"ngIf\"], [\"class\", \"ng5-slider-span ng5-slider-tick-legend\", 3, \"innerHTML\", 4, \"ngIf\"], [1, \"ng5-slider-span\", \"ng5-slider-tick-value\", 3, \"template\", \"tooltip\", \"placement\", \"content\"], [1, \"ng5-slider-span\", \"ng5-slider-tick-legend\", 3, \"innerHTML\"]],\n  template: function SliderComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵelementStart(0, \"span\", 0, 1);\n      ɵngcc0.ɵɵelement(2, \"span\", 2);\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelementStart(3, \"span\", 3, 4);\n      ɵngcc0.ɵɵelement(5, \"span\", 2);\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelementStart(6, \"span\", 5, 6);\n      ɵngcc0.ɵɵelement(8, \"span\", 2);\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelementStart(9, \"span\", 7, 8);\n      ɵngcc0.ɵɵelement(11, \"span\", 9);\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelement(12, \"span\", 10, 11);\n      ɵngcc0.ɵɵelement(14, \"span\", 12, 13);\n      ɵngcc0.ɵɵelement(16, \"span\", 14, 15);\n      ɵngcc0.ɵɵelement(18, \"span\", 16, 17);\n      ɵngcc0.ɵɵelement(20, \"span\", 18, 19);\n      ɵngcc0.ɵɵelement(22, \"span\", 20, 21);\n      ɵngcc0.ɵɵelement(24, \"span\", 22, 23);\n      ɵngcc0.ɵɵelementStart(26, \"span\", 24, 25);\n      ɵngcc0.ɵɵtemplate(28, SliderComponent_span_28_Template, 4, 9, \"span\", 26);\n      ɵngcc0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵadvance(6);\n      ɵngcc0.ɵɵclassProp(\"ng5-slider-transparent\", ctx.fullBarTransparentClass);\n      ɵngcc0.ɵɵadvance(3);\n      ɵngcc0.ɵɵclassProp(\"ng5-slider-draggable\", ctx.selectionBarDraggableClass);\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.barStyle);\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.minPointerStyle);\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵstyleProp(\"display\", ctx.range ? \"inherit\" : \"none\");\n      ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.maxPointerStyle);\n      ɵngcc0.ɵɵadvance(12);\n      ɵngcc0.ɵɵclassProp(\"ng5-slider-ticks-values-under\", ctx.ticksUnderValuesClass);\n      ɵngcc0.ɵɵproperty(\"hidden\", !ctx.showTicks);\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.ticks);\n    }\n  },\n  directives: function directives() {\n    return [SliderElementDirective, ɵngcc1.NgStyle, SliderHandleDirective, SliderLabelDirective, ɵngcc1.NgForOf, ɵngcc1.NgClass, TooltipWrapperComponent, ɵngcc1.NgIf];\n  },\n  styles: [\".ng5-slider{display:inline-block;position:relative;height:4px;width:100%;margin:35px 0 15px;vertical-align:middle;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-touch-action:pan-y;touch-action:pan-y}  .ng5-slider.with-legend{margin-bottom:40px}  .ng5-slider[disabled]{cursor:not-allowed}  .ng5-slider[disabled] .ng5-slider-pointer{cursor:not-allowed;background-color:#d8e0f3}  .ng5-slider[disabled] .ng5-slider-draggable{cursor:not-allowed}  .ng5-slider[disabled] .ng5-slider-selection{background:#8b91a2}  .ng5-slider[disabled] .ng5-slider-tick{cursor:not-allowed}  .ng5-slider[disabled] .ng5-slider-tick.ng5-slider-selected{background:#8b91a2}  .ng5-slider .ng5-slider-span{white-space:nowrap;position:absolute;display:inline-block}  .ng5-slider .ng5-slider-base{width:100%;height:100%;padding:0}  .ng5-slider .ng5-slider-bar-wrapper{left:0;-webkit-box-sizing:border-box;box-sizing:border-box;margin-top:-16px;padding-top:16px;width:100%;height:32px;z-index:1}  .ng5-slider .ng5-slider-draggable{cursor:move}  .ng5-slider .ng5-slider-bar{left:0;width:100%;height:4px;z-index:1;background:#d8e0f3;border-radius:2px}  .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-transparent .ng5-slider-bar{background:0 0}  .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-left-out-selection .ng5-slider-bar{background:#df002d}  .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-right-out-selection .ng5-slider-bar{background:#03a688}  .ng5-slider .ng5-slider-selection{z-index:2;background:#0db9f0;border-radius:2px}  .ng5-slider .ng5-slider-pointer{cursor:pointer;width:32px;height:32px;top:-14px;background-color:#0db9f0;z-index:3;border-radius:16px}  .ng5-slider .ng5-slider-pointer:after{content:'';width:8px;height:8px;position:absolute;top:12px;left:12px;border-radius:4px;background:#fff}  .ng5-slider .ng5-slider-pointer:hover:after{background-color:#fff}  .ng5-slider .ng5-slider-pointer.ng5-slider-active{z-index:4}  .ng5-slider .ng5-slider-pointer.ng5-slider-active:after{background-color:#451aff}  .ng5-slider .ng5-slider-bubble{cursor:default;bottom:16px;padding:1px 3px;color:#55637d;font-size:16px}  .ng5-slider .ng5-slider-bubble.ng5-slider-limit{color:#55637d}  .ng5-slider .ng5-slider-ticks{-webkit-box-sizing:border-box;box-sizing:border-box;width:100%;height:0;position:absolute;left:0;top:-3px;margin:0;z-index:1;list-style:none}  .ng5-slider .ng5-slider-ticks-values-under .ng5-slider-tick-value{top:auto;bottom:-36px}  .ng5-slider .ng5-slider-tick{text-align:center;cursor:pointer;width:10px;height:10px;background:#d8e0f3;border-radius:50%;position:absolute;top:0;left:0;margin-left:11px}  .ng5-slider .ng5-slider-tick.ng5-slider-selected{background:#0db9f0}  .ng5-slider .ng5-slider-tick-value{position:absolute;top:-34px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0)}  .ng5-slider .ng5-slider-tick-legend{position:absolute;top:24px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);max-width:50px;white-space:normal}  .ng5-slider.vertical{position:relative;width:4px;height:100%;margin:0 20px;padding:0;vertical-align:baseline;-ms-touch-action:pan-x;touch-action:pan-x}  .ng5-slider.vertical .ng5-slider-base{width:100%;height:100%;padding:0}  .ng5-slider.vertical .ng5-slider-bar-wrapper{top:auto;left:0;margin:0 0 0 -16px;padding:0 0 0 16px;height:100%;width:32px}  .ng5-slider.vertical .ng5-slider-bar{bottom:0;left:auto;width:4px;height:100%}  .ng5-slider.vertical .ng5-slider-pointer{left:-14px!important;top:auto;bottom:0}  .ng5-slider.vertical .ng5-slider-bubble{left:16px!important;bottom:0}  .ng5-slider.vertical .ng5-slider-ticks{height:100%;width:0;left:-3px;top:0;z-index:1}  .ng5-slider.vertical .ng5-slider-tick{vertical-align:middle;margin-left:auto;margin-top:11px}  .ng5-slider.vertical .ng5-slider-tick-value{left:24px;top:auto;-webkit-transform:translate(0,-28%);transform:translate(0,-28%)}  .ng5-slider.vertical .ng5-slider-tick-legend{top:auto;right:24px;-webkit-transform:translate(0,-28%);transform:translate(0,-28%);max-width:none;white-space:nowrap}  .ng5-slider.vertical .ng5-slider-ticks-values-under .ng5-slider-tick-value{bottom:auto;left:auto;right:24px}  .ng5-slider *{-webkit-transition:none;transition:none}  .ng5-slider.animate .ng5-slider-bar-wrapper{-webkit-transition:all linear .3s;transition:all linear .3s}  .ng5-slider.animate .ng5-slider-selection{-webkit-transition:background-color linear .3s;transition:background-color linear .3s}  .ng5-slider.animate .ng5-slider-pointer{-webkit-transition:all linear .3s;transition:all linear .3s}  .ng5-slider.animate .ng5-slider-bubble{-webkit-transition:all linear .3s;transition:all linear .3s}  .ng5-slider.animate .ng5-slider-bubble.ng5-slider-limit{-webkit-transition:opacity linear .3s;transition:opacity linear .3s}  .ng5-slider.animate .ng5-slider-bubble.ng5-slider-combined{-webkit-transition:opacity linear .3s;transition:opacity linear .3s}  .ng5-slider.animate .ng5-slider-tick{-webkit-transition:background-color linear .3s;transition:background-color linear .3s}\"]\n});\n/** @nocollapse */\n\nSliderComponent.ctorParameters = function () {\n  return [{\n    type: Renderer2\n  }, {\n    type: ElementRef\n  }, {\n    type: ChangeDetectorRef\n  }, {\n    type: NgZone\n  }];\n};\n\nSliderComponent.propDecorators = {\n  \"value\": [{\n    type: Input\n  }],\n  \"valueChange\": [{\n    type: Output\n  }],\n  \"highValue\": [{\n    type: Input\n  }],\n  \"highValueChange\": [{\n    type: Output\n  }],\n  \"options\": [{\n    type: Input\n  }],\n  \"userChangeStart\": [{\n    type: Output\n  }],\n  \"userChange\": [{\n    type: Output\n  }],\n  \"userChangeEnd\": [{\n    type: Output\n  }],\n  \"manualRefresh\": [{\n    type: Input\n  }],\n  \"triggerFocus\": [{\n    type: Input\n  }],\n  \"leftOuterSelectionBarElement\": [{\n    type: ViewChild,\n    args: ['leftOuterSelectionBar', {\n      read: SliderElementDirective\n    }]\n  }],\n  \"rightOuterSelectionBarElement\": [{\n    type: ViewChild,\n    args: ['rightOuterSelectionBar', {\n      read: SliderElementDirective\n    }]\n  }],\n  \"fullBarElement\": [{\n    type: ViewChild,\n    args: ['fullBar', {\n      read: SliderElementDirective\n    }]\n  }],\n  \"selectionBarElement\": [{\n    type: ViewChild,\n    args: ['selectionBar', {\n      read: SliderElementDirective\n    }]\n  }],\n  \"minHandleElement\": [{\n    type: ViewChild,\n    args: ['minHandle', {\n      read: SliderHandleDirective\n    }]\n  }],\n  \"maxHandleElement\": [{\n    type: ViewChild,\n    args: ['maxHandle', {\n      read: SliderHandleDirective\n    }]\n  }],\n  \"floorLabelElement\": [{\n    type: ViewChild,\n    args: ['floorLabel', {\n      read: SliderLabelDirective\n    }]\n  }],\n  \"ceilLabelElement\": [{\n    type: ViewChild,\n    args: ['ceilLabel', {\n      read: SliderLabelDirective\n    }]\n  }],\n  \"minHandleLabelElement\": [{\n    type: ViewChild,\n    args: ['minHandleLabel', {\n      read: SliderLabelDirective\n    }]\n  }],\n  \"maxHandleLabelElement\": [{\n    type: ViewChild,\n    args: ['maxHandleLabel', {\n      read: SliderLabelDirective\n    }]\n  }],\n  \"combinedLabelElement\": [{\n    type: ViewChild,\n    args: ['combinedLabel', {\n      read: SliderLabelDirective\n    }]\n  }],\n  \"ticksElement\": [{\n    type: ViewChild,\n    args: ['ticksElement', {\n      read: SliderElementDirective\n    }]\n  }],\n  \"tooltipTemplate\": [{\n    type: ContentChild,\n    args: ['tooltipTemplate']\n  }],\n  \"sliderElementVerticalClass\": [{\n    type: HostBinding,\n    args: ['class.vertical']\n  }],\n  \"sliderElementAnimateClass\": [{\n    type: HostBinding,\n    args: ['class.animate']\n  }],\n  \"sliderElementDisabledAttr\": [{\n    type: HostBinding,\n    args: ['attr.disabled']\n  }],\n  \"onResize\": [{\n    type: HostListener,\n    args: ['window:resize', ['$event']]\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SliderComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ng5-slider',\n      template: \"<!-- // 0 Left selection bar outside two handles -->\\n<span ng5SliderElement #leftOuterSelectionBar class=\\\"ng5-slider-span ng5-slider-bar-wrapper ng5-slider-left-out-selection\\\">\\n  <span class=\\\"ng5-slider-span ng5-slider-bar\\\"></span>\\n</span>\\n<!-- // 1 Right selection bar outside two handles -->\\n<span ng5SliderElement #rightOuterSelectionBar class=\\\"ng5-slider-span ng5-slider-bar-wrapper ng5-slider-right-out-selection\\\">\\n  <span class=\\\"ng5-slider-span ng5-slider-bar\\\"></span>\\n</span>\\n<!-- // 2 The whole slider bar -->\\n<span ng5SliderElement #fullBar [class.ng5-slider-transparent]=\\\"fullBarTransparentClass\\\" class=\\\"ng5-slider-span ng5-slider-bar-wrapper ng5-slider-full-bar\\\">\\n  <span class=\\\"ng5-slider-span ng5-slider-bar\\\"></span>\\n</span>\\n<!-- // 3 Selection bar between two handles -->\\n<span ng5SliderElement #selectionBar [class.ng5-slider-draggable]=\\\"selectionBarDraggableClass\\\" class=\\\"ng5-slider-span ng5-slider-bar-wrapper ng5-slider-selection-bar\\\">\\n  <span class=\\\"ng5-slider-span ng5-slider-bar ng5-slider-selection\\\" [ngStyle]=\\\"barStyle\\\"></span>\\n</span>\\n<!-- // 4 Low slider handle -->\\n<span ng5SliderHandle #minHandle class=\\\"ng5-slider-span ng5-slider-pointer ng5-slider-pointer-min\\\" [ngStyle]=minPointerStyle></span>\\n<!-- // 5 High slider handle -->\\n<span ng5SliderHandle #maxHandle [style.display]=\\\"range ? 'inherit' : 'none'\\\" class=\\\"ng5-slider-span ng5-slider-pointer ng5-slider-pointer-max\\\" [ngStyle]=maxPointerStyle></span>\\n<!-- // 6 Floor label -->\\n<span ng5SliderLabel #floorLabel class=\\\"ng5-slider-span ng5-slider-bubble ng5-slider-limit ng5-slider-floor\\\"></span>\\n<!-- // 7 Ceiling label -->\\n<span ng5SliderLabel #ceilLabel class=\\\"ng5-slider-span ng5-slider-bubble ng5-slider-limit ng5-slider-ceil\\\"></span>\\n<!-- // 8 Label above the low slider handle -->\\n<span ng5SliderLabel #minHandleLabel class=\\\"ng5-slider-span ng5-slider-bubble ng5-slider-model-value\\\"></span>\\n<!-- // 9 Label above the high slider handle -->\\n<span ng5SliderLabel #maxHandleLabel class=\\\"ng5-slider-span ng5-slider-bubble ng5-slider-model-high\\\"></span>\\n<!-- // 10 Combined range label when the slider handles are close ex. 15 - 17 -->\\n<span ng5SliderLabel #combinedLabel class=\\\"ng5-slider-span ng5-slider-bubble ng5-slider-combined\\\"></span>\\n<!-- // 11 The ticks -->\\n<span ng5SliderElement #ticksElement [hidden]=\\\"!showTicks\\\" [class.ng5-slider-ticks-values-under]=\\\"ticksUnderValuesClass\\\" class=\\\"ng5-slider-ticks\\\">\\n  <span *ngFor=\\\"let t of ticks\\\" class=\\\"ng5-slider-tick\\\" [ngClass]=\\\"{'ng5-slider-selected': t.selected}\\\" [ngStyle]=\\\"t.style\\\">\\n    <ng5-slider-tooltip-wrapper [template]=\\\"tooltipTemplate\\\" [tooltip]=\\\"t.tooltip\\\" [placement]=\\\"t.tooltipPlacement\\\"></ng5-slider-tooltip-wrapper>\\n    <ng5-slider-tooltip-wrapper *ngIf=\\\"t.value != null\\\" class=\\\"ng5-slider-span ng5-slider-tick-value\\\"\\n        [template]=\\\"tooltipTemplate\\\" [tooltip]=\\\"t.valueTooltip\\\" [placement]=\\\"t.valueTooltipPlacement\\\" [content]=\\\"t.value\\\"></ng5-slider-tooltip-wrapper>\\n    <span *ngIf=\\\"t.legend != null\\\" class=\\\"ng5-slider-span ng5-slider-tick-legend\\\" [innerHTML]=\\\"t.legend\\\"></span>\\n  </span>\\n</span>\",\n      styles: [\"::ng-deep .ng5-slider{display:inline-block;position:relative;height:4px;width:100%;margin:35px 0 15px;vertical-align:middle;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-touch-action:pan-y;touch-action:pan-y}::ng-deep .ng5-slider.with-legend{margin-bottom:40px}::ng-deep .ng5-slider[disabled]{cursor:not-allowed}::ng-deep .ng5-slider[disabled] .ng5-slider-pointer{cursor:not-allowed;background-color:#d8e0f3}::ng-deep .ng5-slider[disabled] .ng5-slider-draggable{cursor:not-allowed}::ng-deep .ng5-slider[disabled] .ng5-slider-selection{background:#8b91a2}::ng-deep .ng5-slider[disabled] .ng5-slider-tick{cursor:not-allowed}::ng-deep .ng5-slider[disabled] .ng5-slider-tick.ng5-slider-selected{background:#8b91a2}::ng-deep .ng5-slider .ng5-slider-span{white-space:nowrap;position:absolute;display:inline-block}::ng-deep .ng5-slider .ng5-slider-base{width:100%;height:100%;padding:0}::ng-deep .ng5-slider .ng5-slider-bar-wrapper{left:0;-webkit-box-sizing:border-box;box-sizing:border-box;margin-top:-16px;padding-top:16px;width:100%;height:32px;z-index:1}::ng-deep .ng5-slider .ng5-slider-draggable{cursor:move}::ng-deep .ng5-slider .ng5-slider-bar{left:0;width:100%;height:4px;z-index:1;background:#d8e0f3;border-radius:2px}::ng-deep .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-transparent .ng5-slider-bar{background:0 0}::ng-deep .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-left-out-selection .ng5-slider-bar{background:#df002d}::ng-deep .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-right-out-selection .ng5-slider-bar{background:#03a688}::ng-deep .ng5-slider .ng5-slider-selection{z-index:2;background:#0db9f0;border-radius:2px}::ng-deep .ng5-slider .ng5-slider-pointer{cursor:pointer;width:32px;height:32px;top:-14px;background-color:#0db9f0;z-index:3;border-radius:16px}::ng-deep .ng5-slider .ng5-slider-pointer:after{content:'';width:8px;height:8px;position:absolute;top:12px;left:12px;border-radius:4px;background:#fff}::ng-deep .ng5-slider .ng5-slider-pointer:hover:after{background-color:#fff}::ng-deep .ng5-slider .ng5-slider-pointer.ng5-slider-active{z-index:4}::ng-deep .ng5-slider .ng5-slider-pointer.ng5-slider-active:after{background-color:#451aff}::ng-deep .ng5-slider .ng5-slider-bubble{cursor:default;bottom:16px;padding:1px 3px;color:#55637d;font-size:16px}::ng-deep .ng5-slider .ng5-slider-bubble.ng5-slider-limit{color:#55637d}::ng-deep .ng5-slider .ng5-slider-ticks{-webkit-box-sizing:border-box;box-sizing:border-box;width:100%;height:0;position:absolute;left:0;top:-3px;margin:0;z-index:1;list-style:none}::ng-deep .ng5-slider .ng5-slider-ticks-values-under .ng5-slider-tick-value{top:auto;bottom:-36px}::ng-deep .ng5-slider .ng5-slider-tick{text-align:center;cursor:pointer;width:10px;height:10px;background:#d8e0f3;border-radius:50%;position:absolute;top:0;left:0;margin-left:11px}::ng-deep .ng5-slider .ng5-slider-tick.ng5-slider-selected{background:#0db9f0}::ng-deep .ng5-slider .ng5-slider-tick-value{position:absolute;top:-34px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0)}::ng-deep .ng5-slider .ng5-slider-tick-legend{position:absolute;top:24px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);max-width:50px;white-space:normal}::ng-deep .ng5-slider.vertical{position:relative;width:4px;height:100%;margin:0 20px;padding:0;vertical-align:baseline;-ms-touch-action:pan-x;touch-action:pan-x}::ng-deep .ng5-slider.vertical .ng5-slider-base{width:100%;height:100%;padding:0}::ng-deep .ng5-slider.vertical .ng5-slider-bar-wrapper{top:auto;left:0;margin:0 0 0 -16px;padding:0 0 0 16px;height:100%;width:32px}::ng-deep .ng5-slider.vertical .ng5-slider-bar{bottom:0;left:auto;width:4px;height:100%}::ng-deep .ng5-slider.vertical .ng5-slider-pointer{left:-14px!important;top:auto;bottom:0}::ng-deep .ng5-slider.vertical .ng5-slider-bubble{left:16px!important;bottom:0}::ng-deep .ng5-slider.vertical .ng5-slider-ticks{height:100%;width:0;left:-3px;top:0;z-index:1}::ng-deep .ng5-slider.vertical .ng5-slider-tick{vertical-align:middle;margin-left:auto;margin-top:11px}::ng-deep .ng5-slider.vertical .ng5-slider-tick-value{left:24px;top:auto;-webkit-transform:translate(0,-28%);transform:translate(0,-28%)}::ng-deep .ng5-slider.vertical .ng5-slider-tick-legend{top:auto;right:24px;-webkit-transform:translate(0,-28%);transform:translate(0,-28%);max-width:none;white-space:nowrap}::ng-deep .ng5-slider.vertical .ng5-slider-ticks-values-under .ng5-slider-tick-value{bottom:auto;left:auto;right:24px}::ng-deep .ng5-slider *{-webkit-transition:none;transition:none}::ng-deep .ng5-slider.animate .ng5-slider-bar-wrapper{-webkit-transition:all linear .3s;transition:all linear .3s}::ng-deep .ng5-slider.animate .ng5-slider-selection{-webkit-transition:background-color linear .3s;transition:background-color linear .3s}::ng-deep .ng5-slider.animate .ng5-slider-pointer{-webkit-transition:all linear .3s;transition:all linear .3s}::ng-deep .ng5-slider.animate .ng5-slider-bubble{-webkit-transition:all linear .3s;transition:all linear .3s}::ng-deep .ng5-slider.animate .ng5-slider-bubble.ng5-slider-limit{-webkit-transition:opacity linear .3s;transition:opacity linear .3s}::ng-deep .ng5-slider.animate .ng5-slider-bubble.ng5-slider-combined{-webkit-transition:opacity linear .3s;transition:opacity linear .3s}::ng-deep .ng5-slider.animate .ng5-slider-tick{-webkit-transition:background-color linear .3s;transition:background-color linear .3s}\"],\n      host: {\n        class: 'ng5-slider'\n      },\n      providers: [NG5_SLIDER_CONTROL_VALUE_ACCESSOR]\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.Renderer2\n    }, {\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.ChangeDetectorRef\n    }, {\n      type: ɵngcc0.NgZone\n    }];\n  }, {\n    value: [{\n      type: Input\n    }],\n    valueChange: [{\n      type: Output\n    }],\n    highValue: [{\n      type: Input\n    }],\n    highValueChange: [{\n      type: Output\n    }],\n    options: [{\n      type: Input\n    }],\n    userChangeStart: [{\n      type: Output\n    }],\n    userChange: [{\n      type: Output\n    }],\n    userChangeEnd: [{\n      type: Output\n    }],\n    sliderElementVerticalClass: [{\n      type: HostBinding,\n      args: ['class.vertical']\n    }],\n    sliderElementAnimateClass: [{\n      type: HostBinding,\n      args: ['class.animate']\n    }],\n    sliderElementDisabledAttr: [{\n      type: HostBinding,\n      args: ['attr.disabled']\n    }],\n    manualRefresh: [{\n      type: Input\n    }],\n    triggerFocus: [{\n      type: Input\n    }],\n\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    onResize: [{\n      type: HostListener,\n      args: ['window:resize', ['$event']]\n    }],\n    leftOuterSelectionBarElement: [{\n      type: ViewChild,\n      args: ['leftOuterSelectionBar', {\n        read: SliderElementDirective\n      }]\n    }],\n    rightOuterSelectionBarElement: [{\n      type: ViewChild,\n      args: ['rightOuterSelectionBar', {\n        read: SliderElementDirective\n      }]\n    }],\n    fullBarElement: [{\n      type: ViewChild,\n      args: ['fullBar', {\n        read: SliderElementDirective\n      }]\n    }],\n    selectionBarElement: [{\n      type: ViewChild,\n      args: ['selectionBar', {\n        read: SliderElementDirective\n      }]\n    }],\n    minHandleElement: [{\n      type: ViewChild,\n      args: ['minHandle', {\n        read: SliderHandleDirective\n      }]\n    }],\n    maxHandleElement: [{\n      type: ViewChild,\n      args: ['maxHandle', {\n        read: SliderHandleDirective\n      }]\n    }],\n    floorLabelElement: [{\n      type: ViewChild,\n      args: ['floorLabel', {\n        read: SliderLabelDirective\n      }]\n    }],\n    ceilLabelElement: [{\n      type: ViewChild,\n      args: ['ceilLabel', {\n        read: SliderLabelDirective\n      }]\n    }],\n    minHandleLabelElement: [{\n      type: ViewChild,\n      args: ['minHandleLabel', {\n        read: SliderLabelDirective\n      }]\n    }],\n    maxHandleLabelElement: [{\n      type: ViewChild,\n      args: ['maxHandleLabel', {\n        read: SliderLabelDirective\n      }]\n    }],\n    combinedLabelElement: [{\n      type: ViewChild,\n      args: ['combinedLabel', {\n        read: SliderLabelDirective\n      }]\n    }],\n    ticksElement: [{\n      type: ViewChild,\n      args: ['ticksElement', {\n        read: SliderElementDirective\n      }]\n    }],\n    tooltipTemplate: [{\n      type: ContentChild,\n      args: ['tooltipTemplate']\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar TooltipWrapperComponent = function TooltipWrapperComponent() {\n  _classCallCheck(this, TooltipWrapperComponent);\n};\n\nTooltipWrapperComponent.ɵfac = function TooltipWrapperComponent_Factory(t) {\n  return new (t || TooltipWrapperComponent)();\n};\n\nTooltipWrapperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n  type: TooltipWrapperComponent,\n  selectors: [[\"ng5-slider-tooltip-wrapper\"]],\n  inputs: {\n    template: \"template\",\n    tooltip: \"tooltip\",\n    placement: \"placement\",\n    content: \"content\"\n  },\n  decls: 2,\n  vars: 2,\n  consts: [[4, \"ngIf\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"ng5-slider-inner-tooltip\"]],\n  template: function TooltipWrapperComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵtemplate(0, TooltipWrapperComponent_ng_container_0_Template, 2, 6, \"ng-container\", 0);\n      ɵngcc0.ɵɵtemplate(1, TooltipWrapperComponent_ng_container_1_Template, 3, 3, \"ng-container\", 0);\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵproperty(\"ngIf\", ctx.template);\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.template);\n    }\n  },\n  directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet],\n  styles: [\".ng5-slider-inner-tooltip[_ngcontent-%COMP%]{height:100%}\"]\n});\n/** @nocollapse */\n\nTooltipWrapperComponent.ctorParameters = function () {\n  return [];\n};\n\nTooltipWrapperComponent.propDecorators = {\n  \"template\": [{\n    type: Input\n  }],\n  \"tooltip\": [{\n    type: Input\n  }],\n  \"placement\": [{\n    type: Input\n  }],\n  \"content\": [{\n    type: Input\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipWrapperComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ng5-slider-tooltip-wrapper',\n      template: \"<ng-container *ngIf=\\\"template\\\">\\n  <ng-template *ngTemplateOutlet=\\\"template; context: {tooltip: tooltip, placement: placement, content: content}\\\"></ng-template>\\n</ng-container>\\n\\n<ng-container *ngIf=\\\"!template\\\">\\n  <div class=\\\"ng5-slider-inner-tooltip\\\" [attr.title]=\\\"tooltip\\\" [attr.data-tooltip-placement]=\\\"placement\\\">\\n    {{content}}\\n  </div>\\n</ng-container>\",\n      styles: [\".ng5-slider-inner-tooltip{height:100%}\"]\n    }]\n  }], null, {\n    template: [{\n      type: Input\n    }],\n    tooltip: [{\n      type: Input\n    }],\n    placement: [{\n      type: Input\n    }],\n    content: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Ng5Slider module\n *\n * The module exports the slider component\n */\n\n\nvar Ng5SliderModule = function Ng5SliderModule() {\n  _classCallCheck(this, Ng5SliderModule);\n};\n\nNg5SliderModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: Ng5SliderModule\n});\nNg5SliderModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function Ng5SliderModule_Factory(t) {\n    return new (t || Ng5SliderModule)();\n  },\n  imports: [[CommonModule]]\n});\n/** @nocollapse */\n\nNg5SliderModule.ctorParameters = function () {\n  return [];\n};\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(Ng5SliderModule, {\n    declarations: function declarations() {\n      return [SliderComponent, SliderElementDirective, SliderHandleDirective, SliderLabelDirective, TooltipWrapperComponent];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [SliderComponent];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Ng5SliderModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [SliderComponent, SliderElementDirective, SliderHandleDirective, SliderLabelDirective, TooltipWrapperComponent],\n      exports: [SliderComponent]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Ng5SliderModule, ChangeContext, PointerType, LabelType, Options, SliderElementDirective as ɵb, SliderHandleDirective as ɵc, SliderLabelDirective as ɵd, SliderComponent as ɵa, TooltipWrapperComponent as ɵe };","map":{"version":3,"sources":["ng5-slider/out/options.ts","ng5-slider/out/change-context.ts","ng5-slider/out/value-helper.ts","ng5-slider/out/compatibility-helper.ts","ng5-slider/out/math-helper.ts","ng5-slider/out/event-listener.ts","ng5-slider/out/event-listener-helper.ts","ng5-slider/out/slider-element.directive.ts","ng5-slider/out/slider-handle.directive.ts","ng5-slider/out/slider-label.directive.ts","ng5-slider/out/slider.component.ts","ng5-slider/out/tooltip-wrapper.component.ts","ng5-slider/out/slider.module.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAAsB,IAAA,SAAA,GAAA;AAAoB;AAG9B,EAAA,GAAA,EAAA,CAHU;;AAItB;AACG,EAAA,IAAA,EAAA,CALmB;;AAMb;AAEA,EAAA,KAAA,EAAA,CARa;;AAQC;AAEP,EAAA,IAAA,EAAA,CAVM;;AAUO;AAEb,EAAA,SAAA,EAAA;AAZM,CAAA;AAalB,SAAA,CAAA,SAAA,CAAA,GAAA,CAAA,GAAA,KAAA;AAGmB,SAAA,CAAA,SAAA,CAAA,IAAA,CAAA,GAAA,MAAA;AACf,SAAA,CAAA,SAAA,CAAA,KAAA,CAAA,GAAA,OAAA;AAAsC,SAAA,CAAA,SAAA,CAAA,IAAA,CAAA,GAAA,MAAA;AACzC,SAAA,CAAA,SAAA,CAAA,SAAA,CAAA,GAAA,WAAA;AACmB;AAAI;AAA0B;AAAG;AAEvC;AAAW;;AAAK;AAAI;AAAkB;;IAqBxD,O,GAAE,mBAAA;AAAA;;AAAoB;AACX;AACK;AACI;AAApB,OAAA,KAAA,GAAA,CAAA;AAAC;AAAY;AAEgB;AACe;;AAC5C,OAAA,IAAA,GAAA,IAAA;AAAC;AAAY;AAEW;AACkB;;AAC1C,OAAA,IAAA,GAAA,CAAA;AAAC;AAAY;AAEiC;AAE3C;AACI;;AAAP,OAAA,QAAA,GAAA,IAAA;AAAC;AAAY;AAE0B;AACT;AAE9B;;AAAA,OAAA,QAAA,GAAA,IAAA;AAAC;AAAY;AAE2D;AACI;AAEzE;AACI;;AAAP,OAAA,SAAA,GAAA,KAAA;AAAC;AAAY;AAEuB;AACoB;;AACxD,OAAA,QAAA,GAAA,IAAA;AAAC;AAAY;AAE0B;AACoB;;AAC3D,OAAA,QAAA,GAAA,IAAA;AAAC;AAAY;AAE4D;AAC1D;;AACf,OAAA,SAAA,GAAA,IAAA;AAAC;AAAY;AAEoC;AACe;AACZ;AACc;AAC3C;;AACvB,OAAA,aAAA,GAAA,IAAA;AAAC;AAAY;AAEkC;AACO;AACK;AACF;AACY;AACvC;;AAC9B,OAAA,SAAA,GAAA,IAAA;AAAC;AAAY;AAEgC;AACkC;AACvC;AACsD;AAE7F;AACM;AACG;;AAAV,OAAA,UAAA,GAAA,IAAA;AAAC;AAAY;AAEmD;;AAChE,OAAA,sBAAA,GAAA,KAAA;AAAC;AAAY;AAEwD;AACvD;;AACd,OAAA,cAAA,GAAA,KAAA;AAAC;AAAY;AAEoC;AAC3B;;AACtB,OAAA,kBAAA,GAAA,KAAA;AAAC;AAAY;AAEyC;;AACtD,OAAA,gBAAA,GAAA,KAAA;AAAC;AAAY;AAE0C;;AACvD,OAAA,mBAAA,GAAA,KAAA;AAAC;AAAY;AAEkD;AAClB;;AAC7C,OAAA,yBAAA,GAAA,IAAA;AAAC;AAAY;AAE2C;AACqB;;AAC7E,OAAA,sBAAA,GAAA,KAAA;AAAC;AAAY;AAEC;;AACd,OAAA,iBAAA,GAAA,KAAA;AAAC;AAAY;AAEQ;;AACrB,OAAA,eAAA,GAAA,KAAA;AAAC;AAAY;AAE2C;;AACxD,OAAA,mBAAA,GAAA,IAAA;AAAC;AAAY;AAEY;;AACzB,OAAA,QAAA,GAAA,KAAA;AAAC;AAAY;AAEe;;AAC5B,OAAA,QAAA,GAAA,KAAA;AAAC;AAAY;AAEgC;AACgC;;AAC7E,OAAA,mBAAA,GAAA,EAAA;AAAC;AAAY;AAEyB;AACwC;;AAC9E,OAAA,mBAAA,GAAA,EAAA;AAAC;AAAY;AAEuD;AACwB;;AAC5F,OAAA,mBAAA,GAAA,GAAA;AAAC;AAAY;AAEoE;AACH;;AAC9E,OAAA,oBAAA,GAAA,GAAA;AAAC;AAAY;AAE8B;;AAC3C,OAAA,SAAA,GAAA,KAAA;AAAC;AAAY;AAE0D;;AACvE,OAAA,eAAA,GAAA,KAAA;AAAC;AAEgD;;AAEjD,OAAA,QAAA,GAAA,IAAA;AAAC;;AAGD,OAAA,aAAA,GAAA,CAAA;AAAC;AAAY;AAEwB;AAC6B;AACsB;;AACxF,OAAA,UAAA,GAAA,IAAA;AAAC;AAAY;AAE4B;AACyB;;AAClE,OAAA,YAAA,GAAA,IAAA;AAAC;AAAY;AAEE;;AACf,OAAA,kBAAA,GAAA,IAAA;AAAC;AAAY;AAED;AACW;AACc;;AACrC,OAAA,QAAA,GAAA,KAAA;AAAC;AAAY;AAE0C;AACiB;AAEvE;AACO;AACO;AACK;;AAApB,OAAA,oBAAA,GAAA,IAAA;AAAC;AAAY;AAED;;AACZ,OAAA,YAAA,GAAA,IAAA;AAAC;AAAY;AAEa;AACyB;AACS;AACjB;AACuD;AAEjG;AACI;;AAAL,OAAA,eAAA,GAAA,IAAA;AAAC;AAAY;AAEkC;AAAkC;AAC9E;AACA;AACA;AACW;AAEZ;;AAEF,OAAA,eAAA,GAAA,IAAA;AAAC;AAAY;AAEwE;AACf;;AACtE,OAAA,KAAA,GAAA,CAAA;AAAC;AAAY;AAEmF;AAE9F;AACI;;AAAN,OAAA,WAAA,GAAA,IAAA;AAAC;AAAY;AAEiG;AACD;AACwB;;AACrI,OAAA,YAAA,GAAA,IAAA;AAAC;AAAY;AAE8E;;AAC3F,OAAA,WAAA,GAAA,KAAA;AAAC;AAAY;AAE4B;;AACzC,OAAA,eAAA,GAAA,KAAA;AAAC;AAAY;AAEe;AACwD;;AACpF,OAAA,WAAA,GAAA,KAAA;AAAC;AAAY;AAEqB;AAClB;AACS;AAEpB;AACO;AACO;AAEC;;AAApB,OAAA,gBAAA,GAAA,KAAA;AAAC;AAAY;AAEoC;;AACjD,OAAA,kBAAA,GAAA,IAAA;AAAC;AAAY;AAEiC;;AAC9C,OAAA,QAAA,GAAA,KAAA;AAAC;AAAY;AAEgD;AACZ;AACgE;;AACjH,OAAA,qBAAA,GAAA,IAAA;AAAC;AAAY;AAEoB;AACjB;AACqE;;AACrF,OAAA,qBAAA,GAAA,IAAA;AAAC;AAAY;AAET;AAC+C;AACrB;;AAC9B,OAAA,cAAA,GAAA,EAAA;AAAC;AAAY;AAE0B;AAC4B;;AACnE,OAAA,oBAAA,GAAA,IAAA;AAAC;AAAY;AAE0C;;AACvD,OAAA,SAAA,GAAA,IAAA;AAAC;AAAY;AAEgF;AAC1D;;AACnC,OAAA,cAAA,GAAA,IAAA;AAAC;AAAY;AAE0E;;AACvF,OAAA,aAAA,GAAA,IAAA;AAAC;AAAY;AAEsF;AACpE;;AAC/B,OAAA,kBAAA,GAAA,IAAA;AAAC;AAAY;AAE6F;;AAC1G,OAAA,eAAA,GAAA,IAAA;AAAC;AAAY;AAE6F;;AAC1G,OAAA,YAAA,GAAA,IAAA;AAAC;AAAY;AAEQ;;AACrB,OAAA,OAAA,GAAA,IAAA;AAAC,C;AAEA;AAAI;AAAkC;AAAyC;;;IC/ShF,a;;;AAKC;AAAI;AAAkC;AAAyC;;ACPhF;AAAI;AAGa;;;IAEjB,W;;;;;;;;AAAE;AAAQ;AACH;AAAmB;sCAAC,K,EAA3B;AACI,aAAO,KAAK,KAAK,SAAV,IAAuB,KAAK,KAAK,IAAxC;AACD;AACH;AACO;AAAsB;AAAyB;AAAyB;AACnE;;;;0CADmB,G,EAAa,M,EAAgB,M,EAA5D;AACI;AAAA;AAAM,MAAA,KAAK,GAAW,MAAM,GAAG,MAA/B;AACA,aAAO,CAAC,GAAG,GAAG,MAAP,IAAiB,KAAxB;AACD;AACH;AACO;AAAsB;AAAyB;AAAyB;AAChE;;;;uCADa,G,EAAa,M,EAAgB,M,EAAzD;AACI,MAAA,GAAG,GAAG,IAAI,CAAC,GAAL,CAAS,GAAT,CAAN;AACA,MAAA,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,MAAT,CAAT;AACA,MAAA,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,MAAT,CAAT;AACA;AAAA;AAAM,MAAA,KAAK,GAAW,MAAM,GAAG,MAA/B;AACA,aAAO,CAAC,GAAG,GAAG,MAAP,IAAiB,KAAxB;AACD;AACH;AACO;AAA0B;AAAyB;AAAyB;AACvE;;;;0CADmB,O,EAAiB,M,EAAgB,M,EAAhE;AACI,aAAO,OAAO,IAAI,MAAM,GAAG,MAAb,CAAP,GAA8B,MAArC;AACD;AACH;AACO;AAA0B;AAAyB;AAAyB;AACpE;;;;uCADa,O,EAAiB,M,EAAgB,M,EAA7D;AACI,MAAA,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,MAAT,CAAT;AACA,MAAA,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,MAAT,CAAT;AACA;AAAA;AAAM,MAAA,KAAK,GAAW,OAAO,IAAI,MAAM,GAAG,MAAb,CAAP,GAA8B,MAApD;AACA,aAAO,IAAI,CAAC,GAAL,CAAS,KAAT,CAAP;AACD;AACH;AACO;AAA6B;AAA6B;AAAmB;;;;kCAA7D,U,EAAoB,U,EAA3C;AACI;AAAA;AAAM,MAAA,WAAW,GAAa,UAAU,CAAC,GAAX,CAAe,UAAC,IAAD;AAAA,eAAwC,IAAI,CAAC,GAAL,CAAS,UAAU,GAAG,IAAI,CAAC,KAA3B,CAAxC;AAAA,OAAf,CAA9B;AAEA;AAAA;AAAI,MAAA,kBAAkB,GAAW,CAAjC;;AACA,WAAK;AAAA;AAAI,MAAA,KAAK,GAAW,CAAzB,EAA4B,KAAK,GAAG,UAAU,CAAC,MAA/C,EAAuD,KAAK,EAA5D,EAAgE;AAC9D,YAAI,WAAW,CAAC,KAAD,CAAX,KAAuB,WAAW,CAAC,kBAAD,CAAlC,IAA0D,WAAW,CAAC,KAAD,CAAX,GAAqB,WAAW,CAAC,kBAAD,CAA9F,EAAoH;AAClH,UAAA,kBAAkB,GAAG,KAArB;AACD;AACF;;AAED,aAAO,kBAAP;AACD;;;;;AAEF;AAAI;AAAkC;AAAyC;;AAAI;AAAI;AAAqE;;;ICzC7J,mB;;;;;;;;AAAE;AAAQ;AAC2E;AAAwB;AAC7F;iCAAa,K,EAA7B;AACI;AAAI;AAAC,MAAA,MAAD,CAAgB,UAAhB,KAA+B,SAAnC,EAA8C;AAC5C,eAAO,KAAK,YAAY,UAAxB;AACD;;AAED,aAAO,KAAK,CAAC,OAAN,KAAkB,SAAzB;AACJ;AAEC;AAAQ;AACF;AAAmB;;;;gDAA1B;AACI,aAAO;AAAA;AAAC,QAAA,MAAD,CAAgB,cAAhB,KAAmC;AAA1C;AACJ;;;;;AAEC;AAAI;AAAkC;AAAyC;;AAAI;AAAI;AAAsC;;;ICpB9H,U;;;;;;;;AAAE;AAAQ;AACF;AAAiC;AAAmB;0CAC7B,K,EAAe,c,EAA9C;AACI,aAAO,CAAG,KAAK,CAAC,WAAN,CAAkB,cAAlB,CAAV;AACD;AACH;AACO;AAAwB;AAAwB;AACrD;AAAmB;;;;iCADC,K,EAAe,K,EAAe,I,EAApD;AACI,aAAO,IAAI,CAAC,GAAL,CAAS,IAAI,CAAC,GAAL,CAAS,KAAT,EAAgB,KAAhB,CAAT,EAAiC,IAAjC,CAAP;AACD;;;;;AAEF;AAAI;AAAkC;AAAyC;;;ICRhF,a,GAAE,yBAAA;AAAA;;AACF,OAAA,SAAA,GAAA,IAAA;AACA,OAAA,MAAA,GAAA,IAAA;AACA,OAAA,kBAAA,GAAA,IAAA;AACA,OAAA,gBAAA,GAAA,IAAA;AAAC,C;AAEA;AAAI;AAAkC;AAAyC;;ACThF;AAAI;AAEQ;;;IASZ,mB;AAAE;AAAQ;AACR;AAAF,+BAAsB,QAAtB,EAAA;AAAA;;AAAA,SAAA,QAAA,GAAsB,QAAtB;AACG;AACH;AACO;AAAgC;AAA4B;AAA2B;AACvE;AAAmB;;;;;+CADN,a,EAAoB,S,EAAmB,Q,EACrE,gB,EADN;AAAE;AAGE,UAAI,mBAAmB,CAAC,UAApB,KAAmC,IAAvC,EAA6C;AAC3C,eAAO,KAAK,mBAAL,CAAyB,aAAzB,EAAwC,SAAxC,EAAmD,QAAnD,EAA6D,gBAA7D,CAAP;AACD,OALL,CAMA;;;AAEI;AAAA;AAAM,MAAA,QAAQ,GAAkB,IAAI,aAAJ,EAAhC;AACA,MAAA,QAAQ,CAAC,SAAT,GAAqB,SAArB;AACA,MAAA,QAAQ,CAAC,MAAT,GAAkB,IAAI,OAAJ,EAAlB;;AAEA;AAAA;AAAM,MAAA,gBAAgB,GAA2B,SAA3C,gBAA2C,CAAC,KAAD,EAArD;AACM,QAAA,QAAQ,CAAC,MAAT,CAAgB,IAAhB,CAAqB,KAArB;AACD,OAFD;;AAGA,MAAA,aAAa,CAAC,gBAAd,CAA+B,SAA/B,EAA0C,gBAA1C,EAA4D;AAAC,QAAA,OAAO,EAAE,IAAV;AAAgB,QAAA,OAAO,EAAE;AAAzB,OAA5D;;AAEA,MAAA,QAAQ,CAAC,gBAAT,GAA4B,YAAhC;AACM,QAAA,aAAa,CAAC,mBAAd,CAAkC,SAAlC,EAA6C,gBAA7C,EAA+D;AAAC,UAAA,OAAO,EAAE,IAAV;AAAgB,UAAA,OAAO,EAAE;AAAzB,SAA/D;AACD,OAFD;;AAIA,MAAA,QAAQ,CAAC,kBAAT,GAA8B,QAAQ,CAAC,MAAT,CAC3B,IAD2B,CACrB,CAAC,WAAW,CAAC,iBAAZ,CAA8B,gBAA9B,CAAF,GACF,YAAY,CAAC,gBAAD,EAAmB,SAAnB,EAA8B;AAAE,QAAA,OAAO,EAAE,IAAX;AAAiB,QAAA,QAAQ,EAAE;AAA3B,OAA9B,CADV,GAEF,GAAG,CAAC,YAAd,CAAsB,CAAT,CAHqB,CAGX;AAHW,QAK3B,SAL2B,CAKjB,UAAC,KAAD,EAAjB;AACQ,QAAA,QAAQ,CAAC,KAAD,CAAR;AACD,OAP2B,CAA9B;AASA,aAAO,QAAP;AACJ;AAEC;AAAQ;AAAgC;AAAmB;;;;wCAA/B,a,EAA7B;AACI,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,aAAa,CAAC,kBAA5C,CAAL,EAAsE;AACpE,QAAA,aAAa,CAAC,kBAAd,CAAiC,WAAjC;AACA,QAAA,aAAa,CAAC,kBAAd,GAAmC,IAAnC;AACD;;AAED,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,aAAa,CAAC,MAA5C,CAAL,EAA0D;AACxD,QAAA,aAAa,CAAC,MAAd,CAAqB,QAArB;AACA,QAAA,aAAa,CAAC,MAAd,GAAuB,IAAvB;AACD;;AAED,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,aAAa,CAAC,gBAA5C,CAAL,EAAoE;AAClE,QAAA,aAAa,CAAC,gBAAd;AACA,QAAA,aAAa,CAAC,gBAAd,GAAiC,IAAjC;AACD;AACL;AAEC;AAAQ;AAAgC;AAA4B;AAA2B;AAChE;AAC/B;;;;wCAF4B,a,EAAoB,S,EAAmB,Q,EAC9D,gB,EADN;AAEI;AAAA;AAAM,MAAA,QAAQ,GAAkB,IAAI,aAAJ,EAAhC;AACA,MAAA,QAAQ,CAAC,SAAT,GAAqB,SAArB;AACA,MAAA,QAAQ,CAAC,MAAT,GAAkB,IAAI,OAAJ,EAAlB;;AAEA;AAAA;AAAM,MAAA,gBAAgB,GAA2B,SAA3C,gBAA2C,CAAC,KAAD,EAArD;AACM,QAAA,QAAQ,CAAC,MAAT,CAAgB,IAAhB,CAAqB,KAArB;AACD,OAFD;;AAIA,MAAA,QAAQ,CAAC,gBAAT,GAA4B,KAAK,QAAL,CAAc,MAAd,CAAqB,aAArB,EAAoC,SAApC,EAA+C,gBAA/C,CAA5B;AAEA,MAAA,QAAQ,CAAC,kBAAT,GAA8B,QAAQ,CAAC,MAAT,CAC3B,IAD2B,CACrB,CAAC,WAAW,CAAC,iBAAZ,CAA8B,gBAA9B,CAAF,GACA,YAAY,CAAC,gBAAD,EAAmB,SAAnB,EAA8B;AAAE,QAAA,OAAO,EAAE,IAAX;AAAiB,QAAA,QAAQ,EAAE;AAA3B,OAA9B,CADZ,GAEA,GAAG,CAAC,YAAhB,CAAwB,CAAT,CAHmB,CAGT;AAHS,QAK3B,SAL2B,CAKjB,UAAC,KAAD,EAAjB;AAAqC,QAAA,QAAQ,CAAC,KAAD,CAAR;AAAkB,OALrB,CAA9B;AAOA,aAAO,QAAP;AACJ;;;;;AAEC;AAAI;AAAkC;AAAyC;;;IC/EhF,sB;AAAE;AAAQ;AAA0B;AACX;AA8CzB,kCAAwB,OAAxB,EAAuD,QAAvD,EAAA;AAAA;;AAAA,SAAA,OAAA,GAAwB,OAAxB;AAAA,SAAA,QAAA,GAAuD,QAAvD;AA9CA,SAAA,SAAA,GAAA,CAAA;AAKA,SAAA,UAAA,GAAA,CAAA;AAKA,SAAA,WAAA,GAAA,KAAA;AAKA,SAAA,SAAA,GAAA,KAAA;AAKA,SAAA,MAAA,GAAA,CAAA;AAMA,SAAA,OAAA,GAAA,CAAA;AAGA,SAAA,UAAA,GAAA,SAAA;AAGA,SAAA,IAAA,GAAA,EAAA;AAGA,SAAA,MAAA,GAAA,EAAA;AAGA,SAAA,MAAA,GAAA,EAAA;AAGA,SAAA,KAAA,GAAA,EAAA;AAGA,SAAA,cAAA,GAAA,EAAA;AAGI,SAAK,mBAAL,GAA2B,IAAI,mBAAJ,CAAwB,KAAK,QAA7B,CAA3B;AACD;AACH;AACO;AAAmB;;;;;;AA1B1B;AACO;AAAuB;AACb;kCAwBD,I,EAAhB;AACI,WAAK,WAAL,GAAmB,IAAnB;;AACA,UAAI,IAAJ,EAAU;AACR,aAAK,UAAL,GAAkB,QAAlB;AACD,OAFD,MAEO;AACL,aAAK,UAAL,GAAkB,SAAlB;AACD;AACF;AACH;AACO;AACE;;;;2BADT;AACI,WAAK,OAAL,GAAe,CAAf;AACD;AACH;AACO;AACE;;;;2BADT;AACI,UAAI,KAAK,UAAT,EAAqB;AACnB;AACD;;AAED,WAAK,OAAL,GAAe,CAAf;AACD;AACH;AACO;AACN;;;;gCADD;AACI,UAAI,KAAK,UAAT,EAAqB;AACnB,eAAO,KAAP;AACD;;AACD,aAAO,KAAK,OAAL,KAAiB,CAAxB;AACD;AACH;AACO;AAA2B;AACtB;;;;gCADE,Q,EAAd;AACI,WAAK,SAAL,GAAiB,QAAjB;;AACA,UAAI,KAAK,SAAT,EAAoB;AAClB,aAAK,IAAL,GAAY,EAAZ;AACA,aAAK,KAAL,GAAa,EAAb;AACD,OAHD,MAGO;AACL,aAAK,MAAL,GAAc,EAAd;AACA,aAAK,MAAL,GAAc,EAAd;AACD;AACF;AACH;AACO;AAAwB;AACf;;;;6BADL,K,EAAX;AACI,WAAK,MAAL,GAAc,KAAd;AACD;AACH;AACO;AAAsB;AAAmB;;;;gCAClC,G,EAAd;AACI,WAAK,SAAL,GAAiB,GAAjB;;AACA,UAAI,KAAK,SAAT,EAAoB;AAClB,aAAK,MAAL,GAAc,IAAI,CAAC,KAAL,CAAW,GAAX,IAAkB,IAAhC;AACD,OAFD,MAEO;AACL,aAAK,IAAL,GAAY,IAAI,CAAC,KAAL,CAAW,GAAX,IAAkB,IAA9B;AACD;AACF;AACH;AACO;AAAmB;;;;yCAC1B;AACI;AAAA;AAAM,MAAA,GAAG,GAAe,KAAK,qBAAL,EAAxB;;AACA,UAAI,KAAK,QAAT,EAAmB;AACjB,aAAK,UAAL,GAAkB,CAAC,GAAG,CAAC,MAAJ,GAAa,GAAG,CAAC,GAAlB,IAAyB,KAAK,KAAhD;AACD,OAFD,MAEO;AACL,aAAK,UAAL,GAAkB,CAAC,GAAG,CAAC,KAAJ,GAAY,GAAG,CAAC,IAAjB,IAAyB,KAAK,KAAhD;AACD;AACF;AACH;AACO;AAAsB;AAAmB;;;;iCACjC,G,EAAf;AACI,WAAK,UAAL,GAAkB,GAAlB;;AACA,UAAI,KAAK,SAAT,EAAoB;AAClB,aAAK,MAAL,GAAc,IAAI,CAAC,KAAL,CAAW,GAAX,IAAkB,IAAhC;AACD,OAFD,MAEO;AACL,aAAK,KAAL,GAAa,IAAI,CAAC,KAAL,CAAW,GAAX,IAAkB,IAA/B;AACD;AACF;AACH;AACO;AAAmB;;;;4CAA1B;AACI,aAAO,KAAK,OAAL,CAAa,aAAb,CAA2B,qBAA3B,EAAP;AACD;AACH;AACO;AAA4B;AAA2B;AACvD;AAAmB;;;;uBADrB,S,EAAmB,Q,EAAgC,gB,EAAxD;AACI;AAAA;AAAM,MAAA,QAAQ,GAAkB,KAAK,mBAAL,CAAyB,mBAAzB,CAC9B,KAAK,OAAL,CAAa,aADiB,EACF,SADE,EACS,QADT,EACmB,gBADnB,CAAhC;AAEA,WAAK,cAAL,CAAoB,IAApB,CAAyB,QAAzB;AACD;AACH;AACO;AAA4B;AAA2B;AAC9D;AAAmB;;;;8BADP,S,EAAmB,Q,EAAgC,gB,EAA/D;AACI;AAAA;AAAM,MAAA,QAAQ,GAAkB,KAAK,mBAAL,CAAyB,0BAAzB,CAC9B,KAAK,OAAL,CAAa,aADiB,EACF,SADE,EACS,QADT,EACmB,gBADnB,CAAhC;AAEA,WAAK,cAAL,CAAoB,IAApB,CAAyB,QAAzB;AACD;AACH;AACO;AACL;AAAmB;;;;wBADf,S,EAAN;AACI;AAAA;AAAI,MAAA,eAAJ;AACA;AAAA;AAAI,MAAA,iBAAJ;;AACA,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,SAA9B,CAAL,EAA+C;AAC7C,QAAA,eAAe,GAAG,KAAK,cAAL,CAAoB,MAApB,CAA2B,UAAC,KAAD;AAAA,iBAA0B,KAAK,CAAC,SAAN,KAAoB,SAA9C;AAAA,SAA3B,CAAlB;AACA,QAAA,iBAAiB,GAAG,KAAK,cAAL,CAAoB,MAApB,CAA2B,UAAC,KAAD;AAAA,iBAA0B,KAAK,CAAC,SAAN,KAAoB,SAA9C;AAAA,SAA3B,CAApB;AACD,OAHD,MAGO;AACL,QAAA,eAAe,GAAG,EAAlB;AACA,QAAA,iBAAiB,GAAG,KAAK,cAAzB;AACD;;AATL,iDAW2B,iBAX3B;AAAA;;AAAA;AAWI,4DAA0C;AAAA,cAA/B,QAA+B;AACxC,eAAK,mBAAL,CAAyB,mBAAzB,CAA6C,QAA7C;AACD;AAbL;AAAA;AAAA;AAAA;AAAA;;AAeI,WAAK,cAAL,GAAsB,eAAtB;AACD;;;wBA1JH;AACI,aAAO,KAAK,SAAZ;AACD;AACH;AACO;AAAmB;;;;wBAC1B;AACI,aAAO,KAAK,UAAZ;AACD;AACH;AACO;AAAmB;;;;wBAC1B;AACI,aAAO,KAAK,WAAZ;AACD;AACH;AACO;AAAmB;;;;wBAC1B;AACI,aAAO,KAAK,SAAZ;AACD;AACH;AACO;AAAmB;;;;wBAC1B;AACI,aAAO,KAAK,MAAZ;AACD;;;;;;uCA3BH,8B,CAAW,C,EAAA;AAAA,SAAA,KACT,CAAA,IAAA,sBADS,EACqB,MAAA,CAAA,iBAAA,CAChC,MAAA,CAAA,UADgC,CADrB,EAEX,MAAA,CAAA,iBAAA,CAAA,MAAA,CAAA,SAAA,CAFW,CAAA;AAEX,C;;;;;;;;;;AACC;;AAAC;;AAAmB,sBAAA,CAAA,cAAA,GAAA;AAAA,SAAA,CARrB;AAAA,IAAA,IAAA,EAAA;AAAA,GAQqB,EARrB;AAAA,IAAA,IAAA,EAAA;AAAA,GAQqB,CAAA;AAAA,CAAA;;AARhB,sBAAA,CAAA,cAAA,GAAA;AAkCL,aAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,eAAA;AAAA,GAAA,CAlCK;AAqCL,gBAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,kBAAA;AAAA,GAAA,CArCK;AAwCL,UAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,YAAA;AAAA,GAAA,CAxCK;AA2CL,YAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,cAAA;AAAA,GAAA,CA3CK;AA8CL,YAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,cAAA;AAAA,GAAA,CA9CK;AAiDL,WAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,aAAA;AAAA,GAAA;AAjDK,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDD,C;AAAE;AAAI;AACI;AAEkB;;;IC9ChC,qB;;;;;AAAE;AAAQ;AAA0B;AAA2B;AAmC/D,iCAAc,OAAd,EAAmC,QAAnC,EAAA;AAAA;;AAAA;;AACI,8BAAM,OAAN,EAAe,QAAf;AAlCJ,UAAA,MAAA,GAAA,KAAA;AAGA,UAAA,IAAA,GAAA,EAAA;AAGA,UAAA,QAAA,GAAA,EAAA;AAGA,UAAA,eAAA,GAAA,EAAA;AAGA,UAAA,SAAA,GAAA,EAAA;AAGA,UAAA,cAAA,GAAA,EAAA;AAGA,UAAA,YAAA,GAAA,EAAA;AAGA,UAAA,aAAA,GAAA,EAAA;AAGA,UAAA,YAAA,GAAA,EAAA;AAGA,UAAA,YAAA,GAAA,EAAA;AAMA;AAEG;AACH;AACM;AAAmB;;;;;4BARzB;AACI,WAAK,OAAL,CAAa,aAAb,CAA2B,KAA3B;AACD;;;;EAjCH,sB;;sCAHA,6B,CAAW,C,EAAA;AAAA,SAAA,KACT,CAAA,IAAA,qBADS,EACC,MAAmB,CAAA,iBAAnB,CACZ,MAAA,CAAA,UADY,CADD,EAEX,MAAA,CAAA,iBAAA,CAAA,MAAA,CAAA,SAAA,CAFW,CAAA;AAEX,C;;;;;;;;;;;;oBACC,0B;;AAAC;;AAAmB,qBAAA,CAAA,cAAA,GAAA;AAAA,SAAA,CANrB;AAAA,IAAA,IAAA,EAAA;AAAA,GAMqB,EANrB;AAAA,IAAA,IAAA,EAAA;AAAA,GAMqB,CAAA;AAAA,CAAA;;AANhB,qBAAA,CAAA,cAAA,GAAA;AAOL,YAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,yBAAA;AAAA,GAAA,CAPK;AAUL,UAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,WAAA;AAAA,GAAA,CAVK;AAaL,cAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,eAAA;AAAA,GAAA,CAbK;AAgBL,qBAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,uBAAA;AAAA,GAAA,CAhBK;AAmBL,eAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,iBAAA;AAAA,GAAA,CAnBK;AAsBL,oBAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,sBAAA;AAAA,GAAA,CAtBK;AAyBL,kBAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,oBAAA;AAAA,GAAA,CAzBK;AA4BL,mBAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,qBAAA;AAAA,GAAA,CA5BK;AA+BL,kBAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,oBAAA;AAAA,GAAA,CA/BK;AAkCL,kBAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,oBAAA;AAAA,GAAA;AAlCK,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCD,C;AAAE;AAAI;AACH;AAGP;;;IC/BA,oB;;;;;AAAE;AAAQ;AAA0B;AAA2B;AAM/D,gCAAc,OAAd,EAAmC,QAAnC,EAAA;AAAA;;AAAA;;AACI,gCAAM,OAAN,EAAe,QAAf;AANJ,WAAA,MAAA,GAAA,IAAA;AAKA;AAEG;AACH;AACO;AAAmB;;;;;;AAL1B;AACO;AAAwB;AAAmB;6BAIvC,K,EAAX;AACI;AAAA;AAAI,MAAA,oBAAoB,GAAY,KAApC;;AAEA,UAAI,CAAC,KAAK,UAAN,KACC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,KAAnC,KACA,KAAK,KAAL,CAAW,MAAX,KAAsB,KAAK,CAAC,MAD5B,IAEC,KAAK,KAAL,CAAW,MAAX,GAAoB,CAApB,IAAyB,KAAK,SAAL,KAAmB,CAH9C,CAAJ,EAGuD;AACrD,QAAA,oBAAoB,GAAG,IAAvB;AACD;;AAED,WAAK,MAAL,GAAc,KAAd;AACA,WAAK,OAAL,CAAa,aAAb,CAA2B,SAA3B,GAAuC,KAAvC,CAXJ,CAYA;;AAEI,UAAI,oBAAJ,EAA0B;AACxB,aAAK,kBAAL;AACD;AACF;;;wBAzBH;AACI,aAAO,KAAK,MAAZ;AACD;;;;EAJH,sB;;qCAHA,4B,CAAW,C,EAAA;AAAA,SAAA,KAAA,CACT,IAAA,oBADS,EACC,MAAkB,CAAA,iBAAlB,CACZ,MAAA,CAAA,UADY,CADD,EAEX,MAAA,CAAA,iBAAA,CAAA,MAAA,CAAA,SAAA,CAFW,CAAA;AAEX,C;;;;;oBACC,0B;;AAAC;;AAAmB,oBAAA,CAAA,cAAA,GAAA;AAAA,SAAA,CAPrB;AAAA,IAAA,IAAA,EAAA;AAAA,GAOqB,EAPrB;AAAA,IAAA,IAAA,EAAA;AAAA,GAOqB,CAAA;AAAA,CAAA;;;;;;;;;;;;;;;AAPjB,C;AAAE;AAAI;AAAkC;AACzB;;;ICwDnB,I,GAAE,gBAAA;AAAA;;AACF,OAAA,QAAA,GAAA,KAAA;AACA,OAAA,KAAA,GAAA,EAAA;AACA,OAAA,OAAA,GAAA,IAAA;AACA,OAAA,gBAAA,GAAA,IAAA;AACA,OAAA,KAAA,GAAA,IAAA;AACA,OAAA,YAAA,GAAA,IAAA;AACA,OAAA,qBAAA,GAAA,IAAA;AACA,OAAA,MAAA,GAAA,IAAA;AAAC,C;;IAGD,Q,GAAE,oBAAA;AAAA;;AACF,OAAA,MAAA,GAAA,KAAA;AACA,OAAA,KAAA,GAAA,CAAA;AACA,OAAA,UAAA,GAAA,CAAA;AACA,OAAA,QAAA,GAAA,CAAA;AACA,OAAA,QAAA,GAAA,CAAA;AACA,OAAA,SAAA,GAAA,CAAA;AAAC,C;;IAGD,W;;;;;;;;AAAE;AAAQ;AACC;AACI;AAEH;4BAAY,C,EAAiB,C,EAAzC;AACI,UAAI,WAAW,CAAC,iBAAZ,CAA8B,CAA9B,KAAoC,WAAW,CAAC,iBAAZ,CAA8B,CAA9B,CAAxC,EAA0E;AACxE,eAAO,KAAP;AACD;;AACD,UAAI,WAAW,CAAC,iBAAZ,CAA8B,CAA9B,MAAqC,WAAW,CAAC,iBAAZ,CAA8B,CAA9B,CAAzC,EAA2E;AACzE,eAAO,KAAP;AACD;;AACD,aAAO,CAAC,CAAC,KAAF,KAAY,CAAC,CAAC,KAAd,IAAuB,CAAC,CAAC,SAAF,KAAgB,CAAC,CAAC,SAAhD;AACJ;;;;;;IAGA,W;;;;;;;;;;;;;;AAAE;AAAQ;AAAqB;AACnB;AAAmB;4BAIP,C,EAAiB,C,EAAzC;AACI,UAAI,WAAW,CAAC,iBAAZ,CAA8B,CAA9B,KAAoC,WAAW,CAAC,iBAAZ,CAA8B,CAA9B,CAAxC,EAA0E;AACxE,eAAO,KAAP;AACD;;AACD,UAAI,WAAW,CAAC,iBAAZ,CAA8B,CAA9B,MAAqC,WAAW,CAAC,iBAAZ,CAA8B,CAA9B,CAAzC,EAA2E;AACzE,eAAO,KAAP;AACD;;AACD,aAAO,CAAC,CAAC,KAAF,KAAY,CAAC,CAAC,KAAd,IACA,CAAC,CAAC,SAAF,KAAgB,CAAC,CAAC,SADlB,IAEA,CAAC,CAAC,WAAF,KAAkB,CAAC,CAAC,WAF3B;AAGJ;;;;EAfA,W;;AA0BA,IAAM,iCAAiC,GAAQ;AAC7C,EAAA,OAAO,EAAE,iBADoC;;AAE/C;AACE,EAAA,WAAW,EAAE,UAAU,CAAC;AAAA,WAAM,eAAN;AAAA,GAAD,CAHsB;AAI7C,EAAA,KAAK,EAAE;AAJsC,CAA/C;;IAqDA,e;AAAE;AAAQ;AAA2B;AAA6B;AAAqC;AACrF;AA0LlB,2BAA6B,QAA7B,EAAA,UAAA,EAAA,kBAAA,EAAA,IAAA,EAAA;AAAA;;AAAA,SAAA,QAAA,GAA6B,QAA7B;AACA,SAAA,UAAA,GAAA,UAAA;AACA,SAAA,kBAAA,GAAA,kBAAA;AACA,SAAA,IAAA,GAAA,IAAA,CAHA,CAGC;;AA3LD,SAAA,KAAA,GAAA,IAAA,CAwLA,CAxLC;;AAGD,SAAA,WAAA,GAA6C,IAA7C,YAA6C,EAA7C,CAqLA,CArLC;;AAID,SAAA,SAAA,GAAA,IAAA,CAiLA,CAjLC;;AAGD,SAAA,eAAA,GAAiD,IAAjD,YAAiD,EAAjD,CA8KA,CA9KC;AAA+D;;AAKhE,SAAA,OAAA,GAA4B,IAA5B,OAA4B,EAA5B,CAyKA,CAzKC;;AAID,SAAA,eAAA,GAAwD,IAAxD,YAAwD,EAAxD,CAqKA,CArKC;;AAID,SAAA,UAAA,GAAmD,IAAnD,YAAmD,EAAnD,CAiKA,CAjKC;;AAID,SAAA,aAAA,GAAsD,IAAtD,YAAsD,EAAtD;AA4BA,SAAA,UAAA,GAAA,KAAA;AAIA,SAAA,uBAAA,GAA+D,IAA/D,OAA+D,EAA/D;AACA,SAAA,4BAAA,GAAA,IAAA;AAIA,SAAA,wBAAA,GAAiE,IAAjE,OAAiE,EAAjE;AACA,SAAA,6BAAA,GAAA,IAAA;AAGA,SAAA,YAAA,GAAA,IAAA;AAEA,SAAA,aAAA,GAAA,IAAA;AAEA,SAAA,WAAA,GAAiC,IAAjC,OAAiC,EAAjC;AAGA,SAAA,mBAAA,GAAA,CAAA;AAEA,SAAA,iBAAA,GAAA,CAAA;AAGA,SAAA,sBAAA,GAAA,IAAA;AAEA,SAAA,mBAAA,GAAA,IAAA;AAEA,SAAA,YAAA,GAAA,KAAA;AAEA,SAAA,OAAA,GAAA,IAAA;AAEA,SAAA,QAAA,GAA+B,IAA/B,QAA+B,EAA/B,CAgGA,CAhGC;;AA0DD,SAAA,0BAAA,GAAA,KAAA;AAEA,SAAA,yBAAA,GAAA,KAAA;AAEA,SAAA,yBAAA,GAAA,IAAA;AAGA,SAAA,QAAA,GAAA,EAAA;AACA,SAAA,eAAA,GAAA,EAAA;AACA,SAAA,eAAA,GAAA,EAAA;AACA,SAAA,uBAAA,GAAA,KAAA;AACA,SAAA,0BAAA,GAAA,KAAA;AACA,SAAA,qBAAA,GAAA,KAAA;AASA,SAAA,iBAAA,GAAA,KAAA;AAEA,SAAA,KAAA,GAAA,EAAA;AAGA,SAAA,mBAAA,GAAA,IAAA;AACA,SAAA,mBAAA,GAAA,IAAA;AACA,SAAA,kBAAA,GAAA,IAAA;AAGA,SAAA,cAAA,GAAA,IAAA;AAGA,SAAA,iBAAA,GAAA,IAAA;AACA,SAAA,gBAAA,GAAA,IAAA;AAOI,SAAK,mBAAL,GAA2B,IAAI,mBAAJ,CAAwB,KAAK,QAA7B,CAA3B;AACJ;AAEC;AAAQ;AACU;AACT;;;;;;AA5BT;AAAQ;AAAmB;+BA2B5B;AACI,WAAK,WAAL,GAAmB,IAAI,OAAJ,EAAnB;AACA,MAAA,MAAM,CAAC,MAAP,CAAc,KAAK,WAAnB,EAAgC,KAAK,OAArC,EAFJ,CAGA;AAEG;AACI;;AACH,WAAK,mBAAL;AACA,WAAK,mBAAL;AACJ;AAEC;AAAQ;AAAmB;;;;sCAC5B;AACI,WAAK,YAAL;AAEA,WAAK,gCAAL,CAAsC,KAAK,WAAL,CAAiB,mBAAvD;AACA,WAAK,iCAAL,CAAuC,KAAK,WAAL,CAAiB,oBAAxD,EAJJ,CAKA;;AAEI,WAAK,sBAAL;AAEA,WAAK,YAAL,GAAoB,KAAK,qBAAL,CAA2B,KAAK,KAAhC,CAApB;;AACA,UAAI,KAAK,KAAT,EAAgB;AACd,aAAK,aAAL,GAAqB,KAAK,qBAAL,CAA2B,KAAK,SAAhC,CAArB;AACD,OAFD,MAEO;AACL,aAAK,aAAL,GAAqB,IAArB;AACD;;AAED,WAAK,mBAAL,GAhBJ,CAgB+B;;AAC3B,WAAK,mBAAL;AACA,WAAK,mBAAL;AACA,WAAK,uBAAL;AACA,WAAK,gBAAL;AACA,WAAK,eAAL;AACA,WAAK,gBAAL;AACA,WAAK,WAAL;AACA,WAAK,oBAAL;AAEA,WAAK,uBAAL;AAEA,WAAK,UAAL,GAAkB,IAAlB,CA5BJ,CA6BA;;AAEI,WAAK,kBAAL,CAAwB,aAAxB;AACJ;AAEC;AAAQ;AACC;AAAmB;;;;gCAAR,O,EAArB;AAAE;AAEE,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,OAAO,CAA9C,SAA8C,CAArC,CAAL,EAAqD;AACnD,aAAK,eAAL;AACD,OAJL,CAKA;;;AAEI,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,OAAO,CAA9C,OAA8C,CAArC,CAAD,IACA,CAAC,WAAW,CAAC,iBAAZ,CAA8B,OAAO,CAA9C,WAA8C,CAArC,CADL,EACuD;AACrD,aAAK,uBAAL,CAA6B,IAA7B,CAAkC;AAChC,UAAA,KAAK,EAAE,KAAK,KADoB;AAEhC,UAAA,SAAS,EAAE,KAAK,SAFgB;AAGhC,UAAA,WAAW,EAAE,KAHmB;AAIhC,UAAA,cAAc,EAAE;AAJgB,SAAlC;AAMD;AACL;AAEC;AAAQ;AACN;;;;kCAAH;AACI,WAAK,YAAL;AAEA,WAAK,yBAAL;AACA,WAAK,kCAAL;AACA,WAAK,mCAAL;AACA,WAAK,wBAAL;AACA,WAAK,uBAAL;AACJ;AAEC;AAAQ;AAAsB;AACjB;;;;+BAAM,G,EAApB;AACI,UAAI,GAAG,YAAY,KAAnB,EAA0B;AACxB,aAAK,KAAL,GAAa,GAAG,CAAC,CAAD,CAAhB;AACA,aAAK,SAAL,GAAiB,GAAG,CAAC,CAAD,CAApB;AACD,OAHD,MAGO;AACL,aAAK,KAAL,GAAa,GAAb;AACD,OANL,CAOA;;;AAEI,WAAK,uBAAL,CAA6B,IAA7B,CAAkC;AAChC,QAAA,KAAK,EAAE,KAAK,KADoB;AAEhC,QAAA,SAAS,EAAE,KAAK,SAFgB;AAGhC,QAAA,WAAW,EAAE,KAHmB;AAIhC,QAAA,cAAc,EAAE;AAJgB,OAAlC;AAMJ;AAEC;AAAQ;AACD;AAAmB;;;;qCAAD,gB,EAA1B;AACI,WAAK,gBAAL,GAAwB,gBAAxB;AACJ;AAEC;AAAQ;AACA;AAAmB;;;;sCAAD,iB,EAA3B;AACI,WAAK,iBAAL,GAAyB,iBAAzB;AACJ;AAEC;AAAQ;AACP;AAAmB;;;;qCAAK,U,EAA1B;AACI,WAAK,WAAL,CAAiB,QAAjB,GAA4B,UAA5B;AACA,WAAK,mBAAL;AACJ;AAEC;AAAQ;AAAwB;AAC1B;;;;6BAAW,K,EAAlB;AACI,WAAK,uCAAL;AACJ;AAEC;AAAQ;AAA4B;AAAmB;;;;qDAAb,Q,EAA3C;AAAA;;AACI,WAAK,4BAAL,GAAoC,KAAK,uBAAL,CACnC,IADmC,CAElC,oBAAoB,CAAC,WAAW,CAAC,OAAb,CAFc,EAGxC;AACE;AACI,MAAA,MAAM,CAAC,UAAC,WAAD;AAAA,eAAmC,CAAC,WAAW,CAAC,WAAb,IAA4B,CAAC,WAAW,CAAC,cAA5E;AAAA,OAAD,CAL4B,EAMjC,CAAC,WAAW,CAAC,iBAAZ,CAA8B,QAA9B,CAAF,GACM,YAAY,CAAC,QAAD,EAAW,SAAX,EAAsB;AAAE,QAAA,OAAO,EAAE,IAAX;AAAiB,QAAA,QAAQ,EAAE;AAA3B,OAAtB,CADlB,GAEM,GAAG,CAAC,YAAhB,CAAwB,CAAT,CARyB,CAQf;AARe,QAUnC,SAVmC,CAUzB,UAAC,WAAD;AAAA,eAAmC,MAAI,CAAC,qBAAL,CAA2B,WAA3B,CAAnC;AAAA,OAVyB,CAApC;AAWJ;AAEC;AAAQ;AAA4B;AAAmB;;;;sDAAZ,Q,EAA5C;AAAA;;AACI,WAAK,6BAAL,GAAqC,KAAK,wBAAL,CAClC,IADkC,CAEjC,oBAAoB,CAAC,WAAW,CAAC,OAAb,CAFa,EAGhC,CAAC,WAAW,CAAC,iBAAZ,CAA8B,QAA9B,CAAF,GACI,YAAY,CAAC,QAAD,EAAW,SAAX,EAAsB;AAAE,QAAA,OAAO,EAAE,IAAX;AAAiB,QAAA,QAAQ,EAAE;AAA3B,OAAtB,CADhB,GAEI,GAAG,CAAC,YAAhB,CAAwB,CAAT,CAL0B,CAKhB;AALgB,QAOlC,SAPkC,CAOxB,UAAC,WAAD;AAAA,eAAoC,MAAI,CAAC,wBAAL,CAA8B,WAA9B,CAApC;AAAA,OAPwB,CAArC;AAQJ;AAEC;AAAQ;AAAmB;;;;8CAA5B;AAAA;;AACI,UAAI,mBAAmB,CAAC,yBAApB,EAAJ,EAAqD;AACnD,aAAK,cAAL,GAAsB,IAAI,cAAJ,CAAmB;AAAA,iBAAY,MAAI,CAAC,uCAAL,EAAZ;AAAA,SAAnB,CAAtB;AACA,aAAK,cAAL,CAAoB,OAApB,CAA4B,KAAK,UAAL,CAAgB,aAA5C;AACD;AACL;AAEC;AAAQ;AAAmB;;;;gDAA5B;AACI,UAAI,mBAAmB,CAAC,yBAApB,MAAmD,KAAK,cAAL,KAAwB,IAA/E,EAAqF;AACnF,aAAK,cAAL,CAAoB,UAApB;AACA,aAAK,cAAL,GAAsB,IAAtB;AACD;AACL;AAEC;AAAQ;AAAmB;;;;wCAA5B;AACI,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,mBAAnC,CAAL,EAA8D;AAC5D,aAAK,mBAAL,CAAyB,mBAAzB,CAA6C,KAAK,mBAAlD;AACA,aAAK,mBAAL,GAA2B,IAA3B;AACD;AACL;AAEC;AAAQ;AAAmB;;;;uCAA5B;AACI,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,kBAAnC,CAAL,EAA6D;AAC3D,aAAK,mBAAL,CAAyB,mBAAzB,CAA6C,KAAK,kBAAlD;AACA,aAAK,kBAAL,GAA0B,IAA1B;AACD;AACL;AAEC;AAAQ;AAAmB;;;;yDAA5B;AACI,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,4BAAnC,CAAL,EAAuE;AACrE,aAAK,4BAAL,CAAkC,WAAlC;AACA,aAAK,4BAAL,GAAoC,IAApC;AACD;AACL;AAEC;AAAQ;AAAmB;;;;0DAA5B;AACI,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,6BAAnC,CAAL,EAAwE;AACtE,aAAK,6BAAL,CAAmC,WAAnC;AACA,aAAK,6BAAL,GAAqC,IAArC;AACD;AACL;AAEC;AAAQ;AAAmB;;;;+CAA5B;AACI,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,yBAAnC,CAAL,EAAoE;AAClE,aAAK,yBAAL,CAA+B,WAA/B;AACA,aAAK,yBAAL,GAAiC,IAAjC;AACD;AACL;AAEC;AAAQ;AAAmB;;;;8CAA5B;AACI,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,wBAAnC,CAAL,EAAmE;AACjE,aAAK,wBAAL,CAA8B,WAA9B;AACA,aAAK,wBAAL,GAAgC,IAAhC;AACD;AACL;AAEC;AAAQ;AAA8B;AAAmB;;;;sCAA9B,W,EAA5B;AACI,UAAI,WAAW,KAAK,WAAW,CAAC,GAAhC,EAAqC;AACnC,eAAO,KAAK,gBAAZ;AACD,OAFD,MAEO,IAAI,WAAW,KAAK,WAAW,CAAC,GAAhC,EAAqC;AAC1C,eAAO,KAAK,gBAAZ;AACD;;AACD,aAAO,IAAP;AACJ;AAEC;AAAQ;AAAmB;;;;8CAA5B;AACI,UAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAAhD,EAAqD;AACnD,eAAO,KAAK,YAAZ;AACD,OAFD,MAEO,IAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAAhD,EAAqD;AAC1D,eAAO,KAAK,aAAZ;AACD;;AACD,aAAO,IAAP;AACJ;AAEC;AAAQ;AAA6B;AAAmB;;;;0CAAzB,U,EAAhC;AACI,UAAI,WAAW,CAAC,iBAAZ,CAA8B,UAA9B,CAAJ,EAA+C;AAC7C,eAAO,GAAP;AACD;;AAED,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,UAA/C,CAAD,IAA+D,CAAC,KAAK,WAAL,CAAiB,sBAArF,EAA6G;AAC3G,eAAO,WAAW,CAAC,aAAZ,CAA0B,CAAC,UAA3B,EAAuC,KAAK,WAAL,CAAiB,UAAxD,CAAP;AACD;;AACD,aAAO,CAAC,UAAR;AACJ;AAEC;AAAQ;AAA4B;AAAmB;;;;0CAAxB,S,EAAhC;AACI,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,UAA/C,CAAD,IAA+D,CAAC,KAAK,WAAL,CAAiB,sBAArF,EAA6G;AAC3G,eAAO,KAAK,YAAL,CAAkB,SAAlB,CAAP;AACD;;AACD,aAAO,SAAP;AACJ;AAEC;AAAQ;AAA8B;AACnC;;;;iCADmB,W,EAAvB;AACI;AAAA;AAAM,MAAA,IAAI,GAAyB,KAAK,WAAL,CAAiB,UAAjB,CAA4B,WAA5B,CAAnC;AACA,aAAQ,CAAC,WAAW,CAAC,iBAAZ,CAA8B,IAA9B,CAAF,GAAyC,IAAI,CAAC,KAA9C,GAAsD,GAA7D;AACJ;AAEC;AAAQ;AAAmB;;;;sCAA5B;AACI,WAAK,KAAL,GAAa,KAAK,qBAAL,CAA2B,KAAK,YAAhC,CAAb;;AACA,UAAI,KAAK,KAAT,EAAgB;AACd,aAAK,SAAL,GAAiB,KAAK,qBAAL,CAA2B,KAAK,aAAhC,CAAjB;AACD;;AAED,WAAK,wBAAL,CAA8B,IAA9B,CAAmC;AACjC,QAAA,KAAK,EAAE,KAAK,KADqB;AAEjC,QAAA,SAAS,EAAE,KAAK,SAFiB;AAGjC,QAAA,kBAAkB,EAAE,IAHa;AAIjC,QAAA,WAAW,EAAE;AAJoB,OAAnC,EANJ,CAYA;AAEG;AACI;AACI;;AACP,WAAK,uBAAL,CAA6B,IAA7B,CAAkC;AAChC,QAAA,KAAK,EAAE,KAAK,KADoB;AAEhC,QAAA,SAAS,EAAE,KAAK,SAFgB;AAGhC,QAAA,WAAW,EAAE,KAHmB;AAIhC,QAAA,cAAc,EAAE;AAJgB,OAAlC;AAMJ;AAEC;AAAQ;AAA8B;AACxB;;;;0CAAiB,W,EAAhC;AACI;AAAA;AAAM,MAAA,qBAAqB,GAAgB,KAAK,oBAAL,CAA0B,WAA1B,CAA3C,CADJ,CAEA;;AAEI;AAAA;AAAM,MAAA,mBAAmB,GAAY,CAAC,WAAW,CAAC,OAAZ,CAAoB,WAApB,EAAiC,qBAAjC,CAAtC;;AACA,UAAI,mBAAJ,EAAyB;AACvB,aAAK,KAAL,GAAa,qBAAqB,CAAC,KAAnC;AACA,aAAK,SAAL,GAAiB,qBAAqB,CAAC,SAAvC;AACD;;AAED,WAAK,YAAL,GAAoB,KAAK,qBAAL,CAA2B,qBAAqB,CAAC,KAAjD,CAApB;;AACA,UAAI,KAAK,KAAT,EAAgB;AACd,aAAK,aAAL,GAAqB,KAAK,qBAAL,CAA2B,qBAAqB,CAAC,SAAjD,CAArB;AACD,OAFD,MAEO;AACL,aAAK,aAAL,GAAqB,IAArB;AACD;;AAED,WAAK,eAAL,CAAqB,KAAK,eAAL,CAAqB,KAAK,YAA1B,CAArB;;AACA,UAAI,KAAK,KAAT,EAAgB;AACd,aAAK,gBAAL,CAAsB,KAAK,eAAL,CAAqB,KAAK,aAA1B,CAAtB;AACD;;AACD,WAAK,kBAAL;AACA,WAAK,gBAAL;AACA,WAAK,oBAAL;;AACA,UAAI,KAAK,KAAT,EAAgB;AACd,aAAK,mBAAL;AACD,OA1BL,CA2BA;AAEG;;;AACC,WAAK,wBAAL,CAA8B,IAA9B,CAAmC;AACjC,QAAA,KAAK,EAAE,qBAAqB,CAAC,KADI;AAEjC,QAAA,SAAS,EAAE,qBAAqB,CAAC,SAFA;AAGjC,QAAA,WAAW,EAAE,mBAHoB;AAIjC,QAAA,kBAAkB,EAAE;AAJa,OAAnC;AAMJ;AAEC;AAAQ;AAA8B;AAAmB;;;;6CACvB,W,EAAnC;AAAA;;AACI;AAAA;AAAM,MAAA,WAAW,GAAe,SAA1B,WAA0B,GAApC;AACM,QAAA,MAAI,CAAC,WAAL,CAAiB,IAAjB,CAAsB,WAAW,CAAC,KAAlC;;AACA,YAAI,MAAI,CAAC,KAAT,EAAgB;AACd,UAAA,MAAI,CAAC,eAAL,CAAqB,IAArB,CAA0B,WAAW,CAAC,SAAtC;AACD;;AAED,YAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,MAAI,CAAC,gBAAnC,CAAL,EAA2D;AACzD,cAAI,MAAI,CAAC,KAAT,EAAgB;AACd,YAAA,MAAI,CAAC,gBAAL,CAAsB,CAAC,WAAW,CAAC,KAAb,EAAoB,WAAW,CAAC,SAAhC,CAAtB;AACD,WAFD,MAEO;AACL,YAAA,MAAI,CAAC,gBAAL,CAAsB,WAAW,CAAC,KAAlC;AACD;AACF;;AACD,YAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,MAAI,CAAC,iBAAnC,CAAL,EAA4D;AAC1D,cAAI,MAAI,CAAC,KAAT,EAAgB;AACd,YAAA,MAAI,CAAC,iBAAL,CAAuB,CAAC,WAAW,CAAC,KAAb,EAAoB,WAAW,CAAC,SAAhC,CAAvB;AACD,WAFD,MAEO;AACL,YAAA,MAAI,CAAC,iBAAL,CAAuB,WAAW,CAAC,KAAnC;AACD;AACF;AACF,OApBD;;AAsBA,UAAI,WAAW,CAAC,kBAAhB,EAAoC;AACxC;AACM,QAAA,WAAW;AACX,aAAK,UAAL,CAAgB,IAAhB,CAAqB,KAAK,gBAAL,EAArB;AACD,OAJD,MAIO;AACX;AACM;AACA,QAAA,UAAU,CAAC,YAAjB;AAAyB,UAAA,WAAW;AAAK,SAAzB,CAAV;AACD;AACL;AAEC;AAAQ;AAAwB;AAAmB;;;;yCAArB,K,EAA/B;AACI;AAAA;AAAM,MAAA,eAAe,GAAgB,IAAI,WAAJ,EAArC;AACA,MAAA,eAAe,CAAC,KAAhB,GAAwB,KAAK,CAAC,KAA9B;AACA,MAAA,eAAe,CAAC,SAAhB,GAA4B,KAAK,CAAC,SAAlC;;AAEA,UAAI,KAAK,WAAL,CAAiB,WAArB,EAAkC;AAChC,QAAA,eAAe,CAAC,KAAhB,GAAwB,KAAK,SAAL,CAAe,eAAe,CAAC,KAA/B,CAAxB;;AACA,YAAI,KAAK,KAAT,EAAgB;AACd,UAAA,eAAe,CAAC,SAAhB,GAA4B,KAAK,SAAL,CAAe,eAAe,CAAC,SAA/B,CAA5B;AACD;AACF,OAVL,CAWA;;;AAEI,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,UAA/C,CAAD,IAA+D,CAAC,KAAK,WAAL,CAAiB,YAArF,EAAmG;AACjG,eAAO,eAAP;AACD;;AAED,MAAA,eAAe,CAAC,KAAhB,GAAwB,UAAU,CAAC,YAAX,CAAwB,eAAe,CAAC,KAAxC,EAA+C,KAAK,WAAL,CAAiB,KAAhE,EAAuE,KAAK,WAAL,CAAiB,IAAxF,CAAxB;;AAEA,UAAI,KAAK,KAAT,EAAgB;AACd,QAAA,eAAe,CAAC,SAAhB,GAA4B,UAAU,CAAC,YAAX,CAAwB,eAAe,CAAC,SAAxC,EAAmD,KAAK,WAAL,CAAiB,KAApE,EAA2E,KAAK,WAAL,CAAiB,IAA5F,CAA5B;AACD,OArBL,CAsBA;;;AAEI,UAAI,KAAK,KAAL,IAAc,KAAK,CAAC,KAAN,GAAc,KAAK,CAAC,SAAtC,EAAiD;AACrD;AACM;AACA,YAAI,KAAK,WAAL,CAAiB,WAArB,EAAkC;AAChC,UAAA,eAAe,CAAC,KAAhB,GAAwB,eAAe,CAAC,SAAxC;AACD,SAFD,MAEO;AACL;AAAA;AAAM,UAAA,SAAS,GAAW,KAAK,CAAC,KAAhC;AACA,UAAA,eAAe,CAAC,KAAhB,GAAwB,KAAK,CAAC,SAA9B;AACA,UAAA,eAAe,CAAC,SAAhB,GAA4B,SAA5B;AACD;AACF;;AAED,aAAO,eAAP;AACJ;AAEC;AAAQ;AAAmB;;;;6CAA5B;AACI;AAAA;AAAM,MAAA,mBAAmB,GAAgB;AACvC,QAAA,KAAK,EAAE,KAAK,KAD2B;AAEvC,QAAA,SAAS,EAAE,KAAK;AAFuB,OAAzC;AAIA;AAAA;AAAM,MAAA,qBAAqB,GAAgB,KAAK,oBAAL,CAA0B,mBAA1B,CAA3C;;AACA,UAAI,CAAC,WAAW,CAAC,OAAZ,CAAoB,qBAApB,EAA2C,mBAA3C,CAAL,EAAsE;AACpE,aAAK,KAAL,GAAa,qBAAqB,CAAC,KAAnC;AACA,aAAK,SAAL,GAAiB,qBAAqB,CAAC,SAAvC;AAEA,aAAK,wBAAL,CAA8B,IAA9B,CAAmC;AACjC,UAAA,KAAK,EAAE,KAAK,KADqB;AAEjC,UAAA,SAAS,EAAE,KAAK,SAFiB;AAGjC,UAAA,WAAW,EAAE,IAHoB;AAIjC,UAAA,kBAAkB,EAAE;AAJa,SAAnC;AAMD;AACL;AAEC;AAAQ;AAAmB;;;;sCAA5B;AACI,UAAI,CAAC,KAAK,UAAV,EAAsB;AACpB;AACD;;AAED;AAAA;AAAM,MAAA,2BAA2B,GAAW,KAAK,WAAL,CAAiB,mBAA7D;AACA;AAAA;AAAM,MAAA,4BAA4B,GAAW,KAAK,WAAL,CAAiB,oBAA9D;AAEA,WAAK,YAAL;;AAEA,UAAI,2BAA2B,KAAK,KAAK,WAAL,CAAiB,mBAArD,EAA0E;AACxE,aAAK,kCAAL;AACA,aAAK,gCAAL,CAAsC,KAAK,WAAL,CAAiB,mBAAvD;AACD;;AAED,UAAI,4BAA4B,KAAK,KAAK,WAAL,CAAiB,oBAAtD,EAA4E;AAC1E,aAAK,kCAAL;AACA,aAAK,gCAAL,CAAsC,KAAK,WAAL,CAAiB,oBAAvD;AACD,OAlBL,CAmBA;;;AAEI,WAAK,sBAAL;AAEA,WAAK,YAAL,GAAoB,KAAK,qBAAL,CAA2B,KAAK,KAAhC,CAApB;;AACA,UAAI,KAAK,KAAT,EAAgB;AACd,aAAK,aAAL,GAAqB,KAAK,qBAAL,CAA2B,KAAK,SAAhC,CAArB;AACD,OAFD,MAEO;AACL,aAAK,aAAL,GAAqB,IAArB;AACD;;AAED,WAAK,WAAL;AACJ;AAEC;AAAQ;AAAmB;;;;mCAC5B;AACI,WAAK,WAAL,GAAmB,IAAI,OAAJ,EAAnB;AACA,MAAA,MAAM,CAAC,MAAP,CAAc,KAAK,WAAnB,EAAgC,KAAK,OAArC;AAEA,WAAK,WAAL,CAAiB,cAAjB,GAAkC,KAAK,KAAL,IAAc,KAAK,WAAL,CAAiB,cAAjE;AACA,WAAK,WAAL,CAAiB,kBAAjB,GAAsC,KAAK,KAAL,IAAc,KAAK,WAAL,CAAiB,kBAArE;;AACA,UAAI,KAAK,WAAL,CAAiB,kBAArB,EAAyC;AACvC,aAAK,WAAL,CAAiB,cAAjB,GAAkC,IAAlC;AACD;;AAED,WAAK,WAAL,CAAiB,SAAjB,GAA6B,KAAK,WAAL,CAAiB,SAAjB,IAC3B,KAAK,WAAL,CAAiB,eADU,IAE3B,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,UAA/C,CAFH;;AAGA,UAAI,KAAK,WAAL,CAAiB,SAAjB,KACA,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,QAA/C,CAAD,IAA6D,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,UAA/C,CAD9D,CAAJ,EAC+H;AAC7H,aAAK,iBAAL,GAAyB,IAAzB;AACD;;AAED,WAAK,WAAL,CAAiB,gBAAjB,GAAoC,KAAK,WAAL,CAAiB,gBAAjB,IAClC,KAAK,WAAL,CAAiB,mBADiB,IAElC,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,yBAA/C,CAFH;;AAIA,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,UAA/C,CAAL,EAAiE;AAC/D,aAAK,sBAAL;AACD,OAFD,MAEO;AACL,aAAK,qBAAL;AACD;;AAED,UAAI,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,aAA/C,CAAJ,EAAmE;AACjE,aAAK,WAAL,CAAiB,aAAjB,GAAiC,UAAC,QAAD,EAAmB,QAAnB,EAAvC;AACQ,iBAAO,QAAQ,GAAG,KAAX,GAAmB,QAA1B;AACD,SAFD;AAGD;;AAED,UAAI,KAAK,WAAL,CAAiB,QAAjB,IAA6B,KAAK,WAAL,CAAiB,KAAjB,KAA2B,CAA5D,EAA+D;AAC7D,cAAM,KAAK,CAAC,2CAAD,CAAX;AACD;AACL;AAEC;AAAQ;AAAmB;;;;6CAA5B;AAAA;;AACI,WAAK,WAAL,CAAiB,KAAjB,GAAyB,CAAzB;AACA,WAAK,WAAL,CAAiB,IAAjB,GAAwB,KAAK,WAAL,CAAiB,UAAjB,CAA4B,MAA5B,GAAqC,CAA7D;AACA,WAAK,WAAL,CAAiB,IAAjB,GAAwB,CAAxB;;AAEA,UAAI,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,SAA/C,CAAJ,EAA+D;AAC7D,aAAK,WAAL,CAAiB,SAAjB,GAA6B,UAAC,UAAD,EAAnC;AACQ,cAAI,MAAI,CAAC,WAAL,CAAiB,sBAArB,EAA6C;AAC3C,mBAAO,MAAM,CAAC,MAAI,CAAC,YAAL,CAAkB,UAAlB,CAAD,CAAb;AACD;;AACD,iBAAO,MAAM,CAAC,UAAD,CAAb;AACD,SALD;AAMD;;AAED,WAAK,WAAL,CAAiB,SAAjB,GAA6B,UAAC,KAAD,EAAjC;AACM;AAAA;AAAM,QAAA,IAAI,GAAyB,MAAI,CAAC,WAAL,CAAiB,UAAjB,CAA4B,KAA5B,CAAnC;AACA,eAAO,IAAI,CAAC,MAAZ;AACD,OAHD;AAIJ;AAEC;AAAQ;AAAmB;;;;4CAA5B;AACI,UAAI,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,IAA/C,CAAJ,EAA0D;AACxD,aAAK,WAAL,CAAiB,IAAjB,GAAwB,CAAxB;AACD,OAFD,MAEO;AACL,aAAK,WAAL,CAAiB,IAAjB,GAAwB,CAAC,KAAK,WAAL,CAAiB,IAA1C;;AACA,YAAI,KAAK,WAAL,CAAiB,IAAjB,IAAyB,CAA7B,EAAgC;AAC9B,eAAK,WAAL,CAAiB,IAAjB,GAAwB,CAAxB;AACF;AACD;;AAED,UAAI,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,IAA/C,KACA,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,KAA/C,CADJ,EAC2D;AACzD,cAAM,KAAK,CAAC,yCAAD,CAAX;AACD;;AACD,WAAK,WAAL,CAAiB,IAAjB,GAAwB,CAAC,KAAK,WAAL,CAAiB,IAA1C;AACA,WAAK,WAAL,CAAiB,KAAjB,GAAyB,CAAC,KAAK,WAAL,CAAiB,KAA3C;;AAEA,UAAI,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,SAA/C,CAAJ,EAA+D;AAC7D,aAAK,WAAL,CAAiB,SAAjB,GAA6B,UAAC,KAAD;AAAA,iBAA2B,MAAM,CAAC,KAAD,CAAjC;AAAA,SAA7B;AACD;AACL;AAEC;AAAQ;AACA;;;;kCAAT;AACI,WAAK,mBAAL;AACA,WAAK,gBAAL;AACA,WAAK,eAAL;AACA,WAAK,gBAAL;AACA,WAAK,YAAL;AACA,WAAK,oBAAL;AACA,WAAK,mBAAL;AACA,WAAK,uBAAL;AACA,WAAK,sBAAL;AACJ;AAEC;AAAQ;AAA8B;AACtB;;;;iCAAM,W,EAAvB;AAAE;AAEE,UAAI,WAAW,KAAK,WAAW,CAAC,GAA5B,IAAmC,WAAW,KAAK,WAAW,CAAC,GAAnE,EAAwE;AACtE,QAAA,WAAW,GAAG,WAAW,CAAC,GAA1B;AACD;;AAED,UAAI,WAAW,KAAK,WAAW,CAAC,GAAhC,EAAqC;AACnC,aAAK,gBAAL,CAAsB,KAAtB;AACD,OAFD,MAEO,IAAI,KAAK,KAAL,IAAc,WAAW,KAAK,WAAW,CAAC,GAA9C,EAAmD;AACxD,aAAK,gBAAL,CAAsB,KAAtB;AACD;AACL;AAEC;AAAQ;AAAmB;;;;6CAA5B;AACI,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,mBAAnC,CAAL,EAA8D;AAC5D,aAAK,cAAL,CAAoB,KAAK,mBAAzB;AACA;AAAA;AAAM,QAAA,OAAO,GAA0B,KAAK,iBAAL,CAAuB,KAAK,mBAA5B,CAAvC;AACA,QAAA,OAAO,CAAC,KAAR;AACD;AACL;AAEC;AAAQ;AAAmB;;;;0CAC5B;AAAA;;AACI,WAAK,WAAL;AAEA,WAAK,iBAAL,CAAuB,aAAvB,CAAqC,KAAK,WAAL,CAAiB,eAAjB,IAAoC,KAAK,WAAL,CAAiB,eAA1F;AACA,WAAK,gBAAL,CAAsB,aAAtB,CAAoC,KAAK,WAAL,CAAiB,eAAjB,IAAoC,KAAK,WAAL,CAAiB,eAAzF;AAEA;AAAA;AAAM,MAAA,kBAAkB,GAAY,KAAK,WAAL,CAAiB,eAAjB,IAAoC,CAAC,KAAK,iBAA9E;AACA,WAAK,qBAAL,CAA2B,aAA3B,CAAyC,kBAAkB,IAAI,KAAK,WAAL,CAAiB,iBAAhF;AACA,WAAK,qBAAL,CAA2B,aAA3B,CAAyC,kBAAkB,IAAI,CAAC,KAAK,KAA5B,IAAqC,KAAK,WAAL,CAAiB,iBAA/F;AACA,WAAK,oBAAL,CAA0B,aAA1B,CAAwC,kBAAkB,IAAI,CAAC,KAAK,KAA5B,IAAqC,KAAK,WAAL,CAAiB,iBAA9F;AACA,WAAK,mBAAL,CAAyB,aAAzB,CAAuC,CAAC,KAAK,KAAN,IAAe,CAAC,KAAK,WAAL,CAAiB,gBAAxE;AACA,WAAK,4BAAL,CAAkC,aAAlC,CAAgD,CAAC,KAAK,KAAN,IAAe,CAAC,KAAK,WAAL,CAAiB,sBAAjF;AACA,WAAK,6BAAL,CAAmC,aAAnC,CAAiD,CAAC,KAAK,KAAN,IAAe,CAAC,KAAK,WAAL,CAAiB,sBAAlF;AAEA,WAAK,uBAAL,GAA+B,KAAK,KAAL,IAAc,KAAK,WAAL,CAAiB,sBAA9D;AACA,WAAK,0BAAL,GAAkC,KAAK,WAAL,CAAiB,cAAjB,IAAmC,CAAC,KAAK,WAAL,CAAiB,eAAvF;AACA,WAAK,qBAAL,GAA6B,KAAK,iBAAL,IAA0B,KAAK,OAAL,CAAa,eAApE;;AAEA,UAAI,KAAK,0BAAL,KAAoC,KAAK,WAAL,CAAiB,QAAzD,EAAmE;AACjE,aAAK,mBAAL,GADiE,CAEvE;AACM;AACM;;AACN,QAAA,UAAU,CAAC,YAAjB;AAA+B,UAAA,MAAI,CAAC,WAAL;AAAqB,SAApC,CAAV;AACD,OAxBL,CAyBA;AAEG;;;AACC,UAAI,KAAK,yBAAL,KAAmC,KAAK,WAAL,CAAiB,OAAxD,EAAiE;AAC/D,QAAA,UAAU,CAAC,YAAjB;AAA+B,UAAA,MAAI,CAAC,yBAAL,GAAiC,MAAI,CAAC,WAAL,CAAiB,OAAlD;AAA4D,SAA3E,CAAV;AACD;AACL;AAEC;AAAQ;AAAmB;;;;2CAC5B;AACI,UAAI,KAAK,WAAL,CAAiB,QAAjB,IAA6B,KAAK,WAAL,CAAiB,QAAlD,EAA4D;AAC1D,aAAK,YAAL;AACD,OAFD,MAEO;AACL,aAAK,UAAL;AACD;AACL;AAEC;AAAQ;AAAmB;;;;0CAC5B;AACI,WAAK,yBAAL,GAAiC,KAAK,WAAL,CAAiB,QAAjB,GAA4B,UAA5B,GAAyC,IAA1E;AACJ;AAEC;AAAQ;AAAmB;;;;0CAC5B;AACI,WAAK,0BAAL,GAAkC,KAAK,WAAL,CAAiB,QAAnD;;AADJ,kDAE0B,KAAK,oBAAL,EAF1B;AAAA;;AAAA;AAEI,+DAAmD;AAAA,cAAxC,OAAwC;;AACvD;AACM,cAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,OAA9B,CAAL,EAA6C;AAC3C,YAAA,OAAO,CAAC,WAAR,CAAoB,KAAK,WAAL,CAAiB,QAArC;AACD;AACF;AAPL;AAAA;AAAA;AAAA;AAAA;AAQA;AAEC;AAAQ;AAAmB;;;;kCAA5B;AAAA,kDAC0B,KAAK,oBAAL,EAD1B;AAAA;;AAAA;AACI,+DAAmD;AAAA,cAAxC,OAAwC;AACjD,UAAA,OAAO,CAAC,QAAR,CAAiB,KAAK,WAAL,CAAiB,KAAlC;AACD;AAHL;AAAA;AAAA;AAAA;AAAA;AAIA;AAEC;AAAQ;AAAmB;;;;2CAA5B;AACI,aAAO,CAAC,KAAK,4BAAN,EACL,KAAK,6BADA,EAEL,KAAK,cAFA,EAGL,KAAK,mBAHA,EAIL,KAAK,gBAJA,EAKL,KAAK,gBALA,EAML,KAAK,iBANA,EAOL,KAAK,gBAPA,EAQL,KAAK,qBARA,EASL,KAAK,qBATA,EAUL,KAAK,oBAVA,EAWL,KAAK,YAXA,CAAP;AAaJ;AAEC;AAAQ;AAAmB;;;;kCAE5B;AACI,WAAK,eAAL,CAAqB,KAAK,eAAL,CAAqB,KAAK,YAA1B,CAArB;AACJ;AAEG;AACQ;AAEE;;AAAT,UAAI,KAAK,KAAT,EAAgB;AACd,aAAK,gBAAL,CAAsB,KAAK,eAAL,CAAqB,KAAK,aAA1B,CAAtB;AACD;;AAED,WAAK,kBAAL;;AAEA,UAAI,KAAK,KAAT,EAAgB;AACd,aAAK,mBAAL;AACD;;AAED,WAAK,gBAAL;AACJ;AAEC;AAAQ;AAAmB;;;;uCAC5B;AACI,WAAK,oBAAL;AAEA,WAAK,gBAAL,CAAsB,IAAtB,GAA6B,QAA7B;;AAEA,UAAK,KAAK,WAAL,CAAiB,eAAjB,IACH,EAAE,KAAK,WAAL,CAAiB,QAAjB,IAA6B,KAAK,WAAL,CAAiB,QAAhD,CADF,EAC8D;AAC5D,aAAK,gBAAL,CAAsB,QAAtB,GAAiC,GAAjC;AACD,OAHD,MAGO;AACL,aAAK,gBAAL,CAAsB,QAAtB,GAAiC,EAAjC;AACD;;AAED,UAAI,KAAK,WAAL,CAAiB,QAArB,EAA+B;AAC7B,aAAK,gBAAL,CAAsB,eAAtB,GAAwC,UAAxC;AACD;;AAED,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,SAA/C,CAAL,EAAgE;AAC9D,aAAK,gBAAL,CAAsB,SAAtB,GAAkC,KAAK,WAAL,CAAiB,SAAnD;AACD,OAFD,MAEO,IAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,cAA/C,CAAL,EAAqE;AAC1E,aAAK,gBAAL,CAAsB,cAAtB,GAAuC,KAAK,WAAL,CAAiB,cAAxD;AACD;;AAED,UAAI,KAAK,KAAT,EAAgB;AACd,aAAK,gBAAL,CAAsB,IAAtB,GAA6B,QAA7B;;AAEA,YAAI,KAAK,WAAL,CAAiB,eAAjB,IACF,EAAE,KAAK,WAAL,CAAiB,QAAjB,IAA6B,KAAK,WAAL,CAAiB,QAAhD,CADF,EAC6D;AAC3D,eAAK,gBAAL,CAAsB,QAAtB,GAAiC,GAAjC;AACD,SAHD,MAGO;AACL,eAAK,gBAAL,CAAsB,QAAtB,GAAiC,EAAjC;AACD;;AAED,aAAK,gBAAL,CAAsB,eAAtB,GAAwC,KAAK,WAAL,CAAiB,QAAjB,GAA4B,UAA5B,GAAyC,YAAjF;;AAEA,YAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,aAA/C,CAAL,EAAoE;AAClE,eAAK,gBAAL,CAAsB,SAAtB,GAAkC,KAAK,WAAL,CAAiB,aAAnD;AACD,SAFD,MAEO,IAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,kBAA/C,CAAL,EAAyE;AAC9E,eAAK,gBAAL,CAAsB,cAAtB,GAAuC,KAAK,WAAL,CAAiB,kBAAxD;AACD;AACF;AACL;AAEC;AAAQ;AAAmB;;;;2CAC5B;AACI,WAAK,gBAAL,CAAsB,YAAtB,GAAqC,CAAC,CAAC,KAAK,KAAP,EAAc,QAAd,EAArC;AACA,WAAK,gBAAL,CAAsB,aAAtB,GAAsC,KAAK,WAAL,CAAiB,SAAjB,CAA2B,CAAC,KAAK,KAAjC,EAAwC,SAAS,CAAC,GAAlD,CAAtC;AACA,WAAK,gBAAL,CAAsB,YAAtB,GAAqC,KAAK,WAAL,CAAiB,KAAjB,CAAuB,QAAvB,EAArC;AACA,WAAK,gBAAL,CAAsB,YAAtB,GAAqC,KAAK,WAAL,CAAiB,IAAjB,CAAsB,QAAtB,EAArC;;AAEA,UAAI,KAAK,KAAT,EAAgB;AACd,aAAK,gBAAL,CAAsB,YAAtB,GAAqC,CAAC,CAAC,KAAK,SAAP,EAAkB,QAAlB,EAArC;AACA,aAAK,gBAAL,CAAsB,aAAtB,GAAsC,KAAK,WAAL,CAAiB,SAAjB,CAA2B,CAAC,KAAK,SAAjC,EAA4C,SAAS,CAAC,IAAtD,CAAtC;AACA,aAAK,gBAAL,CAAsB,YAAtB,GAAqC,KAAK,WAAL,CAAiB,KAAjB,CAAuB,QAAvB,EAArC;AACA,aAAK,gBAAL,CAAsB,YAAtB,GAAqC,KAAK,WAAL,CAAiB,IAAjB,CAAsB,QAAtB,EAArC;AACD;AACL;AAEC;AAAQ;AAAmB;;;;8CAE5B;AACI,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,eAA/C,CAAL,EAAsE;AACpE,aAAK,gBAAL,CAAsB,YAAtB,CAAmC,KAAK,WAAL,CAAiB,eAApD;AACD,OAFD,MAEO;AACL,aAAK,gBAAL,CAAsB,kBAAtB;AACD;;AAED;AAAA;AAAM,MAAA,WAAW,GAAW,KAAK,gBAAL,CAAsB,SAAlD;AAEA,WAAK,mBAAL,GAA2B,WAAW,GAAG,CAAzC;;AAEA,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,YAA/C,CAAL,EAAmE;AACjE,aAAK,cAAL,CAAoB,YAApB,CAAiC,KAAK,WAAL,CAAiB,YAAlD;AACD,OAFD,MAEO;AACL,aAAK,cAAL,CAAoB,kBAApB;AACD;;AAED,WAAK,iBAAL,GAAyB,KAAK,cAAL,CAAoB,SAApB,GAAgC,WAAzD;;AAEA,UAAI,KAAK,UAAT,EAAqB;AACnB,aAAK,gBAAL;AACA,aAAK,eAAL;AACA,aAAK,WAAL;AACD;AACL;AAEC;AAAQ;AAAmB;;;;8DAA5B;AACI,WAAK,uBAAL;AACA,WAAK,kBAAL,CAAwB,aAAxB;AACJ;AAEC;AAAQ;AAAmB;;;;uCAC5B;AAAA;;AACI,UAAI,CAAC,KAAK,WAAL,CAAiB,SAAtB,EAAiC;AAC/B;AACD;;AAED;AAAA;AAAM,MAAA,UAAU,GAAa,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,UAA/C,CAAD,GACzB,KAAK,WAAL,CAAiB,UADQ,GAEzB,KAAK,aAAL,EAFJ;AAGA;AAAA;AAAM,MAAA,SAAS,GAAW,KAAK,WAAL,CAAiB,QAAjB,GAA4B,YAA5B,GAA2C,YAArE;;AAEA,UAAI,KAAK,WAAL,CAAiB,WAArB,EAAkC;AAChC,QAAA,UAAU,CAAC,OAAX;AACD;;AAED;AAAA;AAAM,MAAA,QAAQ,GAAW,UAAU,CAAC,GAAX,CAAe,UAAC,KAAD,EAA5C;AACM;AAAA;AAAI,QAAA,QAAQ,GAAW,MAAI,CAAC,eAAL,CAAqB,KAArB,CAAvB;;AAEA,YAAI,MAAI,CAAC,WAAL,CAAiB,QAArB,EAA+B;AAC7B,UAAA,QAAQ,GAAG,MAAI,CAAC,iBAAL,GAAyB,QAApC;AACD;;AAED;AAAA;AAAM,QAAA,WAAW,GAAW,SAAS,GAAG,GAAZ,GAAkB,IAAI,CAAC,KAAL,CAAW,QAAX,CAAlB,GAAyC,KAArE;AACA;AAAA;AAAM,QAAA,IAAI,GAAS,IAAI,IAAJ,EAAnB;AACA,QAAA,IAAI,CAAC,QAAL,GAAgB,MAAI,CAAC,cAAL,CAAoB,KAApB,CAAhB;AACA,QAAA,IAAI,CAAC,KAAL,GAAa;AACX,+BAAqB,WADV;AAEX,4BAAkB,WAFP;AAGX,0BAAgB,WAHL;AAIX,2BAAiB,WAJN;AAKX,UAAA,SAAS,EAAE;AALA,SAAb;;AAOA,YAAI,IAAI,CAAC,QAAL,IAAiB,CAAC,WAAW,CAAC,iBAAZ,CAA8B,MAAI,CAAC,WAAL,CAAiB,oBAA/C,CAAtB,EAA4F;AAC1F,UAAA,IAAI,CAAC,KAAL,CAAW,kBAAX,IAAiC,MAAI,CAAC,oBAAL,EAAjC;AACD;;AACD,YAAI,CAAC,IAAI,CAAC,QAAN,IAAkB,CAAC,WAAW,CAAC,iBAAZ,CAA8B,MAAI,CAAC,WAAL,CAAiB,YAA/C,CAAvB,EAAqF;AACnF,UAAA,IAAI,CAAC,KAAL,CAAW,kBAAX,IAAiC,MAAI,CAAC,YAAL,CAAkB,KAAlB,CAAjC;AACD;;AACD,YAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,MAAI,CAAC,WAAL,CAAiB,YAA/C,CAAL,EAAmE;AACjE,UAAA,IAAI,CAAC,OAAL,GAAe,MAAI,CAAC,WAAL,CAAiB,YAAjB,CAA8B,KAA9B,CAAf;AACA,UAAA,IAAI,CAAC,gBAAL,GAAwB,MAAI,CAAC,WAAL,CAAiB,QAAjB,GAA4B,OAA5B,GAAsC,KAA9D;AACD;;AACD,YAAI,MAAI,CAAC,WAAL,CAAiB,eAAjB,IAAqC,KAAK,GAAG,MAAI,CAAC,WAAL,CAAiB,aAAzB,KAA2C,CAApF,EAAwF;AACtF,UAAA,IAAI,CAAC,KAAL,GAAa,MAAI,CAAC,eAAL,CAAqB,KAArB,EAA4B,SAAS,CAAC,SAAtC,CAAb;;AACA,cAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,MAAI,CAAC,WAAL,CAAiB,kBAA/C,CAAL,EAAyE;AACvE,YAAA,IAAI,CAAC,YAAL,GAAoB,MAAI,CAAC,WAAL,CAAiB,kBAAjB,CAAoC,KAApC,CAApB;AACA,YAAA,IAAI,CAAC,qBAAL,GAA6B,MAAI,CAAC,WAAL,CAAiB,QAAjB,GACzB,OADyB,GAEzB,KAFJ;AAGD;AACF;;AACD,YAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,MAAI,CAAC,WAAL,CAAiB,SAA/C,CAAL,EAAgE;AAC9D;AAAA;AAAM,UAAA,MAAM,GAAW,MAAI,CAAC,WAAL,CAAiB,SAAjB,CAA2B,KAA3B,CAAvB;;AACA,cAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,MAA9B,CAAL,EAA4C;AAC1C,YAAA,IAAI,CAAC,MAAL,GAAc,MAAd;AACD;AACF;;AACD,eAAO,IAAP;AACD,OA3CwB,CAAzB,CAdJ,CA0DA;AAEG;;AACC,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,KAAnC,CAAD,IAA8C,KAAK,KAAL,CAAW,MAAX,KAAsB,QAAQ,CAAC,MAAjF,EAAyF;AACvF,aAAK;AAAA;AAAI,QAAA,CAAC,GAAW,CAArB,EAAwB,CAAC,GAAI,QAAQ,CAAC,MAAtC,EAA8C,EAAE,CAAhD,EAAmD;AACjD,UAAA,MAAM,CAAC,MAAP,CAAc,KAAK,KAAL,CAAW,CAAX,CAAd,EAA6B,QAAQ,CAAC,CAAD,CAArC;AACD;AACF,OAJD,MAIO;AACL,aAAK,KAAL,GAAa,QAAb;AACD;;AAED,WAAK,kBAAL,CAAwB,aAAxB;AACJ;AAEC;AAAQ;AAAmB;;;;oCAA5B;AACI;AAAA;AAAM,MAAA,IAAI,GAAY,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,QAA/C,CAAF,GAA8D,KAAK,WAAL,CAAiB,QAA/E,GAA0F,KAAK,WAAL,CAAiB,IAAhI;AACA;AAAA;AAAM,MAAA,UAAU,GAAa,EAA7B;;AACA,WAAK;AAAA;AAAI,MAAA,KAAK,GAAW,KAAK,WAAL,CAAiB,KAA1C,EAAiD,KAAK,IAAI,KAAK,WAAL,CAAiB,IAA3E,EAAiF,KAAK,IAAI,IAA1F,EAAgG;AAC9F,QAAA,UAAU,CAAC,IAAX,CAAgB,KAAhB;AACD;;AACD,aAAO,UAAP;AACJ;AAEC;AAAQ;AAAwB;AAChC;;;;mCADwB,K,EAAzB;AACI,UAAI,CAAC,KAAK,KAAV,EAAiB;AACf,YAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,yBAA/C,CAAL,EAAgF;AAC9E;AAAA;AAAM,UAAA,MAAM,GAAW,KAAK,WAAL,CAAiB,yBAAxC;;AACA,cAAI,KAAK,YAAL,GAAoB,MAApB,IACA,KAAK,IAAI,MADT,IAEA,KAAK,IAAI,KAAK,YAFlB,EAEgC;AAC9B,mBAAO,IAAP;AACD,WAJD,MAIO,IAAI,KAAK,YAAL,GAAoB,MAApB,IACA,KAAK,IAAI,MADT,IAEA,KAAK,IAAI,KAAK,YAFlB,EAEgC;AACrC,mBAAO,IAAP;AACD;AACF,SAXD,MAWO,IAAI,KAAK,WAAL,CAAiB,mBAArB,EAA0C;AAC/C,cAAI,KAAK,IAAI,KAAK,YAAlB,EAAgC;AAC9B,mBAAO,IAAP;AACD;AACF,SAJM,MAIA,IAAI,KAAK,WAAL,CAAiB,gBAAjB,IAAqC,KAAK,IAAI,KAAK,YAAvD,EAAqE;AAC1E,iBAAO,IAAP;AACD;AACF;;AAED,UAAI,KAAK,KAAL,IAAc,KAAK,IAAI,KAAK,YAA5B,IAA4C,KAAK,IAAI,KAAK,aAA9D,EAA6E;AAC3E,eAAO,IAAP;AACD;;AAED,aAAO,KAAP;AACJ;AAEC;AAAQ;AAAmB;;;;uCAC5B;AACI,UAAI,CAAC,KAAK,iBAAL,CAAuB,UAA5B,EAAwC;AACtC,aAAK,iBAAL,CAAuB,QAAvB,CAAgC,KAAK,eAAL,CAAqB,KAAK,WAAL,CAAiB,KAAtC,EAA6C,SAAS,CAAC,KAAvD,CAAhC;AACA,aAAK,iBAAL,CAAuB,kBAAvB;AACA;AAAA;AAAM,QAAA,QAAQ,GAAW,KAAK,WAAL,CAAiB,WAAjB,GACrB,KAAK,cAAL,CAAoB,SAApB,GAAgC,KAAK,iBAAL,CAAuB,SADlC,GAErB,CAFJ;AAGA,aAAK,iBAAL,CAAuB,WAAvB,CAAmC,QAAnC;AACD;AACL;AAEC;AAAQ;AAAmB;;;;sCAC5B;AACI,UAAI,CAAC,KAAK,gBAAL,CAAsB,UAA3B,EAAuC;AACrC,aAAK,gBAAL,CAAsB,QAAtB,CAA+B,KAAK,eAAL,CAAqB,KAAK,WAAL,CAAiB,IAAtC,EAA4C,SAAS,CAAC,IAAtD,CAA/B;AACA,aAAK,gBAAL,CAAsB,kBAAtB;AACA;AAAA;AAAM,QAAA,QAAQ,GAAW,KAAK,WAAL,CAAiB,WAAjB,GACrB,CADqB,GAErB,KAAK,cAAL,CAAoB,SAApB,GAAgC,KAAK,gBAAL,CAAsB,SAF1D;AAGA,aAAK,gBAAL,CAAsB,WAAtB,CAAkC,QAAlC;AACD;AACL;AAEC;AAAQ;AAAwB;AACtB;AAAmB;;;;kCAAN,K,EAAoB,M,EAA5C;AACI,UAAI,KAAK,KAAK,WAAW,CAAC,GAA1B,EAA+B;AAC7B,aAAK,eAAL,CAAqB,MAArB;AACD,OAFD,MAEO,IAAI,KAAK,KAAK,WAAW,CAAC,GAA1B,EAA+B;AACpC,aAAK,gBAAL,CAAsB,MAAtB;AACD;;AAED,WAAK,kBAAL;AACA,WAAK,gBAAL;;AACA,UAAI,KAAK,KAAT,EAAgB;AACd,aAAK,mBAAL;AACD;AACL;AAEC;AAAQ;AAA4B;AAAyB;AAAmB;;;;sCACrD,S,EAAwB,M,EAApD;AACI;AAAA;AAAM,MAAA,cAAc,GAAY,SAAS,KAAK,WAAW,CAAC,GAA3B,GAC3B,KAAK,qBAAL,CAA2B,SADA,GAE3B,KAAK,qBAAL,CAA2B,SAF/B;AAGA;AAAA;AAAM,MAAA,aAAa,GAAW,MAAM,GAAG,cAAc,GAAG,CAA1B,GAA8B,KAAK,mBAAjE;AACA;AAAA;AAAM,MAAA,WAAW,GAAW,KAAK,cAAL,CAAoB,SAApB,GAAgC,cAA5D;;AAEA,UAAI,CAAC,KAAK,WAAL,CAAiB,kBAAtB,EAA0C;AACxC,eAAO,aAAP;AACD;;AAED,UAAK,KAAK,WAAL,CAAiB,WAAjB,IAAgC,SAAS,KAAK,WAAW,CAAC,GAA3D,IACA,CAAC,KAAK,WAAL,CAAiB,WAAlB,IAAiC,SAAS,KAAK,WAAW,CAAC,GAD/D,EACqE;AACnE,eAAO,IAAI,CAAC,GAAL,CAAS,aAAT,EAAwB,WAAxB,CAAP;AACD,OAHD,MAGO;AACL,eAAO,IAAI,CAAC,GAAL,CAAS,IAAI,CAAC,GAAL,CAAS,aAAT,EAAwB,CAAxB,CAAT,EAAqC,WAArC,CAAP;AACD;AACL;AAEC;AAAQ;AAAyB;AAC9B;;;;oCAAsB,M,EAA1B;AACI,WAAK,gBAAL,CAAsB,WAAtB,CAAkC,MAAlC;AACA,WAAK,qBAAL,CAA2B,QAA3B,CAAoC,KAAK,eAAL,CAAqB,KAAK,YAA1B,EAAwC,SAAS,CAAC,GAAlD,CAApC;AACA,WAAK,qBAAL,CAA2B,WAA3B,CAAuC,KAAK,iBAAL,CAAuB,WAAW,CAAC,GAAnC,EAAwC,MAAxC,CAAvC;;AAEA,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,eAA/C,CAAL,EAAsE;AACpE,aAAK,eAAL,GAAuB;AACrB,UAAA,eAAe,EAAE,KAAK,eAAL,CAAqB,WAAW,CAAC,GAAjC;AADI,SAAvB;AAGD;;AAED,UAAI,KAAK,WAAL,CAAiB,mBAArB,EAA0C;AACxC,aAAK,kCAAL;AACD;AACL;AAEC;AAAQ;AAAyB;AAC/B;;;;qCAAwB,M,EAA3B;AACI,WAAK,gBAAL,CAAsB,WAAtB,CAAkC,MAAlC;AACA,WAAK,qBAAL,CAA2B,QAA3B,CAAoC,KAAK,eAAL,CAAqB,KAAK,aAA1B,EAAyC,SAAS,CAAC,IAAnD,CAApC;AACA,WAAK,qBAAL,CAA2B,WAA3B,CAAuC,KAAK,iBAAL,CAAuB,WAAW,CAAC,GAAnC,EAAwC,MAAxC,CAAvC;;AAEA,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,eAA/C,CAAL,EAAsE;AACpE,aAAK,eAAL,GAAuB;AACrB,UAAA,eAAe,EAAE,KAAK,eAAL,CAAqB,WAAW,CAAC,GAAjC;AADI,SAAvB;AAGD;;AACD,UAAI,KAAK,WAAL,CAAiB,mBAArB,EAA0C;AACxC,aAAK,kCAAL;AACD;AACL;AAEC;AAAQ;AAAmB;;;;yDAC5B;AAAE;AAEE,UAAI,KAAK,WAAL,CAAiB,iBAArB,EAAwC;AACtC;AACD;;AACD;AAAA;AAAI,MAAA,gBAAgB,GAAY,KAAhC;AACA;AAAA;AAAI,MAAA,eAAe,GAAY,KAA/B;AACA;AAAA;AAAM,MAAA,iBAAiB,GAAY,KAAK,sBAAL,CAA4B,KAAK,qBAAjC,CAAnC;AACA;AAAA;AAAM,MAAA,gBAAgB,GAAY,KAAK,qBAAL,CAA2B,KAAK,qBAAhC,CAAlC;AACA;AAAA;AAAM,MAAA,gBAAgB,GAAY,KAAK,qBAAL,CAA2B,KAAK,qBAAhC,CAAlC;AACA;AAAA;AAAM,MAAA,sBAAsB,GAAY,KAAK,sBAAL,CAA4B,KAAK,oBAAjC,CAAxC;AACA;AAAA;AAAM,MAAA,qBAAqB,GAAY,KAAK,qBAAL,CAA2B,KAAK,oBAAhC,CAAvC;;AAEA,UAAI,iBAAJ,EAAuB;AACrB,QAAA,gBAAgB,GAAG,IAAnB;AACA,aAAK,iBAAL,CAAuB,IAAvB;AACD,OAHD,MAGO;AACL,QAAA,gBAAgB,GAAG,KAAnB;AACA,aAAK,iBAAL,CAAuB,IAAvB;AACD;;AAED,UAAI,gBAAJ,EAAsB;AACpB,QAAA,eAAe,GAAG,IAAlB;AACA,aAAK,gBAAL,CAAsB,IAAtB;AACD,OAHD,MAGO;AACL,QAAA,eAAe,GAAG,KAAlB;AACA,aAAK,gBAAL,CAAsB,IAAtB;AACD;;AAED,UAAI,KAAK,KAAT,EAAgB;AACd;AAAA;AAAM,QAAA,QAAQ,GAAY,KAAK,oBAAL,CAA0B,SAA1B,KAAwC,qBAAxC,GAAgE,gBAA1F;AACA;AAAA;AAAM,QAAA,SAAS,GAAY,KAAK,oBAAL,CAA0B,SAA1B,KAAwC,sBAAxC,GAAiE,iBAA5F;;AAEA,YAAI,QAAJ,EAAc;AACZ,eAAK,gBAAL,CAAsB,IAAtB;AACD,SAFD,MAEO,IAAI,CAAC,eAAL,EAAsB;AAC3B,eAAK,gBAAL,CAAsB,IAAtB;AACD,SARa,CASpB;;;AAEM,YAAI,SAAJ,EAAe;AACb,eAAK,iBAAL,CAAuB,IAAvB;AACD,SAFD,MAEO,IAAI,CAAC,gBAAL,EAAuB;AAC5B,eAAK,iBAAL,CAAuB,IAAvB;AACD;AACF;AACL;AAEC;AAAQ;AAAwB;AAAmB;;;;2CAAnB,K,EAAjC;AACI;AAAA;AAAM,MAAA,GAAG,GAAW,KAAK,CAAC,QAA1B;AACA;AAAA;AAAM,MAAA,GAAG,GAAW,KAAK,CAAC,SAA1B;AACA;AAAA;AAAM,MAAA,QAAQ,GAAW,KAAK,iBAAL,CAAuB,QAAhD;AACA;AAAA;AAAM,MAAA,QAAQ,GAAW,KAAK,iBAAL,CAAuB,SAAhD;AACA,aAAO,KAAK,WAAL,CAAiB,WAAjB,GACH,GAAG,GAAG,GAAN,IAAa,QAAQ,GAAG,CADrB,GAEH,GAAG,IAAI,QAAQ,GAAG,QAAX,GAAsB,CAFjC;AAGJ;AAEC;AAAQ;AAAwB;AAAmB;;;;0CAApB,K,EAAhC;AACI;AAAA;AAAM,MAAA,GAAG,GAAW,KAAK,CAAC,QAA1B;AACA;AAAA;AAAM,MAAA,GAAG,GAAW,KAAK,CAAC,SAA1B;AACA;AAAA;AAAM,MAAA,OAAO,GAAW,KAAK,gBAAL,CAAsB,QAA9C;AACA;AAAA;AAAM,MAAA,OAAO,GAAW,KAAK,gBAAL,CAAsB,SAA9C;AACA,aAAO,KAAK,WAAL,CAAiB,WAAjB,GACH,GAAG,IAAI,OAAO,GAAG,OAAV,GAAoB,CADxB,GAEH,GAAG,GAAG,GAAN,IAAa,OAAO,GAAG,CAF3B;AAGJ;AAEC;AAAQ;AAAmB;;;;yCAC5B;AACI;AAAA;AAAI,MAAA,QAAQ,GAAW,CAAvB;AACA;AAAA;AAAI,MAAA,SAAS,GAAW,CAAxB;AACA;AAAA;AAAM,MAAA,uBAAuB,GAAY,KAAK,WAAL,CAAiB,WAAjB,GACnC,CAAC,KAAK,WAAL,CAAiB,mBADiB,GAEnC,KAAK,WAAL,CAAiB,mBAFvB;AAGA;AAAA;AAAM,MAAA,gBAAgB,GAAW,KAAK,WAAL,CAAiB,WAAjB,GAC3B,KAAK,gBAAL,CAAsB,QAAtB,GAAiC,KAAK,mBADX,GAE3B,KAAK,gBAAL,CAAsB,QAAtB,GAAiC,KAAK,mBAF5C;;AAIA,UAAI,KAAK,KAAT,EAAgB;AACd,QAAA,SAAS,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,gBAAL,CAAsB,QAAtB,GAAiC,KAAK,gBAAL,CAAsB,QAAhE,CAAZ;AACA,QAAA,QAAQ,GAAG,gBAAX;AACD,OAHD,MAGO;AACL,YAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,yBAA/C,CAAL,EAAgF;AAC9E;AAAA;AAAM,UAAA,MAAM,GAAW,KAAK,WAAL,CAAiB,yBAAxC;AACA;AAAA;AAAM,UAAA,cAAc,GAAW,KAAK,eAAL,CAAqB,MAArB,CAA/B;AACA;AAAA;AAAM,UAAA,wBAAwB,GAAY,KAAK,WAAL,CAAiB,WAAjB,GACpC,KAAK,YAAL,IAAqB,MADe,GAEpC,KAAK,YAAL,GAAoB,MAF1B;;AAGA,cAAI,wBAAJ,EAA8B;AAC5B,YAAA,SAAS,GAAG,KAAK,gBAAL,CAAsB,QAAtB,GAAiC,cAA7C;AACA,YAAA,QAAQ,GAAG,cAAc,GAAG,KAAK,mBAAjC;AACD,WAHD,MAGO;AACL,YAAA,SAAS,GAAG,cAAc,GAAG,KAAK,gBAAL,CAAsB,QAAnD;AACA,YAAA,QAAQ,GAAG,KAAK,gBAAL,CAAsB,QAAtB,GAAiC,KAAK,mBAAjD;AACD;AACF,SAbD,MAaO,IAAI,uBAAJ,EAA6B;AAClC,UAAA,SAAS,GAAG,IAAI,CAAC,IAAL,CAAU,IAAI,CAAC,GAAL,CAAS,KAAK,iBAAL,GAAyB,KAAK,gBAAL,CAAsB,QAAxD,IAAoE,KAAK,mBAAnF,CAAZ;AACA,UAAA,QAAQ,GAAG,IAAI,CAAC,KAAL,CAAW,KAAK,gBAAL,CAAsB,QAAtB,GAAiC,KAAK,mBAAjD,CAAX;AACD,SAHM,MAGA;AACL,UAAA,SAAS,GAAG,KAAK,gBAAL,CAAsB,QAAtB,GAAiC,KAAK,mBAAlD;AACA,UAAA,QAAQ,GAAG,CAAX;AACD;AACF;;AACD,WAAK,mBAAL,CAAyB,YAAzB,CAAsC,SAAtC;AACA,WAAK,mBAAL,CAAyB,WAAzB,CAAqC,QAArC;;AACA,UAAI,KAAK,KAAL,IAAc,KAAK,WAAL,CAAiB,sBAAnC,EAA2D;AACzD,YAAI,KAAK,WAAL,CAAiB,WAArB,EAAkC;AAChC,eAAK,6BAAL,CAAmC,YAAnC,CAAgD,QAAhD;AACA,eAAK,6BAAL,CAAmC,WAAnC,CAA+C,CAA/C;AACA,eAAK,cAAL,CAAoB,kBAApB;AACA,eAAK,4BAAL,CAAkC,YAAlC,CAA+C,KAAK,cAAL,CAAoB,SAApB,IAAiC,QAAQ,GAAG,SAA5C,CAA/C;AACA,eAAK,4BAAL,CAAkC,WAAlC,CAA8C,QAAQ,GAAG,SAAzD;AACD,SAND,MAMO;AACL,eAAK,4BAAL,CAAkC,YAAlC,CAA+C,QAA/C;AACA,eAAK,4BAAL,CAAkC,WAAlC,CAA8C,CAA9C;AACA,eAAK,cAAL,CAAoB,kBAApB;AACA,eAAK,6BAAL,CAAmC,YAAnC,CAAgD,KAAK,cAAL,CAAoB,SAApB,IAAiC,QAAQ,GAAG,SAA5C,CAAhD;AACA,eAAK,6BAAL,CAAmC,WAAnC,CAA+C,QAAQ,GAAG,SAA1D;AACD;AACF;;AACD,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,oBAA/C,CAAL,EAA2E;AACzE;AAAA;AAAM,QAAA,KAAK,GAAW,KAAK,oBAAL,EAAtB;AACA,aAAK,QAAL,GAAgB;AACd,UAAA,eAAe,EAAE;AADH,SAAhB;AAGD,OALD,MAKO,IAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,oBAA/C,CAAL,EAA2E;AAChF;AAAA;AAAM,QAAA,MAAM,GAAY,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,yBAA/C,CAAF,GACf,KAAK,eAAL,CAAqB,KAAK,WAAL,CAAiB,yBAAtC,CADe,GAEf,CAFR;AAGA;AAAA;AAAM,QAAA,QAAQ,GAAa,MAAM,GAAG,QAAT,GAAoB,CAApB,IAAyB,CAAC,uBAA3B,IAAwD,MAAM,GAAG,QAAT,IAAqB,CAArB,IAA0B,uBAA5G;AACA;AAAA;AAAM,QAAA,SAAS,GAAW,KAAK,WAAL,CAAiB,QAAjB,GACpB,QAAQ,GAAG,QAAH,GAAc,KADF,GAEpB,QAAQ,GAAG,MAAH,GAAY,OAF1B;AAGA,aAAK,QAAL,GAAgB;AACd,UAAA,eAAe,EACb,wBACA,SADA,GAEA,IAFA,GAGA,KAAK,WAAL,CAAiB,oBAAjB,CAAsC,IAHtC,GAIA,MAJA,GAKA,KAAK,WAAL,CAAiB,oBAAjB,CAAsC,EALtC,GAMA;AARY,SAAhB;;AAUA,YAAI,KAAK,WAAL,CAAiB,QAArB,EAA+B;AAC7B,eAAK,QAAL,CAAc,kBAAd,GACE,aACC,MAAM,GACL,SADD,GAEC,QAFD,IAGE,QAAQ,GAAG,CAAC,KAAK,mBAAT,GAA+B,CAHzC,CADD,IAKA,IANF;AAOA,eAAK,QAAL,CAAc,cAAd,GACE,WAAW,KAAK,cAAL,CAAoB,SAApB,GAAgC,KAAK,mBAAhD,IAAuE,IADzE;AAED,SAVD,MAUO;AACL,eAAK,QAAL,CAAc,kBAAd,GACE,MAAM,GACN,QADA,IAEC,QAAQ,GAAG,KAAK,mBAAR,GAA8B,CAFvC,IAGA,WAJF;AAKA,eAAK,QAAL,CAAc,cAAd,GACE,KAAK,cAAL,CAAoB,SAApB,GAAgC,KAAK,mBAArC,GAA2D,SAD7D;AAED;AACF;AACL;AAEC;AAAQ;AAAmB;;;;2CAC5B;AACI,UAAI,KAAK,KAAT,EAAgB;AACd,eAAO,KAAK,WAAL,CAAiB,oBAAjB,CACL,KAAK,KADA,EAEL,KAAK,SAFA,CAAP;AAID;;AACD,aAAO,KAAK,WAAL,CAAiB,oBAAjB,CAAsC,KAAK,KAA3C,CAAP;AACJ;AAEC;AAAQ;AAA8B;AAAmB;;;;oCAChC,W,EAA1B;AACI,UAAI,WAAW,KAAK,WAAW,CAAC,GAAhC,EAAqC;AACnC,eAAO,KAAK,WAAL,CAAiB,eAAjB,CACL,KAAK,SADA,EAEL,WAFK,CAAP;AAID;;AACD,aAAO,KAAK,WAAL,CAAiB,eAAjB,CACL,KAAK,KADA,EAEL,WAFK,CAAP;AAIJ;AAEC;AAAQ;AAAwB;AAAmB;;;;iCAC7B,K,EAAvB;AACI,aAAO,KAAK,WAAL,CAAiB,YAAjB,CAA8B,KAA9B,CAAP;AACJ;AAEC;AAAQ;AAAmB;;;;0CAC5B;AACI;AAAA;AAAI,MAAA,cAAc,GAAY,IAA9B;;AACA,UAAI,KAAK,WAAL,CAAiB,WAArB,EAAkC;AAChC,QAAA,cAAc,GACZ,KAAK,qBAAL,CAA2B,QAA3B,GAAsC,KAAK,qBAAL,CAA2B,SAAjE,GAA6E,EAA7E,IAAmF,KAAK,qBAAL,CAA2B,QADhH;AAED,OAHD,MAGO;AACL,QAAA,cAAc,GACZ,KAAK,qBAAL,CAA2B,QAA3B,GAAsC,KAAK,qBAAL,CAA2B,SAAjE,GAA6E,EAA7E,IAAmF,KAAK,qBAAL,CAA2B,QADhH;AAED;;AAED,UAAI,cAAJ,EAAoB;AAClB;AAAA;AAAM,QAAA,eAAe,GAAW,KAAK,eAAL,CAAqB,KAAK,YAA1B,EAAwC,SAAS,CAAC,GAAlD,CAAhC;AACA;AAAA;AAAM,QAAA,gBAAgB,GAAW,KAAK,eAAL,CAAqB,KAAK,aAA1B,EAAyC,SAAS,CAAC,IAAnD,CAAjC;AACA;AAAA;AAAM,QAAA,kBAAkB,GAAW,KAAK,WAAL,CAAiB,WAAjB,GAC/B,KAAK,WAAL,CAAiB,aAAjB,CAA+B,gBAA/B,EAAiD,eAAjD,CAD+B,GAE/B,KAAK,WAAL,CAAiB,aAAjB,CAA+B,eAA/B,EAAgD,gBAAhD,CAFJ;AAIA,aAAK,oBAAL,CAA0B,QAA1B,CAAmC,kBAAnC;AACA;AAAA;AAAM,QAAA,GAAG,GAAW,KAAK,WAAL,CAAiB,kBAAjB,GAChB,IAAI,CAAC,GAAL,CACE,IAAI,CAAC,GAAL,CACE,KAAK,mBAAL,CAAyB,QAAzB,GACE,KAAK,mBAAL,CAAyB,SAAzB,GAAqC,CADvC,GAEE,KAAK,oBAAL,CAA0B,SAA1B,GAAsC,CAH1C,EAIE,CAJF,CADF,EAOE,KAAK,cAAL,CAAoB,SAApB,GAAgC,KAAK,oBAAL,CAA0B,SAP5D,CADgB,GAUhB,KAAK,mBAAL,CAAyB,QAAzB,GAAoC,KAAK,mBAAL,CAAyB,SAAzB,GAAqC,CAAzE,GAA6E,KAAK,oBAAL,CAA0B,SAA1B,GAAsC,CAVvH;AAYA,aAAK,oBAAL,CAA0B,WAA1B,CAAsC,GAAtC;AACA,aAAK,qBAAL,CAA2B,IAA3B;AACA,aAAK,qBAAL,CAA2B,IAA3B;AACA,aAAK,oBAAL,CAA0B,IAA1B;AACD,OAxBD,MAwBO;AACL,aAAK,gBAAL,CAAsB,KAAK,eAAL,CAAqB,KAAK,aAA1B,CAAtB;AACA,aAAK,eAAL,CAAqB,KAAK,eAAL,CAAqB,KAAK,YAA1B,CAArB;AACA,aAAK,qBAAL,CAA2B,IAA3B;AACA,aAAK,qBAAL,CAA2B,IAA3B;AACA,aAAK,oBAAL,CAA0B,IAA1B;AACD;;AACD,UAAI,KAAK,WAAL,CAAiB,mBAArB,EAA0C;AACxC,aAAK,kCAAL;AACD;AACL;AAEC;AAAQ;AAAwB;AAAwB;AAAmB;;;;oCAClD,K,EAAe,K,EAAzC;AACI,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,UAA/C,CAAD,IAA+D,CAAC,KAAK,WAAL,CAAiB,sBAArF,EAA6G;AAC3G,QAAA,KAAK,GAAG,KAAK,YAAL,CAAkB,KAAlB,CAAR;AACD;;AACD,aAAO,KAAK,WAAL,CAAiB,SAAjB,CAA2B,KAA3B,EAAkC,KAAlC,CAAP;AACJ;AAEC;AAAQ;AAAwB;AAC3B;AAAmB;;;;8BAAL,K,EAAe,U,EAAnC;AACI;AAAA;AAAM,MAAA,IAAI,GAAW,CAAC,WAAW,CAAC,iBAAZ,CAA8B,UAA9B,CAAD,GAA6C,UAA7C,GAA0D,KAAK,WAAL,CAAiB,IAAhG;AACA;AAAA;AAAI,MAAA,iBAAiB,GAAW,UAAU,CAAC,qBAAX,CAC9B,CAAC,KAAK,GAAG,KAAK,WAAL,CAAiB,KAA1B,IAAmC,IADL,EACW,KAAK,WAAL,CAAiB,cAD5B,CAAhC;AAEA,MAAA,iBAAiB,GAAG,IAAI,CAAC,KAAL,CAAW,iBAAX,IAAgC,IAApD;AACA,aAAO,UAAU,CAAC,qBAAX,CAAiC,KAAK,WAAL,CAAiB,KAAjB,GAAyB,iBAA1D,EAA6E,KAAK,WAAL,CAAiB,cAA9F,CAAP;AACJ;AAEC;AAAQ;AAAsB;AACpB;;;;oCAAe,G,EAA1B;AACI;AAAA;AAAI,MAAA,EAAE,GAA6B,WAAW,CAAC,qBAA/C;;AACA,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,qBAA/C,CAAL,EAA4E;AAC1E,QAAA,EAAE,GAAG,KAAK,WAAL,CAAiB,qBAAtB;AACD,OAFD,MAEO,IAAI,KAAK,WAAL,CAAiB,QAArB,EAA+B;AACpC,QAAA,EAAE,GAAG,WAAW,CAAC,kBAAjB;AACD;;AAED,MAAA,GAAG,GAAG,UAAU,CAAC,YAAX,CAAwB,GAAxB,EAA6B,KAAK,WAAL,CAAiB,KAA9C,EAAqD,KAAK,WAAL,CAAiB,IAAtE,CAAN;AACA;AAAA;AAAI,MAAA,OAAO,GAAW,EAAE,CAAC,GAAD,EAAM,KAAK,WAAL,CAAiB,KAAvB,EAA8B,KAAK,WAAL,CAAiB,IAA/C,CAAxB;;AACA,UAAI,WAAW,CAAC,iBAAZ,CAA8B,OAA9B,CAAJ,EAA4C;AAC1C,QAAA,OAAO,GAAG,CAAV;AACD;;AACD,UAAI,KAAK,WAAL,CAAiB,WAArB,EAAkC;AAChC,QAAA,OAAO,GAAG,IAAI,OAAd;AACD;;AACD,aAAO,OAAO,GAAG,KAAK,iBAAtB;AACJ;AAEC;AAAQ;AAA2B;AACpB;;;;oCAAU,Q,EAA1B;AACI;AAAA;AAAI,MAAA,OAAO,GAAW,QAAQ,GAAG,KAAK,iBAAtC;;AACA,UAAI,KAAK,WAAL,CAAiB,WAArB,EAAkC;AAChC,QAAA,OAAO,GAAG,IAAI,OAAd;AACD;;AACD;AAAA;AAAI,MAAA,EAAE,GAA4B,WAAW,CAAC,qBAA9C;;AACA,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,qBAA/C,CAAL,EAA4E;AAC1E,QAAA,EAAE,GAAG,KAAK,WAAL,CAAiB,qBAAtB;AACD,OAFD,MAEO,IAAI,KAAK,WAAL,CAAiB,QAArB,EAA+B;AACpC,QAAA,EAAE,GAAG,WAAW,CAAC,kBAAjB;AACD;;AACD;AAAA;AAAM,MAAA,KAAK,GAAW,EAAE,CAAC,OAAD,EAAU,KAAK,WAAL,CAAiB,KAA3B,EAAkC,KAAK,WAAL,CAAiB,IAAnD,CAAxB;AACA,aAAO,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAA9B,CAAD,GAAwC,KAAxC,GAAgD,CAAvD;AACJ;AAEC;AAAQ;AAAwB;AACrB;AAAmB;;;;+BAAV,K,EAA8B,a,EAAnD;AACI,UAAI,KAAK,YAAY,UAArB,EAAiC;AAC/B,eAAO,KAAK,WAAL,CAAiB,QAAjB,GAA4B,KAAK,CAAC,OAAlC,GAA4C,KAAK,CAAC,OAAzD;AACD;;AAED;AAAA;AAAI,MAAA,UAAU,GAAW,CAAzB;AACA;AAAA;AAAM,MAAA,OAAO,GAAc,KAAK,CAAC,OAAjC;;AACA,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,aAA9B,CAAL,EAAmD;AACjD,aAAK;AAAA;AAAI,QAAA,CAAC,GAAW,CAArB,EAAwB,CAAC,GAAG,OAAO,CAAC,MAApC,EAA4C,CAAC,EAA7C,EAAiD;AAC/C,cAAI,OAAO,CAAC,CAAD,CAAP,CAAW,UAAX,KAA0B,aAA9B,EAA6C;AAC3C,YAAA,UAAU,GAAG,CAAb;AACA;AACD;AACF;AACF,OAdL,CAeA;AAEG;;;AACC,aAAO,KAAK,WAAL,CAAiB,QAAjB,GAA4B,OAAO,CAAC,UAAD,CAAP,CAAoB,OAAhD,GAA0D,OAAO,CAAC,UAAD,CAAP,CAAoB,OAArF;AACJ;AAEC;AAAQ;AAAwB;AAAiC;AAAmB;;;;qCAC1D,K,EAA8B,a,EAAzD;AACI;AAAA;AAAM,MAAA,yBAAyB,GAAe,KAAK,UAAL,CAAgB,aAAhB,CAA8B,qBAA9B,EAA9C;AAEA;AAAA;AAAM,MAAA,SAAS,GAAW,KAAK,WAAL,CAAiB,QAAjB,GACxB,yBAAyB,CAAC,MADF,GACW,yBAAyB,CAAC,IAD/D;AAEA;AAAA;AAAI,MAAA,QAAQ,GAAW,CAAvB;;AACA,UAAI,KAAK,WAAL,CAAiB,QAArB,EAA+B;AAC7B,QAAA,QAAQ,GAAG,CAAC,KAAK,UAAL,CAAgB,KAAhB,EAAuB,aAAvB,CAAD,GAAyC,SAApD;AACD,OAFD,MAEO;AACL,QAAA,QAAQ,GAAG,KAAK,UAAL,CAAgB,KAAhB,EAAuB,aAAvB,IAAwC,SAAnD;AACD;;AACD,aAAO,QAAQ,GAAG,KAAK,WAAL,CAAiB,KAA5B,GAAoC,KAAK,mBAAhD;AACJ;AAEC;AAAQ;AAAwB;AACrB;;;;qCAAe,K,EAA3B;AACI,UAAI,CAAC,KAAK,KAAV,EAAiB;AACf,eAAO,WAAW,CAAC,GAAnB;AACD;;AAED;AAAA;AAAM,MAAA,QAAQ,GAAW,KAAK,gBAAL,CAAsB,KAAtB,CAAzB;AACA;AAAA;AAAM,MAAA,WAAW,GAAW,IAAI,CAAC,GAAL,CAAS,QAAQ,GAAG,KAAK,gBAAL,CAAsB,QAA1C,CAA5B;AACA;AAAA;AAAM,MAAA,WAAW,GAAW,IAAI,CAAC,GAAL,CAAS,QAAQ,GAAG,KAAK,gBAAL,CAAsB,QAA1C,CAA5B;;AAEA,UAAI,WAAW,GAAG,WAAlB,EAA+B;AAC7B,eAAO,WAAW,CAAC,GAAnB;AACD,OAFD,MAEO,IAAI,WAAW,GAAG,WAAlB,EAA+B;AACpC,eAAO,WAAW,CAAC,GAAnB;AACD,OAFM,MAEA,IAAI,CAAC,KAAK,WAAL,CAAiB,WAAtB,EAAmC;AAC9C;AACM,eAAO,QAAQ,GAAG,KAAK,gBAAL,CAAsB,QAAjC,GAA4C,WAAW,CAAC,GAAxD,GAA8D,WAAW,CAAC,GAAjF;AACD,OAhBL,CAiBA;;;AACI,aAAO,QAAQ,GAAG,KAAK,gBAAL,CAAsB,QAAjC,GAA4C,WAAW,CAAC,GAAxD,GAA8D,WAAW,CAAC,GAAjF;AACJ;AAEC;AAAQ;AAAmB;;;;iCAC5B;AAAA;;AACI;AAAA;AAAM,MAAA,cAAc,GAAY,KAAK,WAAL,CAAiB,cAAjD;;AAEA,UAAI,CAAC,KAAK,WAAL,CAAiB,eAAtB,EAAuC;AACrC,aAAK,mBAAL,CAAyB,EAAzB,CAA4B,WAA5B,EACE,UAAC,KAAD;AAAA,iBAA6B,OAAI,CAAC,UAAL,CAAgB,IAAhB,EAAsB,cAAtB,EAAsC,KAAtC,EAA6C,IAA7C,EAAmD,IAAnD,EAAyD,IAAzD,CAA7B;AAAA,SADF;AAGD;;AAED,UAAI,KAAK,WAAL,CAAiB,kBAArB,EAAyC;AACvC,aAAK,gBAAL,CAAsB,EAAtB,CAAyB,WAAzB,EACE,UAAC,KAAD;AAAA,iBAA6B,OAAI,CAAC,UAAL,CAAgB,WAAW,CAAC,GAA5B,EAAiC,cAAjC,EAAiD,KAAjD,EAAwD,IAAxD,EAA8D,IAA9D,CAA7B;AAAA,SADF;AAGA,aAAK,gBAAL,CAAsB,EAAtB,CAAyB,WAAzB,EACE,UAAC,KAAD;AAAA,iBAA6B,OAAI,CAAC,UAAL,CAAgB,WAAW,CAAC,GAA5B,EAAiC,cAAjC,EAAiD,KAAjD,EAAwD,IAAxD,EAA8D,IAA9D,CAA7B;AAAA,SADF;AAGD,OAPD,MAOO;AACL,aAAK,gBAAL,CAAsB,EAAtB,CAAyB,WAAzB,EACE,UAAC,KAAD;AAAA,iBAA6B,OAAI,CAAC,OAAL,CAAa,WAAW,CAAC,GAAzB,EAA8B,KAA9B,EAAqC,IAArC,EAA2C,IAA3C,CAA7B;AAAA,SADF;;AAIA,YAAI,KAAK,KAAT,EAAgB;AACd,eAAK,gBAAL,CAAsB,EAAtB,CAAyB,WAAzB,EACE,UAAC,KAAD;AAAA,mBAA6B,OAAI,CAAC,OAAL,CAAa,WAAW,CAAC,GAAzB,EAA8B,KAA9B,EAAqC,IAArC,EAA2C,IAA3C,CAA7B;AAAA,WADF;AAGD;;AACD,YAAI,CAAC,KAAK,WAAL,CAAiB,eAAtB,EAAuC;AACrC,eAAK,cAAL,CAAoB,EAApB,CAAuB,WAAvB,EACE,UAAC,KAAD;AAAA,mBAA6B,OAAI,CAAC,OAAL,CAAa,IAAb,EAAmB,KAAnB,EAA0B,IAA1B,EAAgC,IAAhC,EAAsC,IAAtC,CAA7B;AAAA,WADF;AAGA,eAAK,YAAL,CAAkB,EAAlB,CAAqB,WAArB,EACE,UAAC,KAAD;AAAA,mBAA6B,OAAI,CAAC,OAAL,CAAa,IAAb,EAAmB,KAAnB,EAA0B,IAA1B,EAAgC,IAAhC,EAAsC,IAAtC,EAA4C,IAA5C,CAA7B;AAAA,WADF;AAGD;AACF;;AAED,UAAI,CAAC,KAAK,WAAL,CAAiB,eAAtB,EAAuC;AACrC,aAAK,mBAAL,CAAyB,SAAzB,CAAmC,YAAnC,EACE,UAAC,KAAD;AAAA,iBAA6B,OAAI,CAAC,UAAL,CAAgB,IAAhB,EAAsB,cAAtB,EAAsC,KAAtC,EAA6C,IAA7C,EAAmD,IAAnD,EAAyD,IAAzD,CAA7B;AAAA,SADF;AAGD;;AACD,UAAI,KAAK,WAAL,CAAiB,kBAArB,EAAyC;AACvC,aAAK,gBAAL,CAAsB,SAAtB,CAAgC,YAAhC,EACE,UAAC,KAAD;AAAA,iBAA6B,OAAI,CAAC,UAAL,CAAgB,WAAW,CAAC,GAA5B,EAAiC,cAAjC,EAAiD,KAAjD,EAAwD,IAAxD,EAA8D,IAA9D,CAA7B;AAAA,SADF;AAGA,aAAK,gBAAL,CAAsB,SAAtB,CAAgC,YAAhC,EACE,UAAC,KAAD;AAAA,iBAA6B,OAAI,CAAC,UAAL,CAAgB,WAAW,CAAC,GAA5B,EAAiC,cAAjC,EAAiD,KAAjD,EAAwD,IAAxD,EAA8D,IAA9D,CAA7B;AAAA,SADF;AAGD,OAPD,MAOO;AACL,aAAK,gBAAL,CAAsB,SAAtB,CAAgC,YAAhC,EACE,UAAC,KAAD;AAAA,iBAA6B,OAAI,CAAC,OAAL,CAAa,WAAW,CAAC,GAAzB,EAA8B,KAA9B,EAAqC,IAArC,EAA2C,IAA3C,CAA7B;AAAA,SADF;;AAGA,YAAI,KAAK,KAAT,EAAgB;AACd,eAAK,gBAAL,CAAsB,SAAtB,CAAgC,YAAhC,EACE,UAAC,KAAD;AAAA,mBAA6B,OAAI,CAAC,OAAL,CAAa,WAAW,CAAC,GAAzB,EAA8B,KAA9B,EAAqC,IAArC,EAA2C,IAA3C,CAA7B;AAAA,WADF;AAGD;;AACD,YAAI,CAAC,KAAK,WAAL,CAAiB,eAAtB,EAAuC;AACrC,eAAK,cAAL,CAAoB,SAApB,CAA8B,YAA9B,EACE,UAAC,KAAD;AAAA,mBAA6B,OAAI,CAAC,OAAL,CAAa,IAAb,EAAmB,KAAnB,EAA0B,IAA1B,EAAgC,IAAhC,EAAsC,IAAtC,CAA7B;AAAA,WADF;AAGA,eAAK,YAAL,CAAkB,SAAlB,CAA4B,YAA5B,EACE,UAAC,KAAD;AAAA,mBAA6B,OAAI,CAAC,OAAL,CAAa,IAAb,EAAmB,KAAnB,EAA0B,KAA1B,EAAiC,KAAjC,EAAwC,IAAxC,EAA8C,IAA9C,CAA7B;AAAA,WADF;AAGD;AACF;;AAED,UAAI,KAAK,WAAL,CAAiB,eAArB,EAAsC;AACpC,aAAK,gBAAL,CAAsB,EAAtB,CAAyB,OAAzB,EAAkC;AAAA,iBAAY,OAAI,CAAC,cAAL,CAAoB,WAAW,CAAC,GAAhC,CAAZ;AAAA,SAAlC;;AACA,YAAI,KAAK,KAAT,EAAgB;AACd,eAAK,gBAAL,CAAsB,EAAtB,CAAyB,OAAzB,EAAkC;AAAA,mBAAY,OAAI,CAAC,cAAL,CAAoB,WAAW,CAAC,GAAhC,CAAZ;AAAA,WAAlC;AACD;AACF;AACL;AAEC;AAAQ;AAAmB;;;;mCAC5B;AACI,WAAK,iBAAL;AACA,WAAK,gBAAL;;AAFJ,kDAI0B,KAAK,oBAAL,EAJ1B;AAAA;;AAAA;AAII,+DAAmD;AAAA,cAAxC,OAAwC;AACjD,UAAA,OAAO,CAAC,GAAR;AACD;AANL;AAAA;AAAA;AAAA;AAAA;AAOA;AAEC;AAAQ;AAA8B;AAAiC;AAAwB;AAC3E;AAA0B;AAAyC;AAC1E;AACP;;;;+BAHc,W,EAA0B,c,EAAyB,K,EACpE,Q,EAAmB,O,EAAkB,qB,EAAiC,oB,EAD1E;AAEI,UAAI,cAAJ,EAAoB;AAClB,aAAK,WAAL,CAAiB,WAAjB,EAA8B,KAA9B,EAAqC,QAArC,EAA+C,OAA/C;AACD,OAFD,MAEO;AACL,aAAK,OAAL,CAAa,WAAb,EAA0B,KAA1B,EAAiC,QAAjC,EAA2C,OAA3C,EAAoD,qBAApD,EAA2E,oBAA3E;AACD;AACL;AAEC;AAAQ;AACG;AAAwB;AAA2B;AAChD;AAAyC;AAAwC;AAAmB;;;;4BADjG,W,EAA0B,K,EACtC,Q,EAAmB,O,EAAkB,qB,EAAiC,oB,EAD5E;AAAA;;AAEI,MAAA,KAAK,CAAC,eAAN,GAFJ,CAGA;;AACI,UAAI,CAAC,mBAAmB,CAAC,YAApB,CAAiC,KAAjC,CAAD,IAA4C,CAAC,mBAAmB,CAAC,UAArE,EAAiF;AAC/E,QAAA,KAAK,CAAC,cAAN;AACD,OANL,CAOA;AAEG;;;AACC,WAAK,uBAAL;;AAEA,UAAI,WAAW,CAAC,iBAAZ,CAA8B,WAA9B,CAAJ,EAAgD;AAC9C,QAAA,WAAW,GAAG,KAAK,gBAAL,CAAsB,KAAtB,CAAd;AACD;;AAED,WAAK,sBAAL,GAA8B,WAA9B;AAEA;AAAA;AAAM,MAAA,cAAc,GAA0B,KAAK,iBAAL,CAAuB,WAAvB,CAA9C;AACA,MAAA,cAAc,CAAC,MAAf,GAAwB,IAAxB;;AAEA,UAAI,KAAK,WAAL,CAAiB,eAArB,EAAsC;AACpC,QAAA,cAAc,CAAC,KAAf;AACD;;AAED,UAAI,QAAJ,EAAc;AACZ,aAAK,iBAAL;;AAEA;AAAA;AAAM,QAAA,cAAc,GAClB,SADI,cACJ,CAAC,CAAD;AAAA,iBAAoC,OAAI,CAAC,QAAL,CAAc,MAAd,GAAuB,OAAI,CAAC,UAAL,CAAgB,CAAhB,CAAvB,GAA4C,OAAI,CAAC,MAAL,CAAY,CAAZ,CAAhF;AAAA,SADF;;AAGA,YAAI,mBAAmB,CAAC,YAApB,CAAiC,KAAjC,CAAJ,EAA6C;AAC3C,eAAK,mBAAL,GAA2B,KAAK,mBAAL,CAAyB,0BAAzB,CACzB,QADyB,EACf,WADe,EACF,cADE,EACc,KAAK,WAAL,CAAiB,mBAD/B,CAA3B;AAED,SAHD,MAGO;AACL,eAAK,mBAAL,GAA2B,KAAK,mBAAL,CAAyB,mBAAzB,CACzB,QADyB,EACf,WADe,EACF,cADE,EACc,KAAK,WAAL,CAAiB,mBAD/B,CAA3B;AAED;AACF;;AAED,UAAI,OAAJ,EAAa;AACX,aAAK,gBAAL;;AAEA;AAAA;AAAM,QAAA,aAAa,GACjB,SADI,aACJ,CAAC,CAAD;AAAA,iBAAoC,OAAI,CAAC,KAAL,CAAW,CAAX,CAApC;AAAA,SADF;;AAGA,YAAI,mBAAmB,CAAC,YAApB,CAAiC,KAAjC,CAAJ,EAA6C;AAC3C,eAAK,kBAAL,GAA0B,KAAK,mBAAL,CAAyB,0BAAzB,CAAoD,QAApD,EAA8D,UAA9D,EAA0E,aAA1E,CAA1B;AACD,SAFD,MAEO;AACL,eAAK,kBAAL,GAA0B,KAAK,mBAAL,CAAyB,mBAAzB,CAA6C,QAA7C,EAAuD,SAAvD,EAAkE,aAAlE,CAA1B;AACD;AACF;;AAED,WAAK,eAAL,CAAqB,IAArB,CAA0B,KAAK,gBAAL,EAA1B;;AAEA,UAAI,mBAAmB,CAAC,YAApB,CAAiC,KAAjC,KAA2C,CAAC,WAAW,CAAC,iBAAZ;AAA8B;AAAC,MAAA,KAAD,CAAsB,cAApD,CAAhD,EAAqH;AACzH;AACM,YAAI,WAAW,CAAC,iBAAZ,CAA8B,KAAK,OAAnC,CAAJ,EAAiD;AAC/C,eAAK,OAAL;AAAe;AAAC,UAAA,KAAD,CAAsB,cAAtB,CAAqC,CAArC,EAAwC,UAAvD;AACD;AACF,OA5DL,CA6DA;AAEG;AACI;;;AACH,UAAI,qBAAJ,EAA2B;AACzB,aAAK,MAAL,CAAY,KAAZ,EAAmB,IAAnB;AACD;;AAED,UAAI,oBAAJ,EAA0B;AACxB,aAAK,KAAL,CAAW,KAAX;AACD;AACL;AAEC;AAAQ;AACF;AAA4B;AAAmB;;;;2BAArC,K,EAA8B,Q,EAA/C;AACI;AAAA;AAAI,MAAA,kBAAkB,GAAU,IAAhC;;AAEA,UAAI,mBAAmB,CAAC,YAApB,CAAiC,KAAjC,CAAJ,EAA6C;AAC3C;AAAA;AAAM,QAAA,cAAc;AAAc;AAAC,QAAA,KAAD,CAAsB,cAAxD;;AACA,aAAK;AAAA;AAAI,QAAA,CAAC,GAAW,CAArB,EAAwB,CAAC,GAAG,cAAc,CAAC,MAA3C,EAAmD,CAAC,EAApD,EAAwD;AACtD,cAAI,cAAc,CAAC,CAAD,CAAd,CAAkB,UAAlB,KAAiC,KAAK,OAA1C,EAAmD;AACjD,YAAA,kBAAkB,GAAG,cAAc,CAAC,CAAD,CAAnC;AACA;AACD;AACF;;AAED,YAAI,WAAW,CAAC,iBAAZ,CAA8B,kBAA9B,CAAJ,EAAuD;AACrD;AACD;AACF;;AAED;AAAA;AAAM,MAAA,MAAM,GAAW,CAAC,WAAW,CAAC,iBAAZ,CAA8B,kBAA9B,CAAD,GACnB,KAAK,gBAAL,CAAsB,KAAtB,EAA6B,kBAAkB,CAAC,UAAhD,CADmB,GAEnB,KAAK,gBAAL,CAAsB,KAAtB,CAFJ;AAGA;AAAA;AAAI,MAAA,QAAJ;AACA;AAAA;AAAM,MAAA,SAAS,GAAW,KAAK,WAAL,CAAiB,WAAjB,GACpB,KAAK,WAAL,CAAiB,KADG,GAEpB,KAAK,WAAL,CAAiB,IAFvB;AAGA;AAAA;AAAM,MAAA,UAAU,GAAW,KAAK,WAAL,CAAiB,WAAjB,GAA+B,KAAK,WAAL,CAAiB,IAAhD,GAAuD,KAAK,WAAL,CAAiB,KAAnG;;AAEA,UAAI,MAAM,IAAI,CAAd,EAAiB;AACf,QAAA,QAAQ,GAAG,UAAX;AACD,OAFD,MAEO,IAAI,MAAM,IAAI,KAAK,iBAAnB,EAAsC;AAC3C,QAAA,QAAQ,GAAG,SAAX;AACD,OAFM,MAEA;AACL,QAAA,QAAQ,GAAG,KAAK,eAAL,CAAqB,MAArB,CAAX;;AACA,YAAI,QAAQ,IAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,QAA/C,CAAjB,EAA2E;AACzE,UAAA,QAAQ,GAAG,KAAK,SAAL,CAAe,QAAf,EAAyB,KAAK,WAAL,CAAiB,QAA1C,CAAX;AACD,SAFD,MAEO;AACL,UAAA,QAAQ,GAAG,KAAK,SAAL,CAAe,QAAf,CAAX;AACD;AACF;;AACD,WAAK,sBAAL,CAA4B,QAA5B;AACJ;AAEC;AAAQ;AAAwB;AAAmB;;;;0BAApC,K,EAAhB;AACI,UAAI,mBAAmB,CAAC,YAApB,CAAiC,KAAjC,CAAJ,EAA6C;AAC3C;AAAA;AAAM,QAAA,cAAc;AAAc;AAAC,QAAA,KAAD,CAAsB,cAAxD;;AACA,YAAI,cAAc,CAAC,CAAD,CAAd,CAAkB,UAAlB,KAAiC,KAAK,OAA1C,EAAmD;AACjD;AACD;AACF;;AAED,WAAK,OAAL,GAAe,IAAf;;AAEA,UAAI,CAAC,KAAK,WAAL,CAAiB,eAAtB,EAAuC;AACrC,aAAK,gBAAL,CAAsB,MAAtB,GAA+B,KAA/B;AACA,aAAK,gBAAL,CAAsB,MAAtB,GAA+B,KAA/B;AACA,aAAK,sBAAL,GAA8B,IAA9B;AACD;;AACD,WAAK,QAAL,CAAc,MAAd,GAAuB,KAAvB;AAEA,WAAK,iBAAL;AACA,WAAK,gBAAL;AAEA,WAAK,aAAL,CAAmB,IAAnB,CAAwB,KAAK,gBAAL,EAAxB;AACJ;AAEC;AAAQ;AAA8B;AAAmB;;;;mCAAjC,W,EAAzB;AAAA;;AACI;AAAA;AAAM,MAAA,cAAc,GAA0B,KAAK,iBAAL,CAAuB,WAAvB,CAA9C;AACA,MAAA,cAAc,CAAC,EAAf,CAAkB,MAAlB,EAA0B;AAAA,eAAY,OAAI,CAAC,aAAL,CAAmB,cAAnB,CAAZ;AAAA,OAA1B;AACA,MAAA,cAAc,CAAC,EAAf,CAAkB,SAAlB,EAA6B,UAAC,KAAD;AAAA,eAAgC,OAAI,CAAC,eAAL,CAAqB,KAArB,CAAhC;AAAA,OAA7B;AACA,MAAA,cAAc,CAAC,EAAf,CAAkB,OAAlB,EAA2B;AAAA,eAAY,OAAI,CAAC,OAAL,EAAZ;AAAA,OAA3B;AACA,MAAA,cAAc,CAAC,MAAf,GAAwB,IAAxB;AAEA,WAAK,sBAAL,GAA8B,WAA9B;AACA,WAAK,mBAAL,GAA2B,WAA3B;AACA,WAAK,YAAL,GAAoB,IAApB;AACJ;AAEC;AAAQ;AACT;;;;8BADA;AACI,WAAK,YAAL,GAAoB,IAApB;AACA,WAAK,aAAL,CAAmB,IAAnB,CAAwB,KAAK,gBAAL,EAAxB;AACJ;AAEC;AAAQ;AAA0B;AAAmB;;;;kCAA9B,O,EAAxB;AACI,MAAA,OAAO,CAAC,GAAR,CAAY,MAAZ;AACA,MAAA,OAAO,CAAC,GAAR,CAAY,SAAZ;AACA,MAAA,OAAO,CAAC,GAAR,CAAY,OAAZ;AACA,MAAA,OAAO,CAAC,MAAR,GAAiB,KAAjB;;AACA,UAAI,WAAW,CAAC,iBAAZ,CAA8B,KAAK,OAAnC,CAAJ,EAAiD;AAC/C,aAAK,sBAAL,GAA8B,IAA9B;AACA,aAAK,mBAAL,GAA2B,IAA3B;AACD;AACL;AAEC;AAAQ;AAA+B;AAAmB;;;;kCAAnC,Y,EAAxB;AACI;AAAA;AAAM,MAAA,UAAU,GAAW,KAAK,WAAL,CAAiB,IAAjB,GAAwB,KAAK,WAAL,CAAiB,KAApE;AAEA;AAAA;AAAI,MAAA,YAAY,GAAW,YAAY,GAAG,KAAK,WAAL,CAAiB,IAA3D;AACA;AAAA;AAAI,MAAA,YAAY,GAAW,YAAY,GAAG,KAAK,WAAL,CAAiB,IAA3D;AACA;AAAA;AAAI,MAAA,YAAY,GAAW,YAAY,GAAG,UAAU,GAAG,EAAvD;AACA;AAAA;AAAI,MAAA,YAAY,GAAW,YAAY,GAAG,UAAU,GAAG,EAAvD;;AAEA,UAAI,KAAK,WAAL,CAAiB,gBAArB,EAAuC;AACrC,QAAA,YAAY,GAAG,YAAY,GAAG,KAAK,WAAL,CAAiB,IAA/C;AACA,QAAA,YAAY,GAAG,YAAY,GAAG,KAAK,WAAL,CAAiB,IAA/C;AACA,QAAA,YAAY,GAAG,YAAY,GAAG,UAAU,GAAG,EAA3C;AACA,QAAA,YAAY,GAAG,YAAY,GAAG,UAAU,GAAG,EAA3C;AACD,OAbL,CAcA;;;AAEI;AAAA;AAAM,MAAA,OAAO,GAA4B;AACvC,QAAA,EAAE,EAAE,YADmC;AAEvC,QAAA,IAAI,EAAE,YAFiC;AAGvC,QAAA,IAAI,EAAE,YAHiC;AAIvC,QAAA,KAAK,EAAE,YAJgC;AAKvC,QAAA,MAAM,EAAE,YAL+B;AAMvC,QAAA,QAAQ,EAAE,YAN6B;AAOvC,QAAA,IAAI,EAAE,KAAK,WAAL,CAAiB,gBAAjB,GAAoC,KAAK,WAAL,CAAiB,IAArD,GAA4D,KAAK,WAAL,CAAiB,KAP5C;AAQvC,QAAA,GAAG,EAAE,KAAK,WAAL,CAAiB,gBAAjB,GAAoC,KAAK,WAAL,CAAiB,KAArD,GAA6D,KAAK,WAAL,CAAiB;AAR5C,OAAzC,CAhBJ,CA0BA;;AACI,UAAI,KAAK,WAAL,CAAiB,WAArB,EAAkC;AAChC,QAAA,OAAO,CAAb,MAAa,CAAP,GAAe,YAAf;AACA,QAAA,OAAO,CAAb,OAAa,CAAP,GAAgB,YAAhB,CAFgC,CAGtC;;AACM,YAAI,KAAK,WAAL,CAAiB,QAArB,EAA+B;AAC7B,UAAA,OAAO,CAAf,IAAe,CAAP,GAAa,YAAb;AACA,UAAA,OAAO,CAAf,MAAe,CAAP,GAAe,YAAf;AACD;AACF;;AACD,aAAO,OAAP;AACJ;AAEC;AAAQ;AAAwB;AAAmB;;;;oCAA1B,K,EAA1B;AACI;AAAA;AAAM,MAAA,YAAY,GAAW,KAAK,uBAAL,EAA7B;AACA;AAAA;AAAM,MAAA,OAAO,GAAW,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,CAAC,OAApC,CAAD,GACpB,KAAK,CAAC,OADc,GAEpB,KAAK,CAAC,KAFV;AAGA;AAAA;AAAM,MAAA,IAAI,GAAgC;AACtC,YAAI,IADkC;AAEtC,YAAI,MAFkC;AAGtC,YAAI,MAHkC;AAItC,YAAI,OAJkC;AAKtC,YAAI,QALkC;AAMtC,YAAI,UANkC;AAOtC,YAAI,MAPkC;AAQtC,YAAI;AARkC,OAA1C;AAUA;AAAA;AAAM,MAAA,OAAO,GAA4B,KAAK,aAAL,CAAmB,YAAnB,CAAzC;AACA;AAAA;AAAM,MAAA,GAAG,GAAW,IAAI,CAAC,OAAD,CAAxB;AACA;AAAA;AAAM,MAAA,MAAM,GAAW,OAAO,CAAC,GAAD,CAA9B;;AAEA,UAAI,WAAW,CAAC,iBAAZ,CAA8B,MAA9B,KAAyC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,sBAAnC,CAA7C,EAAyG;AACvG;AACD;;AACD,MAAA,KAAK,CAAC,cAAN;;AAEA,UAAI,KAAK,YAAT,EAAuB;AACrB,aAAK,YAAL,GAAoB,KAApB;AACA,aAAK,eAAL,CAAqB,IAArB,CAA0B,KAAK,gBAAL,EAA1B;AACD;;AAED;AAAA;AAAM,MAAA,WAAW,GAAW,UAAU,CAAC,YAAX,CAAwB,MAAxB,EAAgC,KAAK,WAAL,CAAiB,KAAjD,EAAwD,KAAK,WAAL,CAAiB,IAAzE,CAA5B;AACA;AAAA;AAAM,MAAA,QAAQ,GAAW,KAAK,SAAL,CAAe,WAAf,CAAzB;;AACA,UAAI,CAAC,KAAK,WAAL,CAAiB,kBAAtB,EAA0C;AACxC,aAAK,sBAAL,CAA4B,QAA5B;AACD,OAFD,MAEO;AACL;AAAA;AAAM,QAAA,UAAU,GAAW,KAAK,aAAL,GAAqB,KAAK,YAArD;AACA;AAAA;AAAI,QAAA,WAAJ;AACA;AAAA;AAAI,QAAA,WAAJ;;AAEA,YAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAAhD,EAAqD;AACnD,UAAA,WAAW,GAAG,QAAd;AACA,UAAA,WAAW,GAAG,QAAQ,GAAG,UAAzB;;AACA,cAAI,WAAW,GAAG,KAAK,WAAL,CAAiB,IAAnC,EAAyC;AACvC,YAAA,WAAW,GAAG,KAAK,WAAL,CAAiB,IAA/B;AACA,YAAA,WAAW,GAAG,WAAW,GAAG,UAA5B;AACD;AACF,SAPD,MAOO,IAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAAhD,EAAqD;AAC1D,UAAA,WAAW,GAAG,QAAd;AACA,UAAA,WAAW,GAAG,QAAQ,GAAG,UAAzB;;AACA,cAAI,WAAW,GAAG,KAAK,WAAL,CAAiB,KAAnC,EAA0C;AACxC,YAAA,WAAW,GAAG,KAAK,WAAL,CAAiB,KAA/B;AACA,YAAA,WAAW,GAAG,WAAW,GAAG,UAA5B;AACD;AACF;;AACD,aAAK,mBAAL,CAAyB,WAAzB,EAAsC,WAAtC;AACD;AACL;AAEC;AAAQ;AAA8B;AAAwB;AACxC;AAA0B;AAAmB;;;;gCAA9C,W,EAA0B,K,EAC5C,Q,EAAmB,O,EADvB;AAEI;AAAA;AAAM,MAAA,QAAQ,GAAW,KAAK,gBAAL,CAAsB,KAAtB,CAAzB;AAEA,WAAK,QAAL,GAAgB,IAAI,QAAJ,EAAhB;AACA,WAAK,QAAL,CAAc,MAAd,GAAuB,IAAvB;AACA,WAAK,QAAL,CAAc,KAAd,GAAsB,KAAK,eAAL,CAAqB,QAArB,CAAtB;AACA,WAAK,QAAL,CAAc,UAAd,GAA2B,KAAK,aAAL,GAAqB,KAAK,YAArD;AACA,WAAK,QAAL,CAAc,QAAd,GAAyB,KAAK,WAAL,CAAiB,WAAjB,GACnB,KAAK,gBAAL,CAAsB,QAAtB,GAAiC,QADd,GAEnB,QAAQ,GAAG,KAAK,gBAAL,CAAsB,QAFvC;AAGA,WAAK,QAAL,CAAc,SAAd,GAA0B,KAAK,WAAL,CAAiB,WAAjB,GACpB,QAAQ,GAAG,KAAK,gBAAL,CAAsB,QADb,GAEpB,KAAK,gBAAL,CAAsB,QAAtB,GAAiC,QAFvC;AAIA,WAAK,OAAL,CAAa,WAAb,EAA0B,KAA1B,EAAiC,QAAjC,EAA2C,OAA3C;AACJ;AAEC;AAAQ;AACF;AAAyB;AAA8B;AAC9D;AAAmB;;;;gCADG,M,EAAgB,W,EAAsB,O,EAA5D;AACI;AAAA;AAAM,MAAA,KAAK,GAAY,KAAK,WAAL,CAAiB,WAAxC;AACA;AAAA;AAAI,MAAA,KAAK,GAAW,IAApB;;AAEA,UAAI,WAAJ,EAAiB;AACf,YAAI,OAAJ,EAAa;AACX,UAAA,KAAK,GAAG,KAAK,GACT,KAAK,WAAL,CAAiB,KADR,GAET,KAAK,WAAL,CAAiB,IAAjB,GAAwB,KAAK,QAAL,CAAc,UAF1C;AAGD,SAJD,MAIO;AACL,UAAA,KAAK,GAAG,KAAK,GACT,KAAK,WAAL,CAAiB,IAAjB,GAAwB,KAAK,QAAL,CAAc,UAD7B,GAET,KAAK,WAAL,CAAiB,KAFrB;AAGD;AACF,OAVD,MAUO;AACL,QAAA,KAAK,GAAG,KAAK,GACT,KAAK,eAAL,CAAqB,MAAM,GAAG,KAAK,QAAL,CAAc,QAA5C,CADS,GAET,KAAK,eAAL,CAAqB,MAAM,GAAG,KAAK,QAAL,CAAc,QAA5C,CAFJ;AAGD;;AACD,aAAO,KAAK,SAAL,CAAe,KAAf,CAAP;AACJ;AAEC;AAAQ;AACF;AAAyB;AAA8B;AAC9D;AAAmB;;;;gCADG,M,EAAgB,W,EAAsB,O,EAA5D;AACI;AAAA;AAAM,MAAA,KAAK,GAAY,KAAK,WAAL,CAAiB,WAAxC;AACA;AAAA;AAAI,MAAA,KAAK,GAAW,IAApB;;AAEA,UAAI,WAAJ,EAAiB;AACf,YAAI,OAAJ,EAAa;AACX,UAAA,KAAK,GAAG,KAAK,GACT,KAAK,WAAL,CAAiB,KAAjB,GAAyB,KAAK,QAAL,CAAc,UAD9B,GAET,KAAK,WAAL,CAAiB,IAFrB;AAGD,SAJD,MAIO;AACL,UAAA,KAAK,GAAG,KAAK,GACT,KAAK,WAAL,CAAiB,IADR,GAET,KAAK,WAAL,CAAiB,KAAjB,GAAyB,KAAK,QAAL,CAAc,UAF3C;AAGD;AACF,OAVD,MAUO;AACL,YAAI,KAAJ,EAAW;AACT,UAAA,KAAK,GACH,KAAK,eAAL,CAAqB,MAAM,GAAG,KAAK,QAAL,CAAc,QAA5C,IACA,KAAK,QAAL,CAAc,UAFhB;AAGD,SAJD,MAIO;AACL,UAAA,KAAK,GACH,KAAK,eAAL,CAAqB,MAAM,GAAG,KAAK,QAAL,CAAc,QAA5C,IACA,KAAK,QAAL,CAAc,UAFhB;AAGD;AACF;;AAED,aAAO,KAAK,SAAL,CAAe,KAAf,CAAP;AACJ;AAEC;AAAQ;AAAyB;AAAmB;;;;+BAAhC,K,EAArB;AACI;AAAA;AAAM,MAAA,MAAM,GAAW,KAAK,gBAAL,CAAsB,KAAtB,CAAvB;AAEA;AAAA;AAAI,MAAA,SAAJ;AAAqB;AACjB,MAAA,UADJ;AACsB;AAClB,MAAA,kBAFJ;AAE6C;AACzC,MAAA,iBAHJ;;AAIA,UAAI,KAAK,WAAL,CAAiB,WAArB,EAAkC;AAChC,QAAA,SAAS,GAAG,KAAK,QAAL,CAAc,QAA1B;AACA,QAAA,UAAU,GAAG,KAAK,QAAL,CAAc,SAA3B;AACA,QAAA,kBAAkB,GAAG,KAAK,gBAA1B;AACA,QAAA,iBAAiB,GAAG,KAAK,gBAAzB;AACD,OALD,MAKO;AACL,QAAA,SAAS,GAAG,KAAK,QAAL,CAAc,SAA1B;AACA,QAAA,UAAU,GAAG,KAAK,QAAL,CAAc,QAA3B;AACA,QAAA,kBAAkB,GAAG,KAAK,gBAA1B;AACA,QAAA,iBAAiB,GAAG,KAAK,gBAAzB;AACD;;AAED;AAAA;AAAM,MAAA,iBAAiB,GAAa,MAAM,IAAI,UAA9C;AACA;AAAA;AAAM,MAAA,eAAe,GAAa,MAAM,IAAI,KAAK,iBAAL,GAAyB,SAArE;AAEA;AAAA;AAAI,MAAA,WAAJ;AACA;AAAA;AAAI,MAAA,WAAJ;;AACA,UAAI,iBAAJ,EAAuB;AACrB,YAAI,kBAAkB,CAAC,QAAnB,KAAgC,CAApC,EAAuC;AACrC;AACD;;AACD,QAAA,WAAW,GAAG,KAAK,WAAL,CAAiB,MAAjB,EAAyB,IAAzB,EAA+B,KAA/B,CAAd;AACA,QAAA,WAAW,GAAG,KAAK,WAAL,CAAiB,MAAjB,EAAyB,IAAzB,EAA+B,KAA/B,CAAd;AACD,OAND,MAMO,IAAI,eAAJ,EAAqB;AAC1B,YAAI,iBAAiB,CAAC,QAAlB,KAA+B,KAAK,iBAAxC,EAA2D;AACzD;AACD;;AACD,QAAA,WAAW,GAAG,KAAK,WAAL,CAAiB,MAAjB,EAAyB,IAAzB,EAA+B,IAA/B,CAAd;AACA,QAAA,WAAW,GAAG,KAAK,WAAL,CAAiB,MAAjB,EAAyB,IAAzB,EAA+B,IAA/B,CAAd;AACD,OANM,MAMA;AACL,QAAA,WAAW,GAAG,KAAK,WAAL,CAAiB,MAAjB,EAAyB,KAAzB,EAAgC,KAAhC,CAAd;AACA,QAAA,WAAW,GAAG,KAAK,WAAL,CAAiB,MAAjB,EAAyB,KAAzB,EAAgC,KAAhC,CAAd;AACD;;AAED,WAAK,mBAAL,CAAyB,WAAzB,EAAsC,WAAtC;AACJ;AAEC;AAAQ;AAA8B;AACzB;AAAmB;;;;wCAAH,W,EAAqB,W,EAAnD;AACI,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,QAA/C,CAAD,IACA,WAAW,GAAG,KAAK,WAAL,CAAiB,QADnC,EAC6C;AAC3C,QAAA,WAAW,GAAG,KAAK,WAAL,CAAiB,QAA/B;AACA,QAAA,WAAW,GAAG,UAAU,CAAC,qBAAX,CAAiC,WAAW,GAAG,KAAK,QAAL,CAAc,UAA7D,EAAyE,KAAK,WAAL,CAAiB,cAA1F,CAAd;AACD;;AACD,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,QAA/C,CAAD,IACA,WAAW,GAAG,KAAK,WAAL,CAAiB,QADnC,EAC6C;AAC3C,QAAA,WAAW,GAAG,KAAK,WAAL,CAAiB,QAA/B;AACA,QAAA,WAAW,GAAG,UAAU,CAAC,qBAAX,CAAiC,WAAW,GAAG,KAAK,QAAL,CAAc,UAA7D,EAAyE,KAAK,WAAL,CAAiB,cAA1F,CAAd;AACD;;AAED,WAAK,YAAL,GAAoB,WAApB;AACA,WAAK,aAAL,GAAqB,WAArB;AACA,WAAK,eAAL;AACA,WAAK,aAAL,CAAmB,WAAW,CAAC,GAA/B,EAAoC,KAAK,eAAL,CAAqB,WAArB,CAApC;AACA,WAAK,aAAL,CAAmB,WAAW,CAAC,GAA/B,EAAoC,KAAK,eAAL,CAAqB,WAArB,CAApC;AACJ;AAEC;AAAQ;AAA2B;AAAmB;;;;2CACtB,Q,EAAjC;AACI,MAAA,QAAQ,GAAG,KAAK,gBAAL,CAAsB,QAAtB,CAAX;;AACA,UAAI,KAAK,KAAT,EAAgB;AACd,YAAI,KAAK,WAAL,CAAiB,SAArB,EAAgC;AAC9B,UAAA,QAAQ,GAAG,KAAK,cAAL,CAAoB,QAApB,CAAX;AACD,SAFD,MAEO;AACL,cAAI,KAAK,WAAL,CAAiB,WAArB,EAAkC;AAChC,gBAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAA5C,IACA,QAAQ,GAAG,KAAK,aADpB,EACmC;AACjC,cAAA,QAAQ,GAAG,KAAK,gBAAL,CAAsB,KAAK,aAA3B,CAAX;AACD,aAHD,MAGO,IAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAA5C,IACA,QAAQ,GAAG,KAAK,YADpB,EACkC;AACvC,cAAA,QAAQ,GAAG,KAAK,gBAAL,CAAsB,KAAK,YAA3B,CAAX;AACD;AACF;;AACD,UAAA,QAAQ,GAAG,KAAK,gBAAL,CAAsB,QAAtB,CAAX;AACR;;AACQ,cAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAA5C,IAAmD,QAAQ,GAAG,KAAK,aAAvE,EAAsF;AACpF,iBAAK,YAAL,GAAoB,KAAK,aAAzB;AACA,iBAAK,eAAL;AACA,iBAAK,aAAL,CAAmB,WAAW,CAAC,GAA/B,EAAoC,KAAK,gBAAL,CAAsB,QAA1D;AACA,iBAAK,oBAAL;AACA,iBAAK,sBAAL,GAA8B,WAAW,CAAC,GAA1C;AACA,iBAAK,gBAAL,CAAsB,MAAtB,GAA+B,KAA/B;AACA,iBAAK,gBAAL,CAAsB,MAAtB,GAA+B,IAA/B;;AACA,gBAAI,KAAK,WAAL,CAAiB,eAArB,EAAsC;AACpC,mBAAK,gBAAL,CAAsB,KAAtB;AACD;AACF,WAXD,MAWO,IAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAA5C,IACA,QAAQ,GAAG,KAAK,YADpB,EACkC;AACvC,iBAAK,aAAL,GAAqB,KAAK,YAA1B;AACA,iBAAK,eAAL;AACA,iBAAK,aAAL,CAAmB,WAAW,CAAC,GAA/B,EAAoC,KAAK,gBAAL,CAAsB,QAA1D;AACA,iBAAK,oBAAL;AACA,iBAAK,sBAAL,GAA8B,WAAW,CAAC,GAA1C;AACA,iBAAK,gBAAL,CAAsB,MAAtB,GAA+B,KAA/B;AACA,iBAAK,gBAAL,CAAsB,MAAtB,GAA+B,IAA/B;;AACA,gBAAI,KAAK,WAAL,CAAiB,eAArB,EAAsC;AACpC,mBAAK,gBAAL,CAAsB,KAAtB;AACD;AACF;AACF;AACF;;AAED,UAAI,KAAK,uBAAL,OAAmC,QAAvC,EAAiD;AAC/C,YAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAAhD,EAAqD;AACnD,eAAK,YAAL,GAAoB,QAApB;AACA,eAAK,eAAL;AACD,SAHD,MAGO,IAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAAhD,EAAqD;AAC1D,eAAK,aAAL,GAAqB,QAArB;AACA,eAAK,eAAL;AACD;;AACD,aAAK,aAAL,CAAmB,KAAK,sBAAxB,EAAgD,KAAK,eAAL,CAAqB,QAArB,CAAhD;AACA,aAAK,oBAAL;AACD;AACL;AAEC;AAAQ;AAA2B;AACpC;;;;qCAD2B,Q,EAA3B;AACI,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,QAA/C,CAAD,IAA6D,QAAQ,GAAG,KAAK,WAAL,CAAiB,QAA7F,EAAuG;AACrG,eAAO,KAAK,WAAL,CAAiB,QAAxB;AACD;;AACD,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,QAA/C,CAAD,IAA6D,QAAQ,GAAG,KAAK,WAAL,CAAiB,QAA7F,EAAuG;AACrG,eAAO,KAAK,WAAL,CAAiB,QAAxB;AACD;;AACD,aAAO,QAAP;AACJ;AAEC;AAAQ;AAA2B;AACpC;;;;qCAD2B,Q,EAA3B;AACI;AAAA;AAAM,MAAA,aAAa,GAAY,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAA7C,GAC1B,KAAK,aADqB,GAE1B,KAAK,YAFT;AAGA;AAAA;AAAM,MAAA,UAAU,GAAW,IAAI,CAAC,GAAL,CAAS,QAAQ,GAAG,aAApB,CAA3B;;AACA,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,QAA/C,CAAL,EAA+D;AAC7D,YAAI,UAAU,GAAG,KAAK,WAAL,CAAiB,QAAlC,EAA4C;AAC1C,cAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAAhD,EAAqD;AACnD,mBAAO,UAAU,CAAC,qBAAX,CAAiC,KAAK,aAAL,GAAqB,KAAK,WAAL,CAAiB,QAAvE,EAAiF,KAAK,WAAL,CAAiB,cAAlG,CAAP;AACD,WAFD,MAEO,IAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAAhD,EAAqD;AAC1D,mBAAO,UAAU,CAAC,qBAAX,CAAiC,KAAK,YAAL,GAAoB,KAAK,WAAL,CAAiB,QAAtE,EAAgF,KAAK,WAAL,CAAiB,cAAjG,CAAP;AACD;AACF;AACF;;AACD,UAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,QAA/C,CAAL,EAA+D;AAC7D,YAAI,UAAU,GAAG,KAAK,WAAL,CAAiB,QAAlC,EAA4C;AAC1C,cAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAAhD,EAAqD;AACnD,mBAAO,UAAU,CAAC,qBAAX,CAAiC,KAAK,aAAL,GAAqB,KAAK,WAAL,CAAiB,QAAvE,EAAiF,KAAK,WAAL,CAAiB,cAAlG,CAAP;AACD,WAFD,MAEO,IAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAAhD,EAAqD;AAC1D,mBAAO,UAAU,CAAC,qBAAX,CAAiC,KAAK,YAAL,GAAoB,KAAK,WAAL,CAAiB,QAAtE,EAAgF,KAAK,WAAL,CAAiB,cAAjG,CAAP;AACD;AACF;AACF;;AACD,aAAO,QAAP;AACJ;AAEC;AAAQ;AAA2B;AAClC;;;;mCADuB,Q,EAAzB;AACI;AAAA;AAAM,MAAA,UAAU,GAAY,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAA7C,GACnB,KAAK,aAAL,GAAqB,QADF,GAEnB,QAAQ,GAAG,KAAK,YAFxB;AAGA;AAAA;AAAM,MAAA,QAAQ,GAAY,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,WAAL,CAAiB,QAA/C,CAAF,GACjB,KAAK,WAAL,CAAiB,QADA,GAEjB,KAAK,WAAL,CAAiB,IAFzB;AAGA;AAAA;AAAM,MAAA,QAAQ,GAAW,KAAK,WAAL,CAAiB,QAA1C,CAPJ,CAQA;;AACI,UAAI,UAAU,GAAG,QAAjB,EAA2B;AACzB,YAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAAhD,EAAqD;AACnD,eAAK,aAAL,GAAqB,UAAU,CAAC,qBAAX,CACnB,IAAI,CAAC,GAAL,CAAS,QAAQ,GAAG,QAApB,EAA8B,KAAK,WAAL,CAAiB,IAA/C,CADmB,EACmC,KAAK,WAAL,CAAiB,cADpD,CAArB;AAEA,UAAA,QAAQ,GAAG,UAAU,CAAC,qBAAX,CAAiC,KAAK,aAAL,GAAqB,QAAtD,EAAgE,KAAK,WAAL,CAAiB,cAAjF,CAAX;AACA,eAAK,eAAL;AACA,eAAK,aAAL,CAAmB,WAAW,CAAC,GAA/B,EAAoC,KAAK,eAAL,CAAqB,KAAK,aAA1B,CAApC;AACD,SAND,MAMO,IAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAAhD,EAAqD;AAC1D,eAAK,YAAL,GAAoB,UAAU,CAAC,qBAAX,CAClB,IAAI,CAAC,GAAL,CAAS,QAAQ,GAAG,QAApB,EAA8B,KAAK,WAAL,CAAiB,KAA/C,CADkB,EACqC,KAAK,WAAL,CAAiB,cADtD,CAApB;AAEA,UAAA,QAAQ,GAAG,UAAU,CAAC,qBAAX,CAAiC,KAAK,YAAL,GAAoB,QAArD,EAA+D,KAAK,WAAL,CAAiB,cAAhF,CAAX;AACA,eAAK,eAAL;AACA,eAAK,aAAL,CAAmB,WAAW,CAAC,GAA/B,EAAoC,KAAK,eAAL,CAAqB,KAAK,YAA1B,CAApC;AACD;;AACD,aAAK,oBAAL;AACD,OAfD,MAeO,IAAI,CAAC,WAAW,CAAC,iBAAZ,CAA8B,QAA9B,CAAD,IAA4C,UAAU,GAAG,QAA7D,EAAuE;AAClF;AACM,YAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAAhD,EAAqD;AACnD,eAAK,aAAL,GAAqB,UAAU,CAAC,qBAAX,CAAiC,QAAQ,GAAG,QAA5C,EAAsD,KAAK,WAAL,CAAiB,cAAvE,CAArB;AACA,eAAK,eAAL;AACA,eAAK,aAAL,CAAmB,WAAW,CAAC,GAA/B,EAAoC,KAAK,eAAL,CAAqB,KAAK,aAA1B,CAApC;AAED,SALD,MAKO,IAAI,KAAK,sBAAL,KAAgC,WAAW,CAAC,GAAhD,EAAqD;AAC1D,eAAK,YAAL,GAAoB,UAAU,CAAC,qBAAX,CAAiC,QAAQ,GAAG,QAA5C,EAAsD,KAAK,WAAL,CAAiB,cAAvE,CAApB;AACA,eAAK,eAAL;AACA,eAAK,aAAL,CAAmB,WAAW,CAAC,GAA/B,EAAoC,KAAK,eAAL,CAAqB,KAAK,YAA1B,CAApC;AACD;;AACD,aAAK,oBAAL;AACD;;AACD,aAAO,QAAP;AACJ;AAEC;AAAQ;AAAmB;;;;uCAA5B;AACI;AAAA;AAAM,MAAA,aAAa,GAAkB,IAAI,aAAJ,EAArC;AACA,MAAA,aAAa,CAAC,WAAd,GAA4B,KAAK,sBAAjC;AACA,MAAA,aAAa,CAAC,KAAd,GAAsB,CAAC,KAAK,KAA5B;;AACA,UAAI,KAAK,KAAT,EAAgB;AACd,QAAA,aAAa,CAAC,SAAd,GAA0B,CAAC,KAAK,SAAhC;AACD;;AACD,aAAO,aAAP;AACJ;;;sBAhjE6B,a,EAA7B;AAAA;;AACI,WAAK,wBAAL;AAEA,WAAK,yBAAL,GAAiC,aAAa,CAAC,SAAd,CAAwB,YAA7D;AACM,QAAA,UAAU,CAAC;AAAA,iBAAM,OAAI,CAAC,uCAAL,EAAN;AAAA,SAAD,CAAV;AACD,OAFgC,CAAjC;AAGJ;AAEC;AAAQ;AAA+B;AACtB;;;;sBACU,Y,EAA5B;AAAA;;AACI,WAAK,uBAAL;AAEA,WAAK,wBAAL,GAAgC,YAAY,CAAC,SAAb,CAAuB,UAAC,WAAD,EAA3D;AACM,QAAA,OAAI,CAAC,YAAL,CAAkB,WAAlB;AACD,OAF+B,CAAhC;AAGJ;AAEC;AAAQ;AAAmB;;;;wBAC5B;AACI,aAAO,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,KAAnC,CAAD,IAA8C,CAAC,WAAW,CAAC,iBAAZ,CAA8B,KAAK,SAAnC,CAAtD;AACJ;AAEC;AAAQ;AAAmB;;;;wBA2G5B;AACI,aAAO,KAAK,WAAL,CAAiB,SAAxB;AACJ;;;;;;gCAnNA,uB,CAAA,C,EAAA;AAAW,SAAA,KAAA,CAAA,IAAA,eAAA,EACC,MAAY,CAAA,iBAAZ,CACV,MAAA,CAAF,SADY,CADD,EAEX,MAAA,CAAA,iBAAA,CAAA,MAAA,CAAA,UAAA,CAFW,EAEX,MAAA,CAAA,iBAAA,CAAA,MAAA,CAAA,iBAAA,CAFW,EAEX,MAAA,CAAA,iBAAA,CAAA,MAAA,CAAA,MAAA,CAFW,CAAA;AAEX,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WAsCA,O;AAAQ,IAAA,SAAA,EAAA,W;AACR,IAAA,OAAA,EAAA,S;AAAA,IAAA,aAAA,EAAA,e;AAAA,IAAA,YAAA,EAAA;;AAAA,EAAA,OAAA,EAAA;AAAA,IAAA,WAAA,EAAA,aAAA;AAAA,IAAA,eAAA,EAAA,iBAAA;AAAA,IAAA,eAAA,EAAA,iBAAA;AAAA,IAAA,UAAA,EAAA,YAAA;AAAA,IAAA,aAAA,EAAA;AAAA,G;AAAA,EAAA,QAAA,EAAA,CAAA,MAAA,CAAA,kBAAA,CAAA,CAAA,iCAAA,CAAA,CAAA,EAAA,MAAA,CAAA,oBAAA,C;AAAA,EAAA,KAAA,EAAA,E;AAAA,EAAA,IAAA,EAAA,E;AAAA,EAAA,MAAA,EAAA,CAAA,CAAA,kBAAA,EAAA,EAAA,EAAA,CAAA,EAAA,iBAAA,EAAA,wBAAA,EAAA,+BAAA,CAAA,EAAA,CAAA,uBAAA,EAAA,EAAA,CAAA,EAAA,CAAA,CAAA,EAAA,iBAAA,EAAA,gBAAA,CAAA,EAAA,CAAA,kBAAA,EAAA,EAAA,EAAA,CAAA,EAAA,iBAAA,EAAA,wBAAA,EAAA,gCAAA,CAAA,EAAA,CAAA,wBAAA,EAAA,EAAA,CAAA,EAAA,CAAA,kBAAA,EAAA,EAAA,EAAA,CAAA,EAAA,iBAAA,EAAA,wBAAA,EAAA,qBAAA,CAAA,EAAA,CAAA,SAAA,EAAA,EAAA,CAAA,EAAA,CAAA,kBAAA,EAAA,EAAA,EAAA,CAAA,EAAA,iBAAA,EAAA,wBAAA,EAAA,0BAAA,CAAA,EAAA,CAAA,cAAA,EAAA,EAAA,CAAA,EAAA,CAAA,CAAA,EAAA,iBAAA,EAAA,gBAAA,EAAA,sBAAA,EAAA,CAAA,EAAA,SAAA,CAAA,EAAA,CAAA,iBAAA,EAAA,EAAA,EAAA,CAAA,EAAA,iBAAA,EAAA,oBAAA,EAAA,wBAAA,EAAA,CAAA,EAAA,SAAA,CAAA,EAAA,CAAA,WAAA,EAAA,EAAA,CAAA,EAAA,CAAA,iBAAA,EAAA,EAAA,EAAA,CAAA,EAAA,iBAAA,EAAA,oBAAA,EAAA,wBAAA,EAAA,CAAA,EAAA,SAAA,CAAA,EAAA,CAAA,WAAA,EAAA,EAAA,CAAA,EAAA,CAAA,gBAAA,EAAA,EAAA,EAAA,CAAA,EAAA,iBAAA,EAAA,mBAAA,EAAA,kBAAA,EAAA,kBAAA,CAAA,EAAA,CAAA,YAAA,EAAA,EAAA,CAAA,EAAA,CAAA,gBAAA,EAAA,EAAA,EAAA,CAAA,EAAA,iBAAA,EAAA,mBAAA,EAAA,kBAAA,EAAA,iBAAA,CAAA,EAAA,CAAA,WAAA,EAAA,EAAA,CAAA,EAAA,CAAA,gBAAA,EAAA,EAAA,EAAA,CAAA,EAAA,iBAAA,EAAA,mBAAA,EAAA,wBAAA,CAAA,EAAA,CAAA,gBAAA,EAAA,EAAA,CAAA,EAAA,CAAA,gBAAA,EAAA,EAAA,EAAA,CAAA,EAAA,iBAAA,EAAA,mBAAA,EAAA,uBAAA,CAAA,EAAA,CAAA,gBAAA,EAAA,EAAA,CAAA,EAAA,CAAA,gBAAA,EAAA,EAAA,EAAA,CAAA,EAAA,iBAAA,EAAA,mBAAA,EAAA,qBAAA,CAAA,EAAA,CAAA,eAAA,EAAA,EAAA,CAAA,EAAA,CAAA,kBAAA,EAAA,EAAA,EAAA,CAAA,EAAA,kBAAA,EAAA,CAAA,EAAA,QAAA,CAAA,EAAA,CAAA,cAAA,EAAA,EAAA,CAAA,EAAA,CAAA,OAAA,EAAA,iBAAA,EAAA,CAAA,EAAA,SAAA,EAAA,SAAA,EAAA,CAAA,EAAA,OAAA,EAAA,SAAA,CAAA,EAAA,CAAA,CAAA,EAAA,iBAAA,EAAA,CAAA,EAAA,SAAA,EAAA,SAAA,CAAA,EAAA,CAAA,CAAA,EAAA,UAAA,EAAA,SAAA,EAAA,WAAA,CAAA,EAAA,CAAA,OAAA,EAAA,uCAAA,EAAA,CAAA,EAAA,UAAA,EAAA,SAAA,EAAA,WAAA,EAAA,SAAA,EAAA,CAAA,EAAA,MAAA,CAAA,EAAA,CAAA,OAAA,EAAA,wCAAA,EAAA,CAAA,EAAA,WAAA,EAAA,CAAA,EAAA,MAAA,CAAA,EAAA,CAAA,CAAA,EAAA,iBAAA,EAAA,uBAAA,EAAA,CAAA,EAAA,UAAA,EAAA,SAAA,EAAA,WAAA,EAAA,SAAA,CAAA,EAAA,CAAA,CAAA,EAAA,iBAAA,EAAA,wBAAA,EAAA,CAAA,EAAA,WAAA,CAAA,C;AAAA,EAAA,QAAA,EAAA,SAAA,wBAAA,CAAA,EAAA,EAAA,GAAA,EAAA;AAAA,QAAA,EAAA,GAAA,CAAA,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WAAA,o7J;;AAIE;;AAAmB,eAAA,CAAA,cAAA,GAAA;AAAA,SAAA,CAhKrB;AAAA,IAAA,IAAA,EAAA;AAAA,GAgKqB,EAjKrB;AAAA,IAAA,IAAA,EAAA;AAAA,GAiKqB,EA3JrB;AAAA,IAAA,IAAA,EAAA;AAAA,GA2JqB,EAxJrB;AAAA,IAAA,IAAA,EAAA;AAAA,GAwJqB,CAAA;AAAA,CAAA;;AAxJhB,eAAA,CAAA,cAAA,GAAA;AA0JL,WAAA,CAAA;AAAA,IAAA,IAAA,EAAA;AAAA,GAAA,CA1JK;AA6JL,iBAAA,CAAA;AAAA,IAAA,IAAA,EAAA;AAAA,GAAA,CA7JK;AAiKL,eAAA,CAAA;AAAA,IAAA,IAAA,EAAA;AAAA,GAAA,CAjKK;AAoKL,qBAAA,CAAA;AAAA,IAAA,IAAA,EAAA;AAAA,GAAA,CApKK;AAyKL,aAAA,CAAA;AAAA,IAAA,IAAA,EAAA;AAAA,GAAA,CAzKK;AA6KL,qBAAA,CAAA;AAAA,IAAA,IAAA,EAAA;AAAA,GAAA,CA7KK;AAiLL,gBAAA,CAAA;AAAA,IAAA,IAAA,EAAA;AAAA,GAAA,CAjLK;AAqLL,mBAAA,CAAA;AAAA,IAAA,IAAA,EAAA;AAAA,GAAA,CArLK;AA0LL,mBAAA,CAAA;AAAA,IAAA,IAAA,EAAA;AAAA,GAAA,CA1LK;AAoML,kBAAA,CAAA;AAAA,IAAA,IAAA,EAAA;AAAA,GAAA,CApMK;AAwPL,kCAAA,CAAA;AAAA,IAAA,IAAA,EAAG,SAAH;AAAA,IAAA,IAAA,EAAA,CAAa,uBAAb,EAAsC;AAAC,MAAA,IAAI,EAA3C;AAAsC,KAAtC;AAAA,GAAA,CAxPK;AA4PL,mCAAA,CAAA;AAAA,IAAA,IAAA,EAAG,SAAH;AAAA,IAAA,IAAA,EAAA,CAAa,wBAAb,EAAuC;AAAC,MAAA,IAAI,EAA5C;AAAuC,KAAvC;AAAA,GAAA,CA5PK;AAgQL,oBAAA,CAAA;AAAA,IAAA,IAAA,EAAG,SAAH;AAAA,IAAA,IAAA,EAAA,CAAa,SAAb,EAAwB;AAAC,MAAA,IAAI,EAA7B;AAAwB,KAAxB;AAAA,GAAA,CAhQK;AAoQL,yBAAA,CAAA;AAAA,IAAA,IAAA,EAAG,SAAH;AAAA,IAAA,IAAA,EAAA,CAAa,cAAb,EAA6B;AAAC,MAAA,IAAI,EAAlC;AAA6B,KAA7B;AAAA,GAAA,CApQK;AAwQL,sBAAA,CAAA;AAAA,IAAA,IAAA,EAAG,SAAH;AAAA,IAAA,IAAA,EAAA,CAAa,WAAb,EAA0B;AAAC,MAAA,IAAI,EAA/B;AAA0B,KAA1B;AAAA,GAAA,CAxQK;AA4QL,sBAAA,CAAA;AAAA,IAAA,IAAA,EAAG,SAAH;AAAA,IAAA,IAAA,EAAA,CAAa,WAAb,EAA0B;AAAC,MAAA,IAAI,EAA/B;AAA0B,KAA1B;AAAA,GAAA,CA5QK;AAgRL,uBAAA,CAAA;AAAA,IAAA,IAAA,EAAG,SAAH;AAAA,IAAA,IAAA,EAAA,CAAa,YAAb,EAA2B;AAAC,MAAA,IAAI,EAAhC;AAA2B,KAA3B;AAAA,GAAA,CAhRK;AAoRL,sBAAA,CAAA;AAAA,IAAA,IAAA,EAAG,SAAH;AAAA,IAAA,IAAA,EAAA,CAAa,WAAb,EAA0B;AAAC,MAAA,IAAI,EAA/B;AAA0B,KAA1B;AAAA,GAAA,CApRK;AAwRL,2BAAA,CAAA;AAAA,IAAA,IAAA,EAAG,SAAH;AAAA,IAAA,IAAA,EAAA,CAAa,gBAAb,EAA+B;AAAC,MAAA,IAAI,EAApC;AAA+B,KAA/B;AAAA,GAAA,CAxRK;AA4RL,2BAAA,CAAA;AAAA,IAAA,IAAA,EAAG,SAAH;AAAA,IAAA,IAAA,EAAA,CAAa,gBAAb,EAA+B;AAAC,MAAA,IAAI,EAApC;AAA+B,KAA/B;AAAA,GAAA,CA5RK;AAgSL,0BAAA,CAAA;AAAA,IAAA,IAAA,EAAG,SAAH;AAAA,IAAA,IAAA,EAAA,CAAa,eAAb,EAA8B;AAAC,MAAA,IAAI,EAAnC;AAA8B,KAA9B;AAAA,GAAA,CAhSK;AAoSL,kBAAA,CAAA;AAAA,IAAA,IAAA,EAAG,SAAH;AAAA,IAAA,IAAA,EAAA,CAAa,cAAb,EAA6B;AAAC,MAAA,IAAI,EAAlC;AAA6B,KAA7B;AAAA,GAAA,CApSK;AAwSL,qBAAA,CAAA;AAAA,IAAA,IAAA,EAAG,YAAH;AAAA,IAAA,IAAA,EAAA,CAAA,iBAAA;AAAA,GAAA,CAxSK;AA4SL,gCAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,gBAAA;AAAA,GAAA,CA5SK;AA8SL,+BAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,eAAA;AAAA,GAAA,CA9SK;AAgTL,+BAAA,CAAA;AAAA,IAAA,IAAA,EAAG,WAAH;AAAA,IAAA,IAAA,EAAA,CAAA,eAAA;AAAA,GAAA,CAhTK;AAycL,cAAA,CAAA;AAAA,IAAA,IAAA,EAAG,YAAH;AAAA,IAAA,IAAA,EAAA,CAAgB,eAAhB,EAAiC,CAAjC,QAAiC,CAAjC;AAAA,GAAA;AAzcK,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAycD,C;AAAE;AAAI;AAAkC;AAE1C;;;IC/cF,uB;;;;wCAbA,+B,CAAW,C,EAAA;AAAA,SAAA,KACT,CAAA,IAAA,uBADS,GAAA;AACC,C;;AAA4B,uBACtC,CAAF,IADwC,GACxC,MAAA,CAAA,iBAAA,CAAA;AAAA,EAAA,IAAA,EAAA,uBAAA;AAAA,EAAA,SAAA,EAAA,CAAA,CAAA,4BAAA,CAAA,CAAA;AAAA,EAAA,MAAA,EAAA;AAAA,IAAA,QAAA,EAAA,UAAA;AAAA,IAAA,OAAA,EAAA,SAAA;AAAA,IAAA,SAAA,EAAA,WAAA;AAAA,IAAA,OAAA,EAAA;AAAA,GAAA;AAAA,EAAA,KAAA,EAAA,CAAA;AAAA,EAAA,IAAA,EAAA,CAAA;AAAA,EAAA,MAAA,EAAA,CAAA,CAAA,CAAA,EAAA,MAAA,CAAA,EAAA,CAAA,CAAA,EAAA,kBAAA,EAAA,yBAAA,CAAA,EAAA,CAAA,CAAA,EAAA,0BAAA,CAAA,CAAA;AAAA,EAAA,QAAA,EAAA,SAAA,gCAAA,CASA,EATA,EASA,GATA,EASA;AAAA,QAAA,EAAA,GAAA,CAAA,EAAA;aAAA,U,CAAoD,C,EAAA,+C,EACpD,C,EAAA,C,EAAA,c,EAAA,C;;;;;;;;;GAVA;oDAAA;WAWC,2D;AAXD,CAAA,CADwC;AAYtC;;AAAmB,uBAAA,CAAA,cAAA,GAAA;AAAA,SAAA,EAAA;AAAA,CAAA;;AAEC,uBAAA,CAAA,cAAA,GAAA;AADtB,cAAA,CAAA;AAAA,IAAA,IAAA,EAAA;AAAA,GAAA,CACsB;AAEtB,aAAA,CAAA;AAAA,IAAA,IAAA,EAAA;AAAA,GAAA,CAFsB;AAKtB,eAAA,CAAA;AAAA,IAAA,IAAA,EAAA;AAAA,GAAA,CALsB;AAQtB,aAAA,CAAA;AAAA,IAAA,IAAA,EAAA;AAAA,GAAA;AARsB,CAAA;;;;;;;;;;;;;;;;;;;;;;;;AAQlB,C;AAAE;AAAI;AAGE;AAAyC;;AC5BrD;AAAI;AAAoB;AAAG;AACC;;;IA2B5B,e;;;;8BAfA,gB,CAAC;AAAA,EAAA,IAAD,EAAA;AAAC,C;AACC,eAAS,CAAA,IAAT,GAAS,MAAA,CAAA,gBAAA,CACK;AAAA,EAAA,OAAA,EAAA,SACb,uBADa,CAEd,CAFc,EAEF;AAAE,WAAA,KAAA,CAAA,IAAA,eAAA,GAAA;AACG,GAHH;AAGG,EAAA,OAAA,EAAA,CAAA,CACf,YADe,CAAA;AAHH,CADL,CAAT;AAME;;AAAqB,eAAA,CAAA,cAAA,GAAA;AAAA,SACrB,EADqB;AAAA,CAAA;;CACD,YAAA;AAAA,GAAA,OAAA,SAAA,KACpB,WADoB,IACpB,SADoB,KACG,MAAA,CAAA,kBAAA,CACxB,eADwB,EAEhB;AAAA,IAAA,YAAA,EACP,wBAAA;AAAe,aAAA,CAAA,eAAA,EAChB,sBADgB,EAEnB,qBAFmB,EAEnB,oBAFmB,EAEnB,uBAFmB,CAAA;AAEnB,KAHW;AAGX,IAAA,OAAA,EAAA,mBAAA;AAAA,aAAA,CAAA,YAAA,CAAA;AAAA,KAHW;AAGX,IAAA,OAAA,EAAA,mBAAA;AAAA,aAAA,CAAA,eAAA,CAAA;AAAA;AAHW,GAFgB,CADH;AAMxB,C;;;;;;;;;;;AAE8B,C;AAAE;AAAI;AAAkC;AAAyC;;AAAK;AAAI;AAAkC;AAAyC;;AAAI;AAAI;AAAwC;;;AAAK,SAAA,eAAA,EAAA,aAAA,EAAA,WAAA,EAAA,SAAA,EAAA,OAAA,EAAA,sBAAA,IAAA,EAAA,EAAA,qBAAA,IAAA,EAAA,EAAA,oBAAA,IAAA,EAAA,EAAA,eAAA,IAAA,EAAA,EAAA,uBAAA,IAAA,EAAA","sourcesContent":["import { PointerType } from './pointer-type';\n\n/** Label type */\nexport enum LabelType {\n  /** Label above low pointer */\n  Low,\n  /** Label above high pointer */\n  High,\n  /** Label for minimum slider value */\n  Floor,\n  /** Label for maximum slider value */\n  Ceil,\n  /** Label below legend tick */\n  TickValue\n}\n\n/** Function to translate label value into text */\nexport type TranslateFunction = (value: number, label: LabelType) => string;\n/** Function to combind */\nexport type CombineLabelsFunction = (minLabel: string, maxLabel: string) => string;\n/** Function to provide legend  */\nexport type GetLegendFunction = (value: number) => string;\n\n/** Function converting slider value to slider position */\nexport type ValueToPositionFunction = (val: number, minVal: number, maxVal: number) => number;\n\n/** Function converting slider position to slider value */\nexport type PositionToValueFunction = (percent: number, minVal: number, maxVal: number) => number;\n\n/**\n * Custom step definition\n *\n * This can be used to specify custom values and legend values for slider ticks\n */\nexport interface CustomStepDefinition {\n  /** Value */\n  value: number;\n  /** Legend (label for the value) */\n  legend?: string;\n}\n\n/** Slider options */\nexport class Options {\n  /** Minimum value for a slider.\n    Not applicable when using stepsArray. */\n  floor?: number = 0;\n\n  /** Maximum value for a slider.\n    Not applicable when using stepsArray. */\n  ceil?: number = null;\n\n  /** Step between each value.\n    Not applicable when using stepsArray. */\n  step?: number = 1;\n\n  /** The minimum range authorized on the slider.\n    Applies to range slider only.\n    When using stepsArray, expressed as index into stepsArray. */\n  minRange?: number = null;\n\n  /** The maximum range authorized on the slider.\n    Applies to range slider only.\n    When using stepsArray, expressed as index into stepsArray. */\n  maxRange?: number = null;\n\n  /** Set to true to have a push behavior. When the min handle goes above the max,\n    the max is moved as well (and vice-versa). The range between min and max is\n    defined by the step option (defaults to 1) and can also be overriden by\n    the minRange option. Applies to range slider only. */\n  pushRange?: boolean = false;\n\n  /** The minimum value authorized on the slider.\n    When using stepsArray, expressed as index into stepsArray. */\n  minLimit?: number = null;\n\n  /** The maximum value authorized on the slider.\n    When using stepsArray, expressed as index into stepsArray. */\n  maxLimit?: number = null;\n\n  /** Custom translate function. Use this if you want to translate values displayed\n      on the slider. */\n  translate?: TranslateFunction = null;\n\n  /** Custom function for combining overlapping labels in range slider.\n      It takes the min and max values (already translated with translate fuction)\n      and should return how these two values should be combined.\n      If not provided, the default function will join the two values with\n      ' - ' as separator. */\n  combineLabels?: CombineLabelsFunction = null;\n\n  /** Use to display legend under ticks (thus, it needs to be used along with\n     showTicks or showTicksValues). The function will be called with each tick\n     value and returned content will be displayed under the tick as a legend.\n     If the returned value is null, then no legend is displayed under\n     the corresponding tick.You can also directly provide the legend values\n     in the stepsArray option. */\n  getLegend?: GetLegendFunction = null;\n\n  /** If you want to display a slider with non linear/number steps.\n     Just pass an array with each slider value and that's it; the floor, ceil and step settings\n     of the slider will be computed automatically.\n     By default, the value model and valueHigh model values will be the value of the selected item\n     in the stepsArray.\n     They can also be bound to the index of the selected item by setting the bindIndexForStepsArray\n     option to true. */\n  stepsArray?: CustomStepDefinition[] = null;\n\n  /** Set to true to bind the index of the selected item to value model and valueHigh model. */\n  bindIndexForStepsArray?: boolean = false;\n\n  /** When set to true and using a range slider, the range can be dragged by the selection bar.\n    Applies to range slider only. */\n  draggableRange?: boolean = false;\n\n  /** Same as draggableRange but the slider range can't be changed.\n    Applies to range slider only. */\n  draggableRangeOnly?: boolean = false;\n\n  /** Set to true to always show the selection bar before the slider handle. */\n  showSelectionBar?: boolean = false;\n\n  /** Set to true to always show the selection bar after the slider handle. */\n  showSelectionBarEnd?: boolean = false;\n\n  /**  Set a number to draw the selection bar between this value and the slider handle.\n    When using stepsArray, expressed as index into stepsArray. */\n  showSelectionBarFromValue?: number = null;\n\n  /**  Only for range slider. Set to true to visualize in different colour the areas\n    on the left/right (top/bottom for vertical range slider) of selection bar between the handles. */\n  showOuterSelectionBars?: boolean = false;\n\n  /** Set to true to hide pointer labels */\n  hidePointerLabels?: boolean = false;\n\n  /** Set to true to hide min / max labels  */\n  hideLimitLabels?: boolean = false;\n\n  /** Set to false to disable the auto-hiding behavior of the limit labels. */\n  autoHideLimitLabels?: boolean = true;\n\n  /** Set to true to make the slider read-only. */\n  readOnly?: boolean = false;\n\n  /** Set to true to disable the slider. */\n  disabled?: boolean = false;\n\n  /** Throttle interval for mouse events in milliseconds.\n   * This is provided to avoid a flood of events when moving the slider with mouse. */\n  mouseEventsInterval?: number = 50;\n\n  /** Throttle interval for touch events in milliseconds.\n   * This is provided to avoid a flood of events when moving the slider with touch gesture. */\n  touchEventsInterval?: number = 50;\n\n  /** Throttle interval for input changes (changes to bindings or reactive form inputs)\n   * This is provided to avoid a flood of events on frequent input binding changes affecting performance. */\n  inputEventsInterval?: number = 100;\n\n  /** Throttle interval for output changes (signalling changes to output bindings and user callbacks)\n   * This is provided to avoid a flood of outgoing events affecting Angular app performance. */\n  outputEventsInterval?: number = 100;\n\n  /** Set to true to display a tick for each step of the slider. */\n  showTicks?: boolean = false;\n\n  /** Set to true to display a tick and the step value for each step of the slider.. */\n  showTicksValues?: boolean = false;\n\n  /* The step between each tick to display. If not set, the step value is used.\n    Not used when ticksArray is specified. */\n  tickStep?: number = null;\n\n  /* The step between displaying each tick step value. */\n  tickValueStep?: number = 1;\n\n  /** Use to display ticks at specific positions.\n    The array contains the index of the ticks that should be displayed.\n    For example, [0, 1, 5] will display a tick for the first, second and sixth values. */\n  ticksArray?: number[] = null;\n\n  /** Used to display a tooltip when a tick is hovered.\n    Set to a function that returns the tooltip content for a given value. */\n  ticksTooltip?: (value: number) => string = null;\n\n  /** Same as ticksTooltip but for ticks values. */\n  ticksValuesTooltip?: (value: number) => string = null;\n\n  /** Set to true to display the slider vertically.\n    The slider will take the full height of its parent.\n    Changing this value at runtime is not currently supported. */\n  vertical?: boolean = false;\n\n  /** Function that returns the current color of the selection bar.\n    If your color won't change, don't use this option but set it through CSS.\n    If the returned color depends on a model value (either value or valueHigh),\n    you should use the argument passed to the function.\n    Indeed, when the function is called, there is no certainty that the model\n    has already been updated.*/\n  getSelectionBarColor?: (minValue: number, maxValue?: number) => string = null;\n\n  /** Function that returns the color of a tick. showTicks must be enabled. */\n  getTickColor?: (value: number) => string = null;\n\n  /** Function that returns the current color of a pointer.\n    If your color won't change, don't use this option but set it through CSS.\n    If the returned color depends on a model value (either value or valueHigh),\n    you should use the argument passed to the function.\n    Indeed, when the function is called, there is no certainty that the model has already been updated.\n    To handle range slider pointers independently, you should evaluate pointerType within the given\n    function where \"min\" stands for value model and \"max\" for valueHigh model values. */\n  getPointerColor?: (value: number, pointerType: PointerType) => string = null;\n\n  /** Handles are focusable (on click or with tab) and can be modified using the following keyboard controls:\n    Left/bottom arrows: -1\n    Right/top arrows: +1\n    Page-down: -10%\n    Page-up: +10%\n    Home: minimum value\n    End: maximum value\n   */\n  keyboardSupport?: boolean = true;\n\n  /** If you display the slider in an element that uses transform: scale(0.5), set the scale value to 2\n    so that the slider is rendered properly and the events are handled correctly. */\n  scale?: number = 1;\n\n  /** Set to true to force the value to be rounded to the step, even when modified from the outside.\n    When set to false, if the model values are modified from outside the slider, they are not rounded\n    and can be between two steps. */\n  enforceStep?: boolean = true;\n\n  /** Set to true to force the value to be normalised to allowed range (floor to ceil), even when modified from the outside.\n    When set to false, if the model values are modified from outside the slider, and they are outside allowed range,\n    the slider may be rendered incorrectly. However, setting this to false may be useful if you want to perform custom normalisation. */\n  enforceRange?: boolean = true;\n\n  /** Set to true to prevent to user from switching the min and max handles. Applies to range slider only. */\n  noSwitching?: boolean = false;\n\n  /** Set to true to only bind events on slider handles. */\n  onlyBindHandles?: boolean = false;\n\n  /** Set to true to show graphs right to left.\n    If vertical is true it will be from top to bottom and left / right arrow functions reversed. */\n  rightToLeft?: boolean = false;\n\n  /** Set to true to reverse keyboard navigation:\n    Right/top arrows: -1\n    Left/bottom arrows: +1\n    Page-up: -10%\n    Page-down: +10%\n    End: minimum value\n    Home: maximum value\n   */\n  reversedControls?: boolean = false;\n\n  /** Set to true to keep the slider labels inside the slider bounds. */\n  boundPointerLabels?: boolean = true;\n\n  /** Set to true to use a logarithmic scale to display the slider.  */\n  logScale?: boolean = false;\n\n  /** Function that returns the position on the slider for a given value.\n    The position must be a percentage between 0 and 1.\n    The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly. */\n  customValueToPosition?: ValueToPositionFunction = null;\n\n  /** Function that returns the value for a given position on the slider.\n    The position is a percentage between 0 and 1.\n    The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly. */\n  customPositionToValue?: PositionToValueFunction = null;\n\n  /** Precision limit for calculated values.\n    Values used in calculations will be rounded to this number of significant digits\n    to prevent accumulating small floating-point errors. */\n  precisionLimit?: number = 12;\n\n  /** Use to display the selection bar as a gradient.\n    The given object must contain from and to properties which are colors. */\n  selectionBarGradient?: {from: string, to: string} = null;\n\n  /** Use to add a label directly to the slider for accessibility. Adds the aria-label attribute. */\n  ariaLabel?: string = null;\n\n  /** Use instead of ariaLabel to reference the id of an element which will be used to label the slider.\n    Adds the aria-labelledby attribute. */\n  ariaLabelledBy?: string = null;\n\n  /** Use to add a label directly to the slider range for accessibility. Adds the aria-label attribute. */\n  ariaLabelHigh?: string = null;\n\n  /** Use instead of ariaLabelHigh to reference the id of an element which will be used to label the slider range.\n    Adds the aria-labelledby attribute. */\n  ariaLabelledByHigh?: string = null;\n\n  /** Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the handle */\n  handleDimension?: number = null;\n\n  /** Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the bar */\n  barDimension?: number = null;\n\n  /** Enable/disable CSS animations */\n  animate?: boolean = true;\n}\n","import { PointerType } from './pointer-type';\n\nexport class ChangeContext {\n  value: number;\n  highValue?: number;\n  pointerType: PointerType;\n}\n","import { CustomStepDefinition } from './options';\n\n/**\n *  Collection of functions to handle conversions/lookups of values\n */\nexport class ValueHelper {\n  static isNullOrUndefined(value: any): boolean {\n    return value === undefined || value === null;\n  }\n\n  static linearValueToPosition(val: number, minVal: number, maxVal: number): number {\n    const range: number = maxVal - minVal;\n    return (val - minVal) / range;\n  }\n\n  static logValueToPosition(val: number, minVal: number, maxVal: number): number {\n    val = Math.log(val);\n    minVal = Math.log(minVal);\n    maxVal = Math.log(maxVal);\n    const range: number = maxVal - minVal;\n    return (val - minVal) / range;\n  }\n\n  static linearPositionToValue(percent: number, minVal: number, maxVal: number): number {\n    return percent * (maxVal - minVal) + minVal;\n  }\n\n  static logPositionToValue(percent: number, minVal: number, maxVal: number): number {\n    minVal = Math.log(minVal);\n    maxVal = Math.log(maxVal);\n    const value: number = percent * (maxVal - minVal) + minVal;\n    return Math.exp(value);\n  }\n\n  static findStepIndex(modelValue: number, stepsArray: CustomStepDefinition[]): number {\n    const differences: number[] = stepsArray.map((step: CustomStepDefinition): number => Math.abs(modelValue - step.value));\n\n    let minDifferenceIndex: number = 0;\n    for (let index: number = 0; index < stepsArray.length; index++) {\n      if (differences[index] !== differences[minDifferenceIndex] && differences[index] < differences[minDifferenceIndex]) {\n        minDifferenceIndex = index;\n      }\n    }\n\n    return minDifferenceIndex;\n  }\n}\n","// Declaration for ResizeObserver a new API available in some of newest browsers:\n// https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver\ndeclare class ResizeObserver {\n}\n\n/** Helper with compatibility functions to support different browsers */\nexport class CompatibilityHelper {\n  /** Workaround for TouchEvent constructor sadly not being available on all browsers (e.g. Firefox, Safari) */\n  public static isTouchEvent(event: any): boolean {\n    if ((window as any).TouchEvent !== undefined) {\n      return event instanceof TouchEvent;\n    }\n\n    return event.touches !== undefined;\n  }\n\n  /** Detect presence of ResizeObserver API */\n  public static isResizeObserverAvailable(): boolean {\n    return (window as any).ResizeObserver !== undefined;\n  }\n}\n","/** Helper with mathematical functions */\nexport class MathHelper {\n  /* Round numbers to a given number of significant digits */\n  static roundToPrecisionLimit(value: number, precisionLimit: number): number {\n    return +( value.toPrecision(precisionLimit) );\n  }\n\n  static clampToRange(value: number, floor: number, ceil: number): number {\n    return Math.min(Math.max(value, floor), ceil);\n  }\n}\n","import { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\n\nexport class EventListener {\n  eventName: string = null;\n  events: Subject<Event> = null;\n  eventsSubscription: Subscription = null;\n  teardownCallback: () => void = null;\n}\n","import { Renderer2 } from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\nimport { throttleTime, tap } from 'rxjs/operators';\nimport detectPassiveEvents from 'detect-passive-events';\n\nimport { EventListener } from './event-listener';\nimport { ValueHelper } from './value-helper';\n\n/**\n * Helper class to attach event listeners to DOM elements with debounce support using rxjs\n */\nexport class EventListenerHelper {\n  constructor(private renderer: Renderer2) {\n  }\n\n  public attachPassiveEventListener(nativeElement: any, eventName: string, callback: (event: any) => void,\n      throttleInterval?: number): EventListener {\n    // Only use passive event listeners if the browser supports it\n    if (detectPassiveEvents.hasSupport !== true) {\n      return this.attachEventListener(nativeElement, eventName, callback, throttleInterval);\n    }\n\n    // Angular doesn't support passive event handlers (yet), so we need to roll our own code using native functions\n    const listener: EventListener = new EventListener();\n    listener.eventName = eventName;\n    listener.events = new Subject<Event>();\n\n    const observerCallback: (event: Event) => void = (event: Event): void => {\n      listener.events.next(event);\n    };\n    nativeElement.addEventListener(eventName, observerCallback, {passive: true, capture: false});\n\n    listener.teardownCallback = (): void => {\n      nativeElement.removeEventListener(eventName, observerCallback, {passive: true, capture: false});\n    };\n\n    listener.eventsSubscription = listener.events\n      .pipe((!ValueHelper.isNullOrUndefined(throttleInterval))\n        ? throttleTime(throttleInterval, undefined, { leading: true, trailing: true})\n        : tap(() => {}) // no-op\n      )\n      .subscribe((event: Event) => {\n        callback(event);\n      });\n\n    return listener;\n  }\n\n  public detachEventListener(eventListener: EventListener): void {\n    if (!ValueHelper.isNullOrUndefined(eventListener.eventsSubscription)) {\n      eventListener.eventsSubscription.unsubscribe();\n      eventListener.eventsSubscription = null;\n    }\n\n    if (!ValueHelper.isNullOrUndefined(eventListener.events)) {\n      eventListener.events.complete();\n      eventListener.events = null;\n    }\n\n    if (!ValueHelper.isNullOrUndefined(eventListener.teardownCallback)) {\n      eventListener.teardownCallback();\n      eventListener.teardownCallback = null;\n    }\n  }\n\n  public attachEventListener(nativeElement: any, eventName: string, callback: (event: any) => void,\n      throttleInterval?: number): EventListener {\n    const listener: EventListener = new EventListener();\n    listener.eventName = eventName;\n    listener.events = new Subject<Event>();\n\n    const observerCallback: (event: Event) => void = (event: Event): void => {\n      listener.events.next(event);\n    };\n\n    listener.teardownCallback = this.renderer.listen(nativeElement, eventName, observerCallback);\n\n    listener.eventsSubscription = listener.events\n      .pipe((!ValueHelper.isNullOrUndefined(throttleInterval))\n          ? throttleTime(throttleInterval, undefined, { leading: true, trailing: true})\n          : tap(() => {}) // no-op\n      )\n      .subscribe((event: Event) => { callback(event); });\n\n    return listener;\n  }\n}\n","import { Directive, ElementRef, Renderer2, HostBinding } from '@angular/core';\nimport { EventListenerHelper } from './event-listener-helper';\nimport { EventListener } from './event-listener';\nimport { ValueHelper } from './value-helper';\n\n@Directive({\n  selector: '[ng5SliderElement]'\n})\nexport class SliderElementDirective {\n  private _position: number = 0;\n  get position(): number {\n    return this._position;\n  }\n\n  private _dimension: number = 0;\n  get dimension(): number {\n    return this._dimension;\n  }\n\n  private _alwaysHide: boolean = false;\n  get alwaysHide(): boolean {\n    return this._alwaysHide;\n  }\n\n  private _vertical: boolean = false;\n  get vertical(): boolean {\n    return this._vertical;\n  }\n\n  private _scale: number = 1;\n  get scale(): number {\n    return this._scale;\n  }\n\n  @HostBinding('style.opacity')\n  opacity: number = 1;\n\n  @HostBinding('style.visibility')\n  visibility: string = 'visible';\n\n  @HostBinding('style.left')\n  left: string = '';\n\n  @HostBinding('style.bottom')\n  bottom: string = '';\n\n  @HostBinding('style.height')\n  height: string = '';\n\n  @HostBinding('style.width')\n  width: string = '';\n\n  private eventListenerHelper: EventListenerHelper;\n  private eventListeners: EventListener[] = [];\n\n  constructor(protected elemRef: ElementRef, protected renderer: Renderer2) {\n    this.eventListenerHelper = new EventListenerHelper(this.renderer);\n  }\n\n  setAlwaysHide(hide: boolean): void {\n    this._alwaysHide = hide;\n    if (hide) {\n      this.visibility = 'hidden';\n    } else {\n      this.visibility = 'visible';\n    }\n  }\n\n  hide(): void {\n    this.opacity = 0;\n  }\n\n  show(): void {\n    if (this.alwaysHide) {\n      return;\n    }\n\n    this.opacity = 1;\n  }\n\n  isVisible(): boolean {\n    if (this.alwaysHide) {\n      return false;\n    }\n    return this.opacity !== 0;\n  }\n\n  setVertical(vertical: boolean): void {\n    this._vertical = vertical;\n    if (this._vertical) {\n      this.left = '';\n      this.width = '';\n    } else {\n      this.bottom = '';\n      this.height = '';\n    }\n  }\n\n  setScale(scale: number): void {\n    this._scale = scale;\n  }\n\n   // Set element left/top position depending on whether slider is horizontal or vertical\n  setPosition(pos: number): void {\n    this._position = pos;\n    if (this._vertical) {\n      this.bottom = Math.round(pos) + 'px';\n    } else {\n      this.left = Math.round(pos) + 'px';\n    }\n  }\n\n  // Calculate element's width/height depending on whether slider is horizontal or vertical\n  calculateDimension(): void {\n    const val: ClientRect = this.getBoundingClientRect();\n    if (this.vertical) {\n      this._dimension = (val.bottom - val.top) * this.scale;\n    } else {\n      this._dimension = (val.right - val.left) * this.scale;\n    }\n  }\n\n  // Set element width/height depending on whether slider is horizontal or vertical\n  setDimension(dim: number): void {\n    this._dimension = dim;\n    if (this._vertical) {\n      this.height = Math.round(dim) + 'px';\n    } else {\n      this.width = Math.round(dim) + 'px';\n    }\n  }\n\n  getBoundingClientRect(): ClientRect {\n    return this.elemRef.nativeElement.getBoundingClientRect();\n  }\n\n  on(eventName: string, callback: (event: any) => void, debounceInterval?: number): void {\n    const listener: EventListener = this.eventListenerHelper.attachEventListener(\n      this.elemRef.nativeElement, eventName, callback, debounceInterval);\n    this.eventListeners.push(listener);\n  }\n\n  onPassive(eventName: string, callback: (event: any) => void, debounceInterval?: number): void {\n    const listener: EventListener = this.eventListenerHelper.attachPassiveEventListener(\n      this.elemRef.nativeElement, eventName, callback, debounceInterval);\n    this.eventListeners.push(listener);\n  }\n\n  off(eventName?: string): void {\n    let listenersToKeep: EventListener[];\n    let listenersToRemove: EventListener[];\n    if (!ValueHelper.isNullOrUndefined(eventName)) {\n      listenersToKeep = this.eventListeners.filter((event: EventListener) => event.eventName !== eventName);\n      listenersToRemove = this.eventListeners.filter((event: EventListener) => event.eventName === eventName);\n    } else {\n      listenersToKeep = [];\n      listenersToRemove = this.eventListeners;\n    }\n\n    for (const listener of listenersToRemove) {\n      this.eventListenerHelper.detachEventListener(listener);\n    }\n\n    this.eventListeners = listenersToKeep;\n  }\n}\n","import { Directive, ElementRef, Renderer2, HostBinding } from '@angular/core';\nimport { SliderElementDirective } from './slider-element.directive';\n\n@Directive({\n  selector: '[ng5SliderHandle]'\n})\nexport class SliderHandleDirective extends SliderElementDirective {\n  @HostBinding('class.ng5-slider-active')\n  active: boolean = false;\n\n  @HostBinding('attr.role')\n  role: string = '';\n\n  @HostBinding('attr.tabindex')\n  tabindex: string = '';\n\n  @HostBinding('attr.aria-orientation')\n  ariaOrientation: string = '';\n\n  @HostBinding('attr.aria-label')\n  ariaLabel: string = '';\n\n  @HostBinding('attr.aria-labelledby')\n  ariaLabelledBy: string = '';\n\n  @HostBinding('attr.aria-valuenow')\n  ariaValueNow: string = '';\n\n  @HostBinding('attr.aria-valuetext')\n  ariaValueText: string = '';\n\n  @HostBinding('attr.aria-valuemin')\n  ariaValueMin: string = '';\n\n  @HostBinding('attr.aria-valuemax')\n  ariaValueMax: string = '';\n\n  focus(): void {\n    this.elemRef.nativeElement.focus();\n  }\n\n  constructor(elemRef: ElementRef, renderer: Renderer2) {\n    super(elemRef, renderer);\n  }\n}\n","import { Directive, ElementRef, Renderer2 } from '@angular/core';\nimport { SliderElementDirective } from './slider-element.directive';\nimport { ValueHelper } from './value-helper';\n\n@Directive({\n  selector: '[ng5SliderLabel]'\n})\nexport class SliderLabelDirective extends SliderElementDirective {\n  private _value: string = null;\n  get value(): string {\n    return this._value;\n  }\n\n  constructor(elemRef: ElementRef, renderer: Renderer2) {\n    super(elemRef, renderer);\n  }\n\n  setValue(value: string): void {\n    let recalculateDimension: boolean = false;\n\n    if (!this.alwaysHide &&\n        (ValueHelper.isNullOrUndefined(this.value) ||\n         this.value.length !== value.length ||\n         (this.value.length > 0 && this.dimension === 0))) {\n      recalculateDimension = true;\n    }\n\n    this._value = value;\n    this.elemRef.nativeElement.innerHTML = value;\n\n    // Update dimension only when length of the label have changed\n    if (recalculateDimension) {\n      this.calculateDimension();\n    }\n  }\n}\n","import {\n  Component,\n  OnInit,\n  ViewChild,\n  AfterViewInit,\n  OnChanges,\n  OnDestroy,\n  HostBinding,\n  HostListener,\n  Input,\n  ElementRef,\n  Renderer2,\n  EventEmitter,\n  Output,\n  ContentChild,\n  TemplateRef,\n  ChangeDetectorRef,\n  SimpleChanges,\n  forwardRef,\n  NgZone\n} from '@angular/core';\n\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\n\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { distinctUntilChanged, filter, throttleTime, tap } from 'rxjs/operators';\n\nimport detectPassiveEvents from 'detect-passive-events';\n\nimport {\n  Options,\n  LabelType,\n  ValueToPositionFunction,\n  PositionToValueFunction,\n  CustomStepDefinition\n} from './options';\nimport { PointerType } from './pointer-type';\nimport { ChangeContext } from './change-context';\nimport { ValueHelper } from './value-helper';\nimport { CompatibilityHelper } from './compatibility-helper';\nimport { MathHelper } from './math-helper';\nimport { EventListener } from './event-listener';\nimport { EventListenerHelper } from './event-listener-helper';\nimport { SliderElementDirective } from './slider-element.directive';\nimport { SliderHandleDirective } from './slider-handle.directive';\nimport { SliderLabelDirective } from './slider-label.directive';\n\n// Declaration for ResizeObserver a new API available in some of newest browsers:\n// https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver\ndeclare class ResizeObserver {\n  constructor(callback: () => void);\n  observe(target: any): void;\n  unobserve(target: any): void;\n  disconnect(): void;\n}\n\nexport class Tick {\n  selected: boolean = false;\n  style: any = {};\n  tooltip: string = null;\n  tooltipPlacement: string = null;\n  value: string = null;\n  valueTooltip: string = null;\n  valueTooltipPlacement: string = null;\n  legend: string = null;\n}\n\nclass Dragging {\n  active: boolean = false;\n  value: number = 0;\n  difference: number = 0;\n  position: number = 0;\n  lowLimit: number = 0;\n  highLimit: number = 0;\n}\n\nclass ModelValues {\n  value: number;\n  highValue: number;\n\n  public static compare(x?: ModelValues, y?: ModelValues): boolean {\n    if (ValueHelper.isNullOrUndefined(x) && ValueHelper.isNullOrUndefined(y)) {\n      return false;\n    }\n    if (ValueHelper.isNullOrUndefined(x) !== ValueHelper.isNullOrUndefined(y)) {\n      return false;\n    }\n    return x.value === y.value && x.highValue === y.highValue;\n  }\n}\n\nclass ModelChange extends ModelValues {\n  // Flag used to by-pass distinctUntilChanged() filter on input values\n  // (sometimes there is a need to pass values through even though the model values have not changed)\n  forceChange: boolean;\n\n  public static compare(x?: ModelChange, y?: ModelChange): boolean {\n    if (ValueHelper.isNullOrUndefined(x) && ValueHelper.isNullOrUndefined(y)) {\n      return false;\n    }\n    if (ValueHelper.isNullOrUndefined(x) !== ValueHelper.isNullOrUndefined(y)) {\n      return false;\n    }\n    return x.value === y.value &&\n           x.highValue === y.highValue &&\n           x.forceChange === y.forceChange;\n  }\n}\n\nclass InputModelChange extends ModelChange {\n  internalChange: boolean;\n}\n\nclass OutputModelChange extends ModelChange {\n  userEventInitiated: boolean;\n}\n\nconst NG5_SLIDER_CONTROL_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  /* tslint:disable-next-line: no-use-before-declare */\n  useExisting: forwardRef(() => SliderComponent),\n  multi: true,\n};\n\n\n@Component({\n  selector: 'ng5-slider',\n  template: `<!-- // 0 Left selection bar outside two handles -->\n<span ng5SliderElement #leftOuterSelectionBar class=\"ng5-slider-span ng5-slider-bar-wrapper ng5-slider-left-out-selection\">\n  <span class=\"ng5-slider-span ng5-slider-bar\"></span>\n</span>\n<!-- // 1 Right selection bar outside two handles -->\n<span ng5SliderElement #rightOuterSelectionBar class=\"ng5-slider-span ng5-slider-bar-wrapper ng5-slider-right-out-selection\">\n  <span class=\"ng5-slider-span ng5-slider-bar\"></span>\n</span>\n<!-- // 2 The whole slider bar -->\n<span ng5SliderElement #fullBar [class.ng5-slider-transparent]=\"fullBarTransparentClass\" class=\"ng5-slider-span ng5-slider-bar-wrapper ng5-slider-full-bar\">\n  <span class=\"ng5-slider-span ng5-slider-bar\"></span>\n</span>\n<!-- // 3 Selection bar between two handles -->\n<span ng5SliderElement #selectionBar [class.ng5-slider-draggable]=\"selectionBarDraggableClass\" class=\"ng5-slider-span ng5-slider-bar-wrapper ng5-slider-selection-bar\">\n  <span class=\"ng5-slider-span ng5-slider-bar ng5-slider-selection\" [ngStyle]=\"barStyle\"></span>\n</span>\n<!-- // 4 Low slider handle -->\n<span ng5SliderHandle #minHandle class=\"ng5-slider-span ng5-slider-pointer ng5-slider-pointer-min\" [ngStyle]=minPointerStyle></span>\n<!-- // 5 High slider handle -->\n<span ng5SliderHandle #maxHandle [style.display]=\"range ? 'inherit' : 'none'\" class=\"ng5-slider-span ng5-slider-pointer ng5-slider-pointer-max\" [ngStyle]=maxPointerStyle></span>\n<!-- // 6 Floor label -->\n<span ng5SliderLabel #floorLabel class=\"ng5-slider-span ng5-slider-bubble ng5-slider-limit ng5-slider-floor\"></span>\n<!-- // 7 Ceiling label -->\n<span ng5SliderLabel #ceilLabel class=\"ng5-slider-span ng5-slider-bubble ng5-slider-limit ng5-slider-ceil\"></span>\n<!-- // 8 Label above the low slider handle -->\n<span ng5SliderLabel #minHandleLabel class=\"ng5-slider-span ng5-slider-bubble ng5-slider-model-value\"></span>\n<!-- // 9 Label above the high slider handle -->\n<span ng5SliderLabel #maxHandleLabel class=\"ng5-slider-span ng5-slider-bubble ng5-slider-model-high\"></span>\n<!-- // 10 Combined range label when the slider handles are close ex. 15 - 17 -->\n<span ng5SliderLabel #combinedLabel class=\"ng5-slider-span ng5-slider-bubble ng5-slider-combined\"></span>\n<!-- // 11 The ticks -->\n<span ng5SliderElement #ticksElement [hidden]=\"!showTicks\" [class.ng5-slider-ticks-values-under]=\"ticksUnderValuesClass\" class=\"ng5-slider-ticks\">\n  <span *ngFor=\"let t of ticks\" class=\"ng5-slider-tick\" [ngClass]=\"{'ng5-slider-selected': t.selected}\" [ngStyle]=\"t.style\">\n    <ng5-slider-tooltip-wrapper [template]=\"tooltipTemplate\" [tooltip]=\"t.tooltip\" [placement]=\"t.tooltipPlacement\"></ng5-slider-tooltip-wrapper>\n    <ng5-slider-tooltip-wrapper *ngIf=\"t.value != null\" class=\"ng5-slider-span ng5-slider-tick-value\"\n        [template]=\"tooltipTemplate\" [tooltip]=\"t.valueTooltip\" [placement]=\"t.valueTooltipPlacement\" [content]=\"t.value\"></ng5-slider-tooltip-wrapper>\n    <span *ngIf=\"t.legend != null\" class=\"ng5-slider-span ng5-slider-tick-legend\" [innerHTML]=\"t.legend\"></span>\n  </span>\n</span>`,\n  styles: [`::ng-deep .ng5-slider{display:inline-block;position:relative;height:4px;width:100%;margin:35px 0 15px;vertical-align:middle;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-touch-action:pan-y;touch-action:pan-y}::ng-deep .ng5-slider.with-legend{margin-bottom:40px}::ng-deep .ng5-slider[disabled]{cursor:not-allowed}::ng-deep .ng5-slider[disabled] .ng5-slider-pointer{cursor:not-allowed;background-color:#d8e0f3}::ng-deep .ng5-slider[disabled] .ng5-slider-draggable{cursor:not-allowed}::ng-deep .ng5-slider[disabled] .ng5-slider-selection{background:#8b91a2}::ng-deep .ng5-slider[disabled] .ng5-slider-tick{cursor:not-allowed}::ng-deep .ng5-slider[disabled] .ng5-slider-tick.ng5-slider-selected{background:#8b91a2}::ng-deep .ng5-slider .ng5-slider-span{white-space:nowrap;position:absolute;display:inline-block}::ng-deep .ng5-slider .ng5-slider-base{width:100%;height:100%;padding:0}::ng-deep .ng5-slider .ng5-slider-bar-wrapper{left:0;-webkit-box-sizing:border-box;box-sizing:border-box;margin-top:-16px;padding-top:16px;width:100%;height:32px;z-index:1}::ng-deep .ng5-slider .ng5-slider-draggable{cursor:move}::ng-deep .ng5-slider .ng5-slider-bar{left:0;width:100%;height:4px;z-index:1;background:#d8e0f3;border-radius:2px}::ng-deep .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-transparent .ng5-slider-bar{background:0 0}::ng-deep .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-left-out-selection .ng5-slider-bar{background:#df002d}::ng-deep .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-right-out-selection .ng5-slider-bar{background:#03a688}::ng-deep .ng5-slider .ng5-slider-selection{z-index:2;background:#0db9f0;border-radius:2px}::ng-deep .ng5-slider .ng5-slider-pointer{cursor:pointer;width:32px;height:32px;top:-14px;background-color:#0db9f0;z-index:3;border-radius:16px}::ng-deep .ng5-slider .ng5-slider-pointer:after{content:'';width:8px;height:8px;position:absolute;top:12px;left:12px;border-radius:4px;background:#fff}::ng-deep .ng5-slider .ng5-slider-pointer:hover:after{background-color:#fff}::ng-deep .ng5-slider .ng5-slider-pointer.ng5-slider-active{z-index:4}::ng-deep .ng5-slider .ng5-slider-pointer.ng5-slider-active:after{background-color:#451aff}::ng-deep .ng5-slider .ng5-slider-bubble{cursor:default;bottom:16px;padding:1px 3px;color:#55637d;font-size:16px}::ng-deep .ng5-slider .ng5-slider-bubble.ng5-slider-limit{color:#55637d}::ng-deep .ng5-slider .ng5-slider-ticks{-webkit-box-sizing:border-box;box-sizing:border-box;width:100%;height:0;position:absolute;left:0;top:-3px;margin:0;z-index:1;list-style:none}::ng-deep .ng5-slider .ng5-slider-ticks-values-under .ng5-slider-tick-value{top:auto;bottom:-36px}::ng-deep .ng5-slider .ng5-slider-tick{text-align:center;cursor:pointer;width:10px;height:10px;background:#d8e0f3;border-radius:50%;position:absolute;top:0;left:0;margin-left:11px}::ng-deep .ng5-slider .ng5-slider-tick.ng5-slider-selected{background:#0db9f0}::ng-deep .ng5-slider .ng5-slider-tick-value{position:absolute;top:-34px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0)}::ng-deep .ng5-slider .ng5-slider-tick-legend{position:absolute;top:24px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);max-width:50px;white-space:normal}::ng-deep .ng5-slider.vertical{position:relative;width:4px;height:100%;margin:0 20px;padding:0;vertical-align:baseline;-ms-touch-action:pan-x;touch-action:pan-x}::ng-deep .ng5-slider.vertical .ng5-slider-base{width:100%;height:100%;padding:0}::ng-deep .ng5-slider.vertical .ng5-slider-bar-wrapper{top:auto;left:0;margin:0 0 0 -16px;padding:0 0 0 16px;height:100%;width:32px}::ng-deep .ng5-slider.vertical .ng5-slider-bar{bottom:0;left:auto;width:4px;height:100%}::ng-deep .ng5-slider.vertical .ng5-slider-pointer{left:-14px!important;top:auto;bottom:0}::ng-deep .ng5-slider.vertical .ng5-slider-bubble{left:16px!important;bottom:0}::ng-deep .ng5-slider.vertical .ng5-slider-ticks{height:100%;width:0;left:-3px;top:0;z-index:1}::ng-deep .ng5-slider.vertical .ng5-slider-tick{vertical-align:middle;margin-left:auto;margin-top:11px}::ng-deep .ng5-slider.vertical .ng5-slider-tick-value{left:24px;top:auto;-webkit-transform:translate(0,-28%);transform:translate(0,-28%)}::ng-deep .ng5-slider.vertical .ng5-slider-tick-legend{top:auto;right:24px;-webkit-transform:translate(0,-28%);transform:translate(0,-28%);max-width:none;white-space:nowrap}::ng-deep .ng5-slider.vertical .ng5-slider-ticks-values-under .ng5-slider-tick-value{bottom:auto;left:auto;right:24px}::ng-deep .ng5-slider *{-webkit-transition:none;transition:none}::ng-deep .ng5-slider.animate .ng5-slider-bar-wrapper{-webkit-transition:all linear .3s;transition:all linear .3s}::ng-deep .ng5-slider.animate .ng5-slider-selection{-webkit-transition:background-color linear .3s;transition:background-color linear .3s}::ng-deep .ng5-slider.animate .ng5-slider-pointer{-webkit-transition:all linear .3s;transition:all linear .3s}::ng-deep .ng5-slider.animate .ng5-slider-bubble{-webkit-transition:all linear .3s;transition:all linear .3s}::ng-deep .ng5-slider.animate .ng5-slider-bubble.ng5-slider-limit{-webkit-transition:opacity linear .3s;transition:opacity linear .3s}::ng-deep .ng5-slider.animate .ng5-slider-bubble.ng5-slider-combined{-webkit-transition:opacity linear .3s;transition:opacity linear .3s}::ng-deep .ng5-slider.animate .ng5-slider-tick{-webkit-transition:background-color linear .3s;transition:background-color linear .3s}`],\n  host: { class: 'ng5-slider' },\n  providers: [NG5_SLIDER_CONTROL_VALUE_ACCESSOR]\n})\nexport class SliderComponent implements OnInit, AfterViewInit, OnChanges, OnDestroy, ControlValueAccessor {\n  // Model for low value of slider. For simple slider, this is the only input. For range slider, this is the low value.\n  @Input()\n  public value: number = null;\n  // Output for low value slider to support two-way bindings\n  @Output()\n  public valueChange: EventEmitter<number> = new EventEmitter();\n\n  // Model for high value of slider. Not used in simple slider. For range slider, this is the high value.\n  @Input()\n  public highValue: number = null;\n  // Output for high value slider to support two-way bindings\n  @Output()\n  public highValueChange: EventEmitter<number> = new EventEmitter();\n\n  // An object with all the other options of the slider.\n  // Each option can be updated at runtime and the slider will automatically be re-rendered.\n  @Input()\n  public options: Options = new Options();\n\n  // Event emitted when user starts interaction with the slider\n  @Output()\n  public userChangeStart: EventEmitter<ChangeContext> = new EventEmitter();\n\n  // Event emitted on each change coming from user interaction\n  @Output()\n  public userChange: EventEmitter<ChangeContext> = new EventEmitter();\n\n  // Event emitted when user finishes interaction with the slider\n  @Output()\n  public userChangeEnd: EventEmitter<ChangeContext> = new EventEmitter();\n\n  private manualRefreshSubscription: any;\n  // Input event that triggers slider refresh (re-positioning of slider elements)\n  @Input() set manualRefresh(manualRefresh: EventEmitter<void>) {\n    this.unsubscribeManualRefresh();\n\n    this.manualRefreshSubscription = manualRefresh.subscribe(() => {\n      setTimeout(() => this.calculateViewDimensionsAndDetectChanges());\n    });\n  }\n\n  private triggerFocusSubscription: any;\n  // Input event that triggers setting focus on given slider handle\n  @Input() set triggerFocus(triggerFocus: EventEmitter<void>) {\n    this.unsubscribeTriggerFocus();\n\n    this.triggerFocusSubscription = triggerFocus.subscribe((pointerType: PointerType) => {\n      this.focusPointer(pointerType);\n    });\n  }\n\n  // Slider type, true means range slider\n  public get range(): boolean {\n    return !ValueHelper.isNullOrUndefined(this.value) && !ValueHelper.isNullOrUndefined(this.highValue);\n  }\n\n  // Set to true if init method already executed\n  private initHasRun: boolean = false;\n\n  // Changes in model inputs are passed through this subject\n  // These are all changes coming in from outside the component through input bindings or reactive form inputs\n  private inputModelChangeSubject: Subject<InputModelChange> = new Subject<InputModelChange>();\n  private inputModelChangeSubscription: Subscription = null;\n\n  // Changes to model outputs are passed through this subject\n  // These are all changes that need to be communicated to output emitters and registered callbacks\n  private outputModelChangeSubject: Subject<OutputModelChange> = new Subject<OutputModelChange>();\n  private outputModelChangeSubscription: Subscription = null;\n\n  // Low value synced to model low value\n  private viewLowValue: number = null;\n  // High value synced to model high value\n  private viewHighValue: number = null;\n  // Options synced to model options, based on defaults\n  private viewOptions: Options = new Options();\n\n  // Half of the width or height of the slider handles\n  private handleHalfDimension: number = 0;\n  // Maximum position the slider handle can have\n  private maxHandlePosition: number = 0;\n\n  // Which handle is currently tracked for move events\n  private currentTrackingPointer: PointerType = null;\n  // Internal variable to keep track of the focus element\n  private currentFocusPointer: PointerType = null;\n  // Used to call onStart on the first keydown event\n  private firstKeyDown: boolean = false;\n  // Current touch id of touch event being handled\n  private touchId: number = null;\n  // Values recorded when first dragging the bar\n  private dragging: Dragging = new Dragging();\n\n  /* Slider DOM elements */\n\n  // Left selection bar outside two handles\n  @ViewChild('leftOuterSelectionBar', {read: SliderElementDirective})\n  private leftOuterSelectionBarElement: SliderElementDirective;\n\n  // Right selection bar outside two handles\n  @ViewChild('rightOuterSelectionBar', {read: SliderElementDirective})\n  private rightOuterSelectionBarElement: SliderElementDirective;\n\n  // The whole slider bar\n  @ViewChild('fullBar', {read: SliderElementDirective})\n  private fullBarElement: SliderElementDirective;\n\n  // Highlight between two handles\n  @ViewChild('selectionBar', {read: SliderElementDirective})\n  private selectionBarElement: SliderElementDirective;\n\n  // Left slider handle\n  @ViewChild('minHandle', {read: SliderHandleDirective})\n  private minHandleElement: SliderHandleDirective;\n\n  // Right slider handle\n  @ViewChild('maxHandle', {read: SliderHandleDirective})\n  private maxHandleElement: SliderHandleDirective;\n\n  // Floor label\n  @ViewChild('floorLabel', {read: SliderLabelDirective})\n  private floorLabelElement: SliderLabelDirective;\n\n  // Ceiling label\n  @ViewChild('ceilLabel', {read: SliderLabelDirective})\n  private ceilLabelElement: SliderLabelDirective;\n\n  // Label above the low value\n  @ViewChild('minHandleLabel', {read: SliderLabelDirective})\n  private minHandleLabelElement: SliderLabelDirective;\n\n  // Label above the high value\n  @ViewChild('maxHandleLabel', {read: SliderLabelDirective})\n  private maxHandleLabelElement: SliderLabelDirective;\n\n  // Combined label\n  @ViewChild('combinedLabel', {read: SliderLabelDirective})\n  private combinedLabelElement: SliderLabelDirective;\n\n  // The ticks\n  @ViewChild('ticksElement', {read: SliderElementDirective})\n  private ticksElement: SliderElementDirective;\n\n  // Optional custom template for displaying tooltips\n  @ContentChild('tooltipTemplate')\n  public tooltipTemplate: TemplateRef<any>;\n\n  // Host element class bindings\n  @HostBinding('class.vertical')\n  public sliderElementVerticalClass: boolean = false;\n  @HostBinding('class.animate')\n  public sliderElementAnimateClass: boolean = false;\n  @HostBinding('attr.disabled')\n  public sliderElementDisabledAttr: string = null;\n\n  // CSS styles and class flags\n  public barStyle: any = {};\n  public minPointerStyle: any = {};\n  public maxPointerStyle: any = {};\n  public fullBarTransparentClass: boolean = false;\n  public selectionBarDraggableClass: boolean = false;\n  public ticksUnderValuesClass: boolean = false;\n\n  // Whether to show/hide ticks\n  public get showTicks(): boolean {\n    return this.viewOptions.showTicks;\n  }\n\n  /* If tickStep is set or ticksArray is specified.\n     In this case, ticks values should be displayed below the slider. */\n  private intermediateTicks: boolean = false;\n  // Ticks array as displayed in view\n  public ticks: Tick[] = [];\n\n  // Event listeners\n  private eventListenerHelper: EventListenerHelper = null;\n  private onMoveEventListener: EventListener = null;\n  private onEndEventListener: EventListener = null;\n\n  // Observer for slider element resize events\n  private resizeObserver: ResizeObserver = null;\n\n  // Callbacks for reactive forms support\n  private onTouchedCallback: (value: any) => void = null;\n  private onChangeCallback: (value: any) => void = null;\n\n\n  public constructor(private renderer: Renderer2,\n              private elementRef: ElementRef,\n              private changeDetectionRef: ChangeDetectorRef,\n              private zone: NgZone) {\n    this.eventListenerHelper = new EventListenerHelper(this.renderer);\n  }\n\n  // OnInit interface\n  public ngOnInit(): void {\n    this.viewOptions = new Options();\n    Object.assign(this.viewOptions, this.options);\n\n    // We need to run these two things first, before the rest of the init in ngAfterViewInit(),\n    // because these two settings are set through @HostBinding and Angular change detection\n    // mechanism doesn't like them changing in ngAfterViewInit()\n    this.updateDisabledState();\n    this.updateVerticalState();\n  }\n\n  // AfterViewInit interface\n  public ngAfterViewInit(): void {\n    this.applyOptions();\n\n    this.subscribeInputModelChangeSubject(this.viewOptions.inputEventsInterval);\n    this.subscribeOutputModelChangeSubject(this.viewOptions.outputEventsInterval);\n\n    // Once we apply options, we need to normalise model values for the first time\n    this.renormaliseModelValues();\n\n    this.viewLowValue = this.modelValueToViewValue(this.value);\n    if (this.range) {\n      this.viewHighValue = this.modelValueToViewValue(this.highValue);\n    } else {\n      this.viewHighValue = null;\n    }\n\n    this.updateVerticalState(); // need to run this again to cover changes to slider elements\n    this.manageElementsStyle();\n    this.updateDisabledState();\n    this.calculateViewDimensions();\n    this.addAccessibility();\n    this.updateCeilLabel();\n    this.updateFloorLabel();\n    this.initHandles();\n    this.manageEventsBindings();\n\n    this.subscribeResizeObserver();\n\n    this.initHasRun = true;\n\n    // Run change detection manually to resolve some issues when init procedure changes values used in the view\n    this.changeDetectionRef.detectChanges();\n  }\n\n  // OnChanges interface\n  public ngOnChanges(changes: SimpleChanges): void {\n    // Always apply options first\n    if (!ValueHelper.isNullOrUndefined(changes.options)) {\n      this.onChangeOptions();\n    }\n\n    // Then value changes\n    if (!ValueHelper.isNullOrUndefined(changes.value) ||\n        !ValueHelper.isNullOrUndefined(changes.highValue)) {\n      this.inputModelChangeSubject.next({\n        value: this.value,\n        highValue: this.highValue,\n        forceChange: false,\n        internalChange: false\n      });\n    }\n  }\n\n  // OnDestroy interface\n  public ngOnDestroy(): void {\n    this.unbindEvents();\n\n    this.unsubscribeResizeObserver();\n    this.unsubscribeInputModelChangeSubject();\n    this.unsubscribeOutputModelChangeSubject();\n    this.unsubscribeManualRefresh();\n    this.unsubscribeTriggerFocus();\n  }\n\n  // ControlValueAccessor interface\n  public writeValue(obj: any): void {\n    if (obj instanceof Array) {\n      this.value = obj[0];\n      this.highValue = obj[1];\n    } else {\n      this.value = obj;\n    }\n\n    // ngOnChanges() is not called in this instance, so we need to communicate the change manually\n    this.inputModelChangeSubject.next({\n      value: this.value,\n      highValue: this.highValue,\n      forceChange: false,\n      internalChange: false\n    });\n  }\n\n  // ControlValueAccessor interface\n  public registerOnChange(onChangeCallback: any): void {\n    this.onChangeCallback = onChangeCallback;\n  }\n\n  // ControlValueAccessor interface\n  public registerOnTouched(onTouchedCallback: any): void {\n    this.onTouchedCallback = onTouchedCallback;\n  }\n\n  // ControlValueAccessor interface\n  public setDisabledState(isDisabled: boolean): void {\n    this.viewOptions.disabled = isDisabled;\n    this.updateDisabledState();\n  }\n\n  @HostListener('window:resize', ['$event'])\n  public onResize(event: any): void {\n    this.calculateViewDimensionsAndDetectChanges();\n  }\n\n  private subscribeInputModelChangeSubject(interval?: number): void {\n    this.inputModelChangeSubscription = this.inputModelChangeSubject\n    .pipe(\n      distinctUntilChanged(ModelChange.compare),\n      // Hack to reset the status of the distinctUntilChanged() - if a \"fake\" event comes through with forceChange=true,\n      // we forcefully by-pass distinctUntilChanged(), but otherwise drop the event\n      filter((modelChange: InputModelChange) => !modelChange.forceChange && !modelChange.internalChange),\n      (!ValueHelper.isNullOrUndefined(interval))\n          ? throttleTime(interval, undefined, { leading: true, trailing: true})\n          : tap(() => {}) // no-op\n    )\n    .subscribe((modelChange: InputModelChange) => this.applyInputModelChange(modelChange));\n  }\n\n  private subscribeOutputModelChangeSubject(interval?: number): void {\n    this.outputModelChangeSubscription = this.outputModelChangeSubject\n      .pipe(\n        distinctUntilChanged(ModelChange.compare),\n        (!ValueHelper.isNullOrUndefined(interval))\n          ? throttleTime(interval, undefined, { leading: true, trailing: true})\n          : tap(() => {}) // no-op\n      )\n      .subscribe((modelChange: OutputModelChange) => this.publishOutputModelChange(modelChange));\n  }\n\n  private subscribeResizeObserver(): void {\n    if (CompatibilityHelper.isResizeObserverAvailable()) {\n      this.resizeObserver = new ResizeObserver((): void => this.calculateViewDimensionsAndDetectChanges());\n      this.resizeObserver.observe(this.elementRef.nativeElement);\n    }\n  }\n\n  private unsubscribeResizeObserver(): void {\n    if (CompatibilityHelper.isResizeObserverAvailable() && this.resizeObserver !== null) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n  }\n\n  private unsubscribeOnMove(): void {\n    if (!ValueHelper.isNullOrUndefined(this.onMoveEventListener)) {\n      this.eventListenerHelper.detachEventListener(this.onMoveEventListener);\n      this.onMoveEventListener = null;\n    }\n  }\n\n  private unsubscribeOnEnd(): void {\n    if (!ValueHelper.isNullOrUndefined(this.onEndEventListener)) {\n      this.eventListenerHelper.detachEventListener(this.onEndEventListener);\n      this.onEndEventListener = null;\n    }\n  }\n\n  private unsubscribeInputModelChangeSubject(): void {\n    if (!ValueHelper.isNullOrUndefined(this.inputModelChangeSubscription)) {\n      this.inputModelChangeSubscription.unsubscribe();\n      this.inputModelChangeSubscription = null;\n    }\n  }\n\n  private unsubscribeOutputModelChangeSubject(): void {\n    if (!ValueHelper.isNullOrUndefined(this.outputModelChangeSubscription)) {\n      this.outputModelChangeSubscription.unsubscribe();\n      this.outputModelChangeSubscription = null;\n    }\n  }\n\n  private unsubscribeManualRefresh(): void {\n    if (!ValueHelper.isNullOrUndefined(this.manualRefreshSubscription)) {\n      this.manualRefreshSubscription.unsubscribe();\n      this.manualRefreshSubscription = null;\n    }\n  }\n\n  private unsubscribeTriggerFocus(): void {\n    if (!ValueHelper.isNullOrUndefined(this.triggerFocusSubscription)) {\n      this.triggerFocusSubscription.unsubscribe();\n      this.triggerFocusSubscription = null;\n    }\n  }\n\n  private getPointerElement(pointerType: PointerType): SliderHandleDirective {\n    if (pointerType === PointerType.Min) {\n      return this.minHandleElement;\n    } else if (pointerType === PointerType.Max) {\n      return this.maxHandleElement;\n    }\n    return null;\n  }\n\n  private getCurrentTrackingValue(): number {\n    if (this.currentTrackingPointer === PointerType.Min) {\n      return this.viewLowValue;\n    } else if (this.currentTrackingPointer === PointerType.Max) {\n      return this.viewHighValue;\n    }\n    return null;\n  }\n\n  private modelValueToViewValue(modelValue: number): number {\n    if (ValueHelper.isNullOrUndefined(modelValue)) {\n      return NaN;\n    }\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n      return ValueHelper.findStepIndex(+modelValue, this.viewOptions.stepsArray);\n    }\n    return +modelValue;\n  }\n\n  private viewValueToModelValue(viewValue: number): number {\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n      return this.getStepValue(viewValue);\n    }\n    return viewValue;\n  }\n\n  private getStepValue(sliderValue: number): number {\n    const step: CustomStepDefinition = this.viewOptions.stepsArray[sliderValue];\n    return (!ValueHelper.isNullOrUndefined(step)) ? step.value : NaN;\n  }\n\n  private applyViewChange(): void {\n    this.value = this.viewValueToModelValue(this.viewLowValue);\n    if (this.range) {\n      this.highValue = this.viewValueToModelValue(this.viewHighValue);\n    }\n\n    this.outputModelChangeSubject.next({\n      value: this.value,\n      highValue: this.highValue,\n      userEventInitiated: true,\n      forceChange: false\n    });\n\n    // At this point all changes are applied and outputs are emitted, so we should be done.\n    // However, input changes are communicated in different stream and we need to be ready to\n    // act on the next input change even if it is exactly the same as last input change.\n    // Therefore, we send a special event to reset the stream.\n    this.inputModelChangeSubject.next({\n      value: this.value,\n      highValue: this.highValue,\n      forceChange: false,\n      internalChange: true\n    });\n  }\n\n  // Apply model change to the slider view\n  private applyInputModelChange(modelChange: InputModelChange): void {\n    const normalisedModelChange: ModelValues = this.normaliseModelValues(modelChange);\n\n    // If normalised model change is different, apply the change to the model values\n    const normalisationChange: boolean = !ModelValues.compare(modelChange, normalisedModelChange);\n    if (normalisationChange) {\n      this.value = normalisedModelChange.value;\n      this.highValue = normalisedModelChange.highValue;\n    }\n\n    this.viewLowValue = this.modelValueToViewValue(normalisedModelChange.value);\n    if (this.range) {\n      this.viewHighValue = this.modelValueToViewValue(normalisedModelChange.highValue);\n    } else {\n      this.viewHighValue = null;\n    }\n\n    this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n    if (this.range) {\n      this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n    }\n    this.updateSelectionBar();\n    this.updateTicksScale();\n    this.updateAriaAttributes();\n    if (this.range) {\n      this.updateCombinedLabel();\n    }\n\n    // At the end, we need to communicate the model change to the outputs as well\n    // Normalisation changes are also always forced out to ensure that subscribers always end up in correct state\n    this.outputModelChangeSubject.next({\n      value: normalisedModelChange.value,\n      highValue: normalisedModelChange.highValue,\n      forceChange: normalisationChange,\n      userEventInitiated: false\n    });\n  }\n\n  // Publish model change to output event emitters and registered callbacks\n  private publishOutputModelChange(modelChange: OutputModelChange): void {\n    const emitOutputs: () => void = (): void => {\n      this.valueChange.emit(modelChange.value);\n      if (this.range) {\n        this.highValueChange.emit(modelChange.highValue);\n      }\n\n      if (!ValueHelper.isNullOrUndefined(this.onChangeCallback)) {\n        if (this.range) {\n          this.onChangeCallback([modelChange.value, modelChange.highValue]);\n        } else {\n          this.onChangeCallback(modelChange.value);\n        }\n      }\n      if (!ValueHelper.isNullOrUndefined(this.onTouchedCallback)) {\n        if (this.range) {\n          this.onTouchedCallback([modelChange.value, modelChange.highValue]);\n        } else {\n          this.onTouchedCallback(modelChange.value);\n        }\n      }\n    };\n\n    if (modelChange.userEventInitiated) {\n      // If this change was initiated by a user event, we can emit outputs in the same tick\n      emitOutputs();\n      this.userChange.emit(this.getChangeContext());\n    } else {\n      // But, if the change was initated by something else like a change in input bindings,\n      // we need to wait until next tick to emit the outputs to keep Angular change detection happy\n      setTimeout(() => { emitOutputs(); });\n    }\n  }\n\n  private normaliseModelValues(input: ModelValues): ModelValues {\n    const normalisedInput: ModelValues = new ModelValues();\n    normalisedInput.value = input.value;\n    normalisedInput.highValue = input.highValue;\n\n    if (this.viewOptions.enforceStep) {\n      normalisedInput.value = this.roundStep(normalisedInput.value);\n      if (this.range) {\n        normalisedInput.highValue = this.roundStep(normalisedInput.highValue);\n      }\n    }\n\n    // Don't attempt to normalise further when using steps array (steps may be out of order and that is perfectly fine)\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) || !this.viewOptions.enforceRange) {\n      return normalisedInput;\n    }\n\n    normalisedInput.value = MathHelper.clampToRange(normalisedInput.value, this.viewOptions.floor, this.viewOptions.ceil);\n\n    if (this.range) {\n      normalisedInput.highValue = MathHelper.clampToRange(normalisedInput.highValue, this.viewOptions.floor, this.viewOptions.ceil);\n    }\n\n    // Make sure that range slider invariant (value <= highValue) is always satisfied\n    if (this.range && input.value > input.highValue) {\n      // We know that both values are now clamped correctly, they may just be in the wrong order\n      // So the easy solution is to swap them... except swapping is sometimes disabled in options, so we make the two values the same\n      if (this.viewOptions.noSwitching) {\n        normalisedInput.value = normalisedInput.highValue;\n      } else {\n        const tempValue: number = input.value;\n        normalisedInput.value = input.highValue;\n        normalisedInput.highValue = tempValue;\n      }\n    }\n\n    return normalisedInput;\n  }\n\n  private renormaliseModelValues(): void {\n    const previousModelValues: ModelValues = {\n      value: this.value,\n      highValue: this.highValue\n    };\n    const normalisedModelValues: ModelValues = this.normaliseModelValues(previousModelValues);\n    if (!ModelValues.compare(normalisedModelValues, previousModelValues)) {\n      this.value = normalisedModelValues.value;\n      this.highValue = normalisedModelValues.highValue;\n\n      this.outputModelChangeSubject.next({\n        value: this.value,\n        highValue: this.highValue,\n        forceChange: true,\n        userEventInitiated: false\n      });\n    }\n  }\n\n  private onChangeOptions(): void {\n    if (!this.initHasRun) {\n      return;\n    }\n\n    const previousInputEventsInterval: number = this.viewOptions.inputEventsInterval;\n    const previousOutputEventsInterval: number = this.viewOptions.outputEventsInterval;\n\n    this.applyOptions();\n\n    if (previousInputEventsInterval !== this.viewOptions.inputEventsInterval) {\n      this.unsubscribeInputModelChangeSubject();\n      this.subscribeInputModelChangeSubject(this.viewOptions.inputEventsInterval);\n    }\n\n    if (previousOutputEventsInterval !== this.viewOptions.outputEventsInterval) {\n      this.unsubscribeInputModelChangeSubject();\n      this.subscribeInputModelChangeSubject(this.viewOptions.outputEventsInterval);\n    }\n\n    // With new options, we need to re-normalise model values if necessary\n    this.renormaliseModelValues();\n\n    this.viewLowValue = this.modelValueToViewValue(this.value);\n    if (this.range) {\n      this.viewHighValue = this.modelValueToViewValue(this.highValue);\n    } else {\n      this.viewHighValue = null;\n    }\n\n    this.resetSlider();\n  }\n\n  // Read the user options and apply them to the slider model\n  private applyOptions(): void {\n    this.viewOptions = new Options();\n    Object.assign(this.viewOptions, this.options);\n\n    this.viewOptions.draggableRange = this.range && this.viewOptions.draggableRange;\n    this.viewOptions.draggableRangeOnly = this.range && this.viewOptions.draggableRangeOnly;\n    if (this.viewOptions.draggableRangeOnly) {\n      this.viewOptions.draggableRange = true;\n    }\n\n    this.viewOptions.showTicks = this.viewOptions.showTicks ||\n      this.viewOptions.showTicksValues ||\n      !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray);\n    if (this.viewOptions.showTicks &&\n       (!ValueHelper.isNullOrUndefined(this.viewOptions.tickStep) || !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray))) {\n      this.intermediateTicks = true;\n    }\n\n    this.viewOptions.showSelectionBar = this.viewOptions.showSelectionBar ||\n      this.viewOptions.showSelectionBarEnd ||\n      !ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue);\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray)) {\n      this.applyStepsArrayOptions();\n    } else {\n      this.applyFloorCeilOptions();\n    }\n\n    if (ValueHelper.isNullOrUndefined(this.viewOptions.combineLabels)) {\n      this.viewOptions.combineLabels = (minValue: string, maxValue: string): string => {\n        return minValue + ' - ' + maxValue;\n      };\n    }\n\n    if (this.viewOptions.logScale && this.viewOptions.floor === 0) {\n      throw Error('Can\\'t use floor=0 with logarithmic scale');\n    }\n  }\n\n  private applyStepsArrayOptions(): void {\n    this.viewOptions.floor = 0;\n    this.viewOptions.ceil = this.viewOptions.stepsArray.length - 1;\n    this.viewOptions.step = 1;\n\n    if (ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {\n      this.viewOptions.translate = (modelValue: number): string => {\n        if (this.viewOptions.bindIndexForStepsArray) {\n          return String(this.getStepValue(modelValue));\n        }\n        return String(modelValue);\n      };\n    }\n\n    this.viewOptions.getLegend = (index: number): string => {\n      const step: CustomStepDefinition = this.viewOptions.stepsArray[index];\n      return step.legend;\n    };\n  }\n\n  private applyFloorCeilOptions(): void {\n    if (ValueHelper.isNullOrUndefined(this.viewOptions.step)) {\n      this.viewOptions.step = 1;\n    } else {\n      this.viewOptions.step = +this.viewOptions.step;\n      if (this.viewOptions.step <= 0) {\n        this.viewOptions.step = 1;\n     }\n    }\n\n    if (ValueHelper.isNullOrUndefined(this.viewOptions.ceil) ||\n        ValueHelper.isNullOrUndefined(this.viewOptions.floor)) {\n      throw Error('floor and ceil options must be supplied');\n    }\n    this.viewOptions.ceil = +this.viewOptions.ceil;\n    this.viewOptions.floor = +this.viewOptions.floor;\n\n    if (ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {\n      this.viewOptions.translate = (value: number): string => String(value);\n    }\n  }\n\n  // Resets slider\n  private resetSlider(): void {\n    this.manageElementsStyle();\n    this.addAccessibility();\n    this.updateCeilLabel();\n    this.updateFloorLabel();\n    this.unbindEvents();\n    this.manageEventsBindings();\n    this.updateDisabledState();\n    this.calculateViewDimensions();\n    this.refocusPointerIfNeeded();\n  }\n\n  // Sets focus on the specified pointer\n  private focusPointer(pointerType: PointerType): void {\n    // If not supplied, use min pointer as default\n    if (pointerType !== PointerType.Min && pointerType !== PointerType.Max) {\n      pointerType = PointerType.Min;\n    }\n\n    if (pointerType === PointerType.Min) {\n      this.minHandleElement.focus();\n    } else if (this.range && pointerType === PointerType.Max) {\n      this.maxHandleElement.focus();\n    }\n  }\n\n  private refocusPointerIfNeeded(): void {\n    if (!ValueHelper.isNullOrUndefined(this.currentFocusPointer)) {\n      this.onPointerFocus(this.currentFocusPointer);\n      const element: SliderHandleDirective = this.getPointerElement(this.currentFocusPointer);\n      element.focus();\n    }\n  }\n\n  // Update each elements style based on options\n  private manageElementsStyle(): void {\n    this.updateScale();\n\n    this.floorLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n    this.ceilLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n\n    const hideLabelsForTicks: boolean = this.viewOptions.showTicksValues && !this.intermediateTicks;\n    this.minHandleLabelElement.setAlwaysHide(hideLabelsForTicks || this.viewOptions.hidePointerLabels);\n    this.maxHandleLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n    this.combinedLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n    this.selectionBarElement.setAlwaysHide(!this.range && !this.viewOptions.showSelectionBar);\n    this.leftOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);\n    this.rightOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);\n\n    this.fullBarTransparentClass = this.range && this.viewOptions.showOuterSelectionBars;\n    this.selectionBarDraggableClass = this.viewOptions.draggableRange && !this.viewOptions.onlyBindHandles;\n    this.ticksUnderValuesClass = this.intermediateTicks && this.options.showTicksValues;\n\n    if (this.sliderElementVerticalClass !== this.viewOptions.vertical) {\n      this.updateVerticalState();\n      // The above change in host component class will not be applied until the end of this cycle\n      // However, functions calculating the slider position expect the slider to be already styled as vertical\n      // So as a workaround, we need to reset the slider once again to compute the correct values\n      setTimeout((): void => { this.resetSlider(); });\n    }\n\n    // Changing animate class may interfere with slider reset/initialisation, so we should set it separately,\n    // after all is properly set up\n    if (this.sliderElementAnimateClass !== this.viewOptions.animate) {\n      setTimeout((): void => { this.sliderElementAnimateClass = this.viewOptions.animate; });\n    }\n  }\n\n  // Manage the events bindings based on readOnly and disabled options\n  private manageEventsBindings(): void {\n    if (this.viewOptions.disabled || this.viewOptions.readOnly) {\n      this.unbindEvents();\n    } else {\n      this.bindEvents();\n    }\n  }\n\n  // Set the disabled state based on disabled option\n  private updateDisabledState(): void {\n    this.sliderElementDisabledAttr = this.viewOptions.disabled ? 'disabled' : null;\n  }\n\n  // Set vertical state based on vertical option\n  private updateVerticalState(): void {\n    this.sliderElementVerticalClass = this.viewOptions.vertical;\n    for (const element of this.getAllSliderElements()) {\n      // This is also called before ngAfterInit, so need to check that view child bindings work\n      if (!ValueHelper.isNullOrUndefined(element)) {\n        element.setVertical(this.viewOptions.vertical);\n      }\n    }\n  }\n\n  private updateScale(): void {\n    for (const element of this.getAllSliderElements()) {\n      element.setScale(this.viewOptions.scale);\n    }\n  }\n\n  private getAllSliderElements(): SliderElementDirective[] {\n    return [this.leftOuterSelectionBarElement,\n      this.rightOuterSelectionBarElement,\n      this.fullBarElement,\n      this.selectionBarElement,\n      this.minHandleElement,\n      this.maxHandleElement,\n      this.floorLabelElement,\n      this.ceilLabelElement,\n      this.minHandleLabelElement,\n      this.maxHandleLabelElement,\n      this.combinedLabelElement,\n      this.ticksElement\n    ];\n  }\n\n  // Initialize slider handles positions and labels\n  // Run only once during initialization and every time view port changes size\n  private initHandles(): void {\n    this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n\n    /*\n   the order here is important since the selection bar should be\n   updated after the high handle but before the combined label\n   */\n    if (this.range) {\n      this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n    }\n\n    this.updateSelectionBar();\n\n    if (this.range) {\n      this.updateCombinedLabel();\n    }\n\n    this.updateTicksScale();\n  }\n\n  // Adds accessibility attributes, run only once during initialization\n  private addAccessibility(): void {\n    this.updateAriaAttributes();\n\n    this.minHandleElement.role = 'slider';\n\n    if ( this.viewOptions.keyboardSupport &&\n      !(this.viewOptions.readOnly || this.viewOptions.disabled) ) {\n      this.minHandleElement.tabindex = '0';\n    } else {\n      this.minHandleElement.tabindex = '';\n    }\n\n    if (this.viewOptions.vertical) {\n      this.minHandleElement.ariaOrientation = 'vertical';\n    }\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabel)) {\n      this.minHandleElement.ariaLabel = this.viewOptions.ariaLabel;\n    } else if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledBy)) {\n      this.minHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledBy;\n    }\n\n    if (this.range) {\n      this.maxHandleElement.role = 'slider';\n\n      if (this.viewOptions.keyboardSupport &&\n        !(this.viewOptions.readOnly || this.viewOptions.disabled)) {\n        this.maxHandleElement.tabindex = '0';\n      } else {\n        this.maxHandleElement.tabindex = '';\n      }\n\n      this.maxHandleElement.ariaOrientation = this.viewOptions.vertical ? 'vertical' : 'horizontal';\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelHigh)) {\n        this.maxHandleElement.ariaLabel = this.viewOptions.ariaLabelHigh;\n      } else if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledByHigh)) {\n        this.maxHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledByHigh;\n      }\n    }\n  }\n\n  // Updates aria attributes according to current values\n  private updateAriaAttributes(): void {\n    this.minHandleElement.ariaValueNow = (+this.value).toString();\n    this.minHandleElement.ariaValueText = this.viewOptions.translate(+this.value, LabelType.Low);\n    this.minHandleElement.ariaValueMin = this.viewOptions.floor.toString();\n    this.minHandleElement.ariaValueMax = this.viewOptions.ceil.toString();\n\n    if (this.range) {\n      this.maxHandleElement.ariaValueNow = (+this.highValue).toString();\n      this.maxHandleElement.ariaValueText = this.viewOptions.translate(+this.highValue, LabelType.High);\n      this.maxHandleElement.ariaValueMin = this.viewOptions.floor.toString();\n      this.maxHandleElement.ariaValueMax = this.viewOptions.ceil.toString();\n    }\n  }\n\n  // Calculate dimensions that are dependent on view port size\n  // Run once during initialization and every time view port changes size.\n  private calculateViewDimensions(): void {\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.handleDimension)) {\n      this.minHandleElement.setDimension(this.viewOptions.handleDimension);\n    } else {\n      this.minHandleElement.calculateDimension();\n    }\n\n    const handleWidth: number = this.minHandleElement.dimension;\n\n    this.handleHalfDimension = handleWidth / 2;\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.barDimension)) {\n      this.fullBarElement.setDimension(this.viewOptions.barDimension);\n    } else {\n      this.fullBarElement.calculateDimension();\n    }\n\n    this.maxHandlePosition = this.fullBarElement.dimension - handleWidth;\n\n    if (this.initHasRun) {\n      this.updateFloorLabel();\n      this.updateCeilLabel();\n      this.initHandles();\n    }\n  }\n\n  private calculateViewDimensionsAndDetectChanges(): void {\n    this.calculateViewDimensions();\n    this.changeDetectionRef.detectChanges();\n  }\n\n  // Update the ticks position\n  private updateTicksScale(): void {\n    if (!this.viewOptions.showTicks) {\n      return;\n    }\n\n    const ticksArray: number[] = !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray)\n      ? this.viewOptions.ticksArray\n      : this.getTicksArray();\n    const translate: string = this.viewOptions.vertical ? 'translateY' : 'translateX';\n\n    if (this.viewOptions.rightToLeft) {\n      ticksArray.reverse();\n    }\n\n    const newTicks: Tick[] = ticksArray.map((value: number): Tick => {\n      let position: number = this.valueToPosition(value);\n\n      if (this.viewOptions.vertical) {\n        position = this.maxHandlePosition - position;\n      }\n\n      const translation: string = translate + '(' + Math.round(position) + 'px)';\n      const tick: Tick = new Tick();\n      tick.selected = this.isTickSelected(value);\n      tick.style = {\n        '-webkit-transform': translation,\n        '-moz-transform': translation,\n        '-o-transform': translation,\n        '-ms-transform': translation,\n        transform: translation,\n      };\n      if (tick.selected && !ValueHelper.isNullOrUndefined(this.viewOptions.getSelectionBarColor)) {\n        tick.style['background-color'] = this.getSelectionBarColor();\n      }\n      if (!tick.selected && !ValueHelper.isNullOrUndefined(this.viewOptions.getTickColor)) {\n        tick.style['background-color'] = this.getTickColor(value);\n      }\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.ticksTooltip)) {\n        tick.tooltip = this.viewOptions.ticksTooltip(value);\n        tick.tooltipPlacement = this.viewOptions.vertical ? 'right' : 'top';\n      }\n      if (this.viewOptions.showTicksValues && (value % this.viewOptions.tickValueStep === 0)) {\n        tick.value = this.getDisplayValue(value, LabelType.TickValue);\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.ticksValuesTooltip)) {\n          tick.valueTooltip = this.viewOptions.ticksValuesTooltip(value);\n          tick.valueTooltipPlacement = this.viewOptions.vertical\n            ? 'right'\n            : 'top';\n        }\n      }\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.getLegend)) {\n        const legend: string = this.viewOptions.getLegend(value);\n        if (!ValueHelper.isNullOrUndefined(legend)) {\n          tick.legend = legend;\n        }\n      }\n      return tick;\n    });\n\n    // We should avoid re-creating the ticks array if possible\n    // This both improves performance and makes CSS animations work correctly\n    if (!ValueHelper.isNullOrUndefined(this.ticks) && this.ticks.length === newTicks.length) {\n      for (let i: number = 0; i  < newTicks.length; ++i) {\n        Object.assign(this.ticks[i], newTicks[i]);\n      }\n    } else {\n      this.ticks = newTicks;\n    }\n\n    this.changeDetectionRef.detectChanges();\n  }\n\n  private getTicksArray(): number[] {\n    const step: number = (!ValueHelper.isNullOrUndefined(this.viewOptions.tickStep)) ? this.viewOptions.tickStep : this.viewOptions.step;\n    const ticksArray: number[] = [];\n    for (let value: number = this.viewOptions.floor; value <= this.viewOptions.ceil; value += step) {\n      ticksArray.push(value);\n    }\n    return ticksArray;\n  }\n\n  private isTickSelected(value: number): boolean {\n    if (!this.range) {\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {\n        const center: number = this.viewOptions.showSelectionBarFromValue;\n        if (this.viewLowValue > center &&\n            value >= center &&\n            value <= this.viewLowValue) {\n          return true;\n        } else if (this.viewLowValue < center &&\n                   value <= center &&\n                   value >= this.viewLowValue) {\n          return true;\n        }\n      } else if (this.viewOptions.showSelectionBarEnd) {\n        if (value >= this.viewLowValue) {\n          return true;\n        }\n      } else if (this.viewOptions.showSelectionBar && value <= this.viewLowValue) {\n        return true;\n      }\n    }\n\n    if (this.range && value >= this.viewLowValue && value <= this.viewHighValue) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Update position of the floor label\n  private updateFloorLabel(): void {\n    if (!this.floorLabelElement.alwaysHide) {\n      this.floorLabelElement.setValue(this.getDisplayValue(this.viewOptions.floor, LabelType.Floor));\n      this.floorLabelElement.calculateDimension();\n      const position: number = this.viewOptions.rightToLeft\n        ? this.fullBarElement.dimension - this.floorLabelElement.dimension\n        : 0;\n      this.floorLabelElement.setPosition(position);\n    }\n  }\n\n  // Update position of the ceiling label\n  private updateCeilLabel(): void {\n    if (!this.ceilLabelElement.alwaysHide) {\n      this.ceilLabelElement.setValue(this.getDisplayValue(this.viewOptions.ceil, LabelType.Ceil));\n      this.ceilLabelElement.calculateDimension();\n      const position: number = this.viewOptions.rightToLeft\n        ? 0\n        : this.fullBarElement.dimension - this.ceilLabelElement.dimension;\n      this.ceilLabelElement.setPosition(position);\n    }\n  }\n\n  // Update slider handles and label positions\n  private updateHandles(which: PointerType, newPos: number): void {\n    if (which === PointerType.Min) {\n      this.updateLowHandle(newPos);\n    } else if (which === PointerType.Max) {\n      this.updateHighHandle(newPos);\n    }\n\n    this.updateSelectionBar();\n    this.updateTicksScale();\n    if (this.range) {\n      this.updateCombinedLabel();\n    }\n  }\n\n  // Helper function to work out the position for handle labels depending on RTL or not\n  private getHandleLabelPos(labelType: PointerType, newPos: number): number {\n    const labelDimension: number = (labelType === PointerType.Min)\n      ? this.minHandleLabelElement.dimension\n      : this.maxHandleLabelElement.dimension;\n    const nearHandlePos: number = newPos - labelDimension / 2 + this.handleHalfDimension;\n    const endOfBarPos: number = this.fullBarElement.dimension - labelDimension;\n\n    if (!this.viewOptions.boundPointerLabels) {\n      return nearHandlePos;\n    }\n\n    if ((this.viewOptions.rightToLeft && labelType === PointerType.Min) ||\n       (!this.viewOptions.rightToLeft && labelType === PointerType.Max)) {\n      return Math.min(nearHandlePos, endOfBarPos);\n    } else {\n      return Math.min(Math.max(nearHandlePos, 0), endOfBarPos);\n    }\n  }\n\n  // Update low slider handle position and label\n  private updateLowHandle(newPos: number): void {\n    this.minHandleElement.setPosition(newPos);\n    this.minHandleLabelElement.setValue(this.getDisplayValue(this.viewLowValue, LabelType.Low));\n    this.minHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Min, newPos));\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {\n      this.minPointerStyle = {\n        backgroundColor: this.getPointerColor(PointerType.Min),\n      };\n    }\n\n    if (this.viewOptions.autoHideLimitLabels) {\n      this.updateFloorAndCeilLabelsVisibility();\n    }\n  }\n\n  // Update high slider handle position and label\n  private updateHighHandle(newPos: number): void {\n    this.maxHandleElement.setPosition(newPos);\n    this.maxHandleLabelElement.setValue(this.getDisplayValue(this.viewHighValue, LabelType.High));\n    this.maxHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Max, newPos));\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {\n      this.maxPointerStyle = {\n        backgroundColor: this.getPointerColor(PointerType.Max),\n      };\n    }\n    if (this.viewOptions.autoHideLimitLabels) {\n      this.updateFloorAndCeilLabelsVisibility();\n    }\n  }\n\n  // Show/hide floor/ceiling label\n  private updateFloorAndCeilLabelsVisibility(): void {\n    // Show based only on hideLimitLabels if pointer labels are hidden\n    if (this.viewOptions.hidePointerLabels) {\n      return;\n    }\n    let floorLabelHidden: boolean = false;\n    let ceilLabelHidden: boolean = false;\n    const isMinLabelAtFloor: boolean = this.isLabelBelowFloorLabel(this.minHandleLabelElement);\n    const isMinLabelAtCeil: boolean = this.isLabelAboveCeilLabel(this.minHandleLabelElement);\n    const isMaxLabelAtCeil: boolean = this.isLabelAboveCeilLabel(this.maxHandleLabelElement);\n    const isCombinedLabelAtFloor: boolean = this.isLabelBelowFloorLabel(this.combinedLabelElement);\n    const isCombinedLabelAtCeil: boolean = this.isLabelAboveCeilLabel(this.combinedLabelElement);\n\n    if (isMinLabelAtFloor) {\n      floorLabelHidden = true;\n      this.floorLabelElement.hide();\n    } else {\n      floorLabelHidden = false;\n      this.floorLabelElement.show();\n    }\n\n    if (isMinLabelAtCeil) {\n      ceilLabelHidden = true;\n      this.ceilLabelElement.hide();\n    } else {\n      ceilLabelHidden = false;\n      this.ceilLabelElement.show();\n    }\n\n    if (this.range) {\n      const hideCeil: boolean = this.combinedLabelElement.isVisible() ? isCombinedLabelAtCeil : isMaxLabelAtCeil;\n      const hideFloor: boolean = this.combinedLabelElement.isVisible() ? isCombinedLabelAtFloor : isMinLabelAtFloor;\n\n      if (hideCeil) {\n        this.ceilLabelElement.hide();\n      } else if (!ceilLabelHidden) {\n        this.ceilLabelElement.show();\n      }\n\n      // Hide or show floor label\n      if (hideFloor) {\n        this.floorLabelElement.hide();\n      } else if (!floorLabelHidden) {\n        this.floorLabelElement.show();\n      }\n    }\n  }\n\n  private isLabelBelowFloorLabel(label: SliderLabelDirective): boolean {\n    const pos: number = label.position;\n    const dim: number = label.dimension;\n    const floorPos: number = this.floorLabelElement.position;\n    const floorDim: number = this.floorLabelElement.dimension;\n    return this.viewOptions.rightToLeft\n      ? pos + dim >= floorPos - 2\n      : pos <= floorPos + floorDim + 2;\n  }\n\n  private isLabelAboveCeilLabel(label: SliderLabelDirective): boolean {\n    const pos: number = label.position;\n    const dim: number = label.dimension;\n    const ceilPos: number = this.ceilLabelElement.position;\n    const ceilDim: number = this.ceilLabelElement.dimension;\n    return this.viewOptions.rightToLeft\n      ? pos <= ceilPos + ceilDim + 2\n      : pos + dim >= ceilPos - 2;\n  }\n\n  // Update slider selection bar, combined label and range label\n  private updateSelectionBar(): void {\n    let position: number = 0;\n    let dimension: number = 0;\n    const isSelectionBarFromRight: boolean = this.viewOptions.rightToLeft\n        ? !this.viewOptions.showSelectionBarEnd\n        : this.viewOptions.showSelectionBarEnd;\n    const positionForRange: number = this.viewOptions.rightToLeft\n        ? this.maxHandleElement.position + this.handleHalfDimension\n        : this.minHandleElement.position + this.handleHalfDimension;\n\n    if (this.range) {\n      dimension = Math.abs(this.maxHandleElement.position - this.minHandleElement.position);\n      position = positionForRange;\n    } else {\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {\n        const center: number = this.viewOptions.showSelectionBarFromValue;\n        const centerPosition: number = this.valueToPosition(center);\n        const isModelGreaterThanCenter: boolean = this.viewOptions.rightToLeft\n            ? this.viewLowValue <= center\n            : this.viewLowValue > center;\n        if (isModelGreaterThanCenter) {\n          dimension = this.minHandleElement.position - centerPosition;\n          position = centerPosition + this.handleHalfDimension;\n        } else {\n          dimension = centerPosition - this.minHandleElement.position;\n          position = this.minHandleElement.position + this.handleHalfDimension;\n        }\n      } else if (isSelectionBarFromRight) {\n        dimension = Math.ceil(Math.abs(this.maxHandlePosition - this.minHandleElement.position) + this.handleHalfDimension);\n        position = Math.floor(this.minHandleElement.position + this.handleHalfDimension);\n      } else {\n        dimension = this.minHandleElement.position + this.handleHalfDimension;\n        position = 0;\n      }\n    }\n    this.selectionBarElement.setDimension(dimension);\n    this.selectionBarElement.setPosition(position);\n    if (this.range && this.viewOptions.showOuterSelectionBars) {\n      if (this.viewOptions.rightToLeft) {\n        this.rightOuterSelectionBarElement.setDimension(position);\n        this.rightOuterSelectionBarElement.setPosition(0);\n        this.fullBarElement.calculateDimension();\n        this.leftOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));\n        this.leftOuterSelectionBarElement.setPosition(position + dimension);\n      } else {\n        this.leftOuterSelectionBarElement.setDimension(position);\n        this.leftOuterSelectionBarElement.setPosition(0);\n        this.fullBarElement.calculateDimension();\n        this.rightOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));\n        this.rightOuterSelectionBarElement.setPosition(position + dimension);\n      }\n    }\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.getSelectionBarColor)) {\n      const color: string = this.getSelectionBarColor();\n      this.barStyle = {\n        backgroundColor: color,\n      };\n    } else if (!ValueHelper.isNullOrUndefined(this.viewOptions.selectionBarGradient)) {\n      const offset: number = (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue))\n            ? this.valueToPosition(this.viewOptions.showSelectionBarFromValue)\n            : 0;\n      const reversed: boolean = (offset - position > 0 && !isSelectionBarFromRight) || (offset - position <= 0 && isSelectionBarFromRight);\n      const direction: string = this.viewOptions.vertical\n          ? reversed ? 'bottom' : 'top'\n          : reversed ? 'left' : 'right';\n      this.barStyle = {\n        backgroundImage:\n          'linear-gradient(to ' +\n          direction +\n          ', ' +\n          this.viewOptions.selectionBarGradient.from +\n          ' 0%,' +\n          this.viewOptions.selectionBarGradient.to +\n          ' 100%)',\n      };\n      if (this.viewOptions.vertical) {\n        this.barStyle.backgroundPosition =\n          'center ' +\n          (offset +\n            dimension +\n            position +\n            (reversed ? -this.handleHalfDimension : 0)) +\n          'px';\n        this.barStyle.backgroundSize =\n          '100% ' + (this.fullBarElement.dimension - this.handleHalfDimension) + 'px';\n      } else {\n        this.barStyle.backgroundPosition =\n          offset -\n          position +\n          (reversed ? this.handleHalfDimension : 0) +\n          'px center';\n        this.barStyle.backgroundSize =\n          this.fullBarElement.dimension - this.handleHalfDimension + 'px 100%';\n      }\n    }\n  }\n\n  // Wrapper around the getSelectionBarColor of the user to pass to correct parameters\n  private getSelectionBarColor(): string {\n    if (this.range) {\n      return this.viewOptions.getSelectionBarColor(\n        this.value,\n        this.highValue\n      );\n    }\n    return this.viewOptions.getSelectionBarColor(this.value);\n  }\n\n  // Wrapper around the getPointerColor of the user to pass to  correct parameters\n  private getPointerColor(pointerType: PointerType): string {\n    if (pointerType === PointerType.Max) {\n      return this.viewOptions.getPointerColor(\n        this.highValue,\n        pointerType\n      );\n    }\n    return this.viewOptions.getPointerColor(\n      this.value,\n      pointerType\n    );\n  }\n\n  // Wrapper around the getTickColor of the user to pass to correct parameters\n  private getTickColor(value: number): string {\n    return this.viewOptions.getTickColor(value);\n  }\n\n  // Update combined label position and value\n  private updateCombinedLabel(): void {\n    let isLabelOverlap: boolean = null;\n    if (this.viewOptions.rightToLeft) {\n      isLabelOverlap =\n        this.minHandleLabelElement.position - this.minHandleLabelElement.dimension - 10 <= this.maxHandleLabelElement.position;\n    } else {\n      isLabelOverlap =\n        this.minHandleLabelElement.position + this.minHandleLabelElement.dimension + 10 >= this.maxHandleLabelElement.position;\n    }\n\n    if (isLabelOverlap) {\n      const lowDisplayValue: string = this.getDisplayValue(this.viewLowValue, LabelType.Low);\n      const highDisplayValue: string = this.getDisplayValue(this.viewHighValue, LabelType.High);\n      const combinedLabelValue: string = this.viewOptions.rightToLeft\n        ? this.viewOptions.combineLabels(highDisplayValue, lowDisplayValue)\n        : this.viewOptions.combineLabels(lowDisplayValue, highDisplayValue);\n\n      this.combinedLabelElement.setValue(combinedLabelValue);\n      const pos: number = this.viewOptions.boundPointerLabels\n        ? Math.min(\n            Math.max(\n              this.selectionBarElement.position +\n                this.selectionBarElement.dimension / 2 -\n                this.combinedLabelElement.dimension / 2,\n              0\n            ),\n            this.fullBarElement.dimension - this.combinedLabelElement.dimension\n          )\n        : this.selectionBarElement.position + this.selectionBarElement.dimension / 2 - this.combinedLabelElement.dimension / 2;\n\n      this.combinedLabelElement.setPosition(pos);\n      this.minHandleLabelElement.hide();\n      this.maxHandleLabelElement.hide();\n      this.combinedLabelElement.show();\n    } else {\n      this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n      this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n      this.maxHandleLabelElement.show();\n      this.minHandleLabelElement.show();\n      this.combinedLabelElement.hide();\n    }\n    if (this.viewOptions.autoHideLimitLabels) {\n      this.updateFloorAndCeilLabelsVisibility();\n    }\n  }\n\n  // Return the translated value if a translate function is provided else the original value\n  private getDisplayValue(value: number, which: LabelType): string {\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n      value = this.getStepValue(value);\n    }\n    return this.viewOptions.translate(value, which);\n  }\n\n  // Round value to step and precision based on minValue\n  private roundStep(value: number, customStep?: number): number {\n    const step: number = !ValueHelper.isNullOrUndefined(customStep) ? customStep : this.viewOptions.step;\n    let steppedDifference: number = MathHelper.roundToPrecisionLimit(\n      (value - this.viewOptions.floor) / step, this.viewOptions.precisionLimit);\n    steppedDifference = Math.round(steppedDifference) * step;\n    return MathHelper.roundToPrecisionLimit(this.viewOptions.floor + steppedDifference, this.viewOptions.precisionLimit);\n  }\n\n  // Translate value to pixel position\n  private valueToPosition(val: number): number {\n    let fn: ValueToPositionFunction  = ValueHelper.linearValueToPosition;\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.customValueToPosition)) {\n      fn = this.viewOptions.customValueToPosition;\n    } else if (this.viewOptions.logScale) {\n      fn = ValueHelper.logValueToPosition;\n    }\n\n    val = MathHelper.clampToRange(val, this.viewOptions.floor, this.viewOptions.ceil);\n    let percent: number = fn(val, this.viewOptions.floor, this.viewOptions.ceil);\n    if (ValueHelper.isNullOrUndefined(percent)) {\n      percent = 0;\n    }\n    if (this.viewOptions.rightToLeft) {\n      percent = 1 - percent;\n    }\n    return percent * this.maxHandlePosition;\n  }\n\n  // Translate position to model value\n  private positionToValue(position: number): number {\n    let percent: number = position / this.maxHandlePosition;\n    if (this.viewOptions.rightToLeft) {\n      percent = 1 - percent;\n    }\n    let fn: PositionToValueFunction = ValueHelper.linearPositionToValue;\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.customPositionToValue)) {\n      fn = this.viewOptions.customPositionToValue;\n    } else if (this.viewOptions.logScale) {\n      fn = ValueHelper.logPositionToValue;\n    }\n    const value: number = fn(percent, this.viewOptions.floor, this.viewOptions.ceil);\n    return !ValueHelper.isNullOrUndefined(value) ? value : 0;\n  }\n\n  // Get the X-coordinate or Y-coordinate of an event\n  private getEventXY(event: MouseEvent|TouchEvent, targetTouchId?: number): number {\n    if (event instanceof MouseEvent) {\n      return this.viewOptions.vertical ? event.clientY : event.clientX;\n    }\n\n    let touchIndex: number = 0;\n    const touches: TouchList = event.touches;\n    if (!ValueHelper.isNullOrUndefined(targetTouchId)) {\n      for (let i: number = 0; i < touches.length; i++) {\n        if (touches[i].identifier === targetTouchId) {\n          touchIndex = i;\n          break;\n        }\n      }\n    }\n\n    // Return the target touch or if the target touch was not found in the event\n    // returns the coordinates of the first touch\n    return this.viewOptions.vertical ? touches[touchIndex].clientY : touches[touchIndex].clientX;\n  }\n\n  // Compute the event position depending on whether the slider is horizontal or vertical\n  private getEventPosition(event: MouseEvent|TouchEvent, targetTouchId?: number): number {\n    const sliderElementBoundingRect: ClientRect = this.elementRef.nativeElement.getBoundingClientRect();\n\n    const sliderPos: number = this.viewOptions.vertical ?\n      sliderElementBoundingRect.bottom : sliderElementBoundingRect.left;\n    let eventPos: number = 0;\n    if (this.viewOptions.vertical) {\n      eventPos = -this.getEventXY(event, targetTouchId) + sliderPos;\n    } else {\n      eventPos = this.getEventXY(event, targetTouchId) - sliderPos;\n    }\n    return eventPos * this.viewOptions.scale - this.handleHalfDimension;\n  }\n\n  // Get the handle closest to an event\n  private getNearestHandle(event: MouseEvent|TouchEvent): PointerType {\n    if (!this.range) {\n      return PointerType.Min;\n    }\n\n    const position: number = this.getEventPosition(event);\n    const distanceMin: number = Math.abs(position - this.minHandleElement.position);\n    const distanceMax: number = Math.abs(position - this.maxHandleElement.position);\n\n    if (distanceMin < distanceMax) {\n      return PointerType.Min;\n    } else if (distanceMin > distanceMax) {\n      return PointerType.Max;\n    } else if (!this.viewOptions.rightToLeft) {\n      // if event is at the same distance from min/max then if it's at left of minH, we return minH else maxH\n      return position < this.minHandleElement.position ? PointerType.Min : PointerType.Max;\n    }\n    // reverse in rtl\n    return position > this.minHandleElement.position ? PointerType.Min : PointerType.Max;\n  }\n\n  // Bind mouse and touch events to slider handles\n  private bindEvents(): void {\n    const draggableRange: boolean = this.viewOptions.draggableRange;\n\n    if (!this.viewOptions.onlyBindHandles) {\n      this.selectionBarElement.on('mousedown',\n        (event: MouseEvent): void => this.onBarStart(null, draggableRange, event, true, true, true)\n      );\n    }\n\n    if (this.viewOptions.draggableRangeOnly) {\n      this.minHandleElement.on('mousedown',\n        (event: MouseEvent): void => this.onBarStart(PointerType.Min, draggableRange, event, true, true)\n      );\n      this.maxHandleElement.on('mousedown',\n        (event: MouseEvent): void => this.onBarStart(PointerType.Max, draggableRange, event, true, true)\n      );\n    } else {\n      this.minHandleElement.on('mousedown',\n        (event: MouseEvent): void => this.onStart(PointerType.Min, event, true, true)\n      );\n\n      if (this.range) {\n        this.maxHandleElement.on('mousedown',\n          (event: MouseEvent): void => this.onStart(PointerType.Max, event, true, true)\n        );\n      }\n      if (!this.viewOptions.onlyBindHandles) {\n        this.fullBarElement.on('mousedown',\n          (event: MouseEvent): void => this.onStart(null, event, true, true, true)\n        );\n        this.ticksElement.on('mousedown',\n          (event: MouseEvent): void => this.onStart(null, event, true, true, true, true)\n        );\n      }\n    }\n\n    if (!this.viewOptions.onlyBindHandles) {\n      this.selectionBarElement.onPassive('touchstart',\n        (event: TouchEvent): void => this.onBarStart(null, draggableRange, event, true, true, true)\n      );\n    }\n    if (this.viewOptions.draggableRangeOnly) {\n      this.minHandleElement.onPassive('touchstart',\n        (event: TouchEvent): void => this.onBarStart(PointerType.Min, draggableRange, event, true, true)\n      );\n      this.maxHandleElement.onPassive('touchstart',\n        (event: TouchEvent): void => this.onBarStart(PointerType.Max, draggableRange, event, true, true)\n      );\n    } else {\n      this.minHandleElement.onPassive('touchstart',\n        (event: TouchEvent): void => this.onStart(PointerType.Min, event, true, true)\n      );\n      if (this.range) {\n        this.maxHandleElement.onPassive('touchstart',\n          (event: TouchEvent): void => this.onStart(PointerType.Max, event, true, true)\n        );\n      }\n      if (!this.viewOptions.onlyBindHandles) {\n        this.fullBarElement.onPassive('touchstart',\n          (event: TouchEvent): void => this.onStart(null, event, true, true, true)\n        );\n        this.ticksElement.onPassive('touchstart',\n          (event: TouchEvent): void => this.onStart(null, event, false, false, true, true)\n        );\n      }\n    }\n\n    if (this.viewOptions.keyboardSupport) {\n      this.minHandleElement.on('focus', (): void => this.onPointerFocus(PointerType.Min));\n      if (this.range) {\n        this.maxHandleElement.on('focus', (): void => this.onPointerFocus(PointerType.Max));\n      }\n    }\n  }\n\n  // Unbind mouse and touch events to slider handles\n  private unbindEvents(): void {\n    this.unsubscribeOnMove();\n    this.unsubscribeOnEnd();\n\n    for (const element of this.getAllSliderElements()) {\n      element.off();\n    }\n  }\n\n  private onBarStart(pointerType: PointerType, draggableRange: boolean, event: MouseEvent|TouchEvent,\n    bindMove: boolean, bindEnd: boolean, simulateImmediateMove?: boolean, simulateImmediateEnd?: boolean): void {\n    if (draggableRange) {\n      this.onDragStart(pointerType, event, bindMove, bindEnd);\n    } else {\n      this.onStart(pointerType, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd);\n    }\n  }\n\n  // onStart event handler\n  private onStart(pointerType: PointerType, event: MouseEvent|TouchEvent,\n      bindMove: boolean, bindEnd: boolean, simulateImmediateMove?: boolean, simulateImmediateEnd?: boolean): void {\n    event.stopPropagation();\n    // Only call preventDefault() when handling non-passive events (passive events don't need it)\n    if (!CompatibilityHelper.isTouchEvent(event) || !detectPassiveEvents.hasSupport) {\n      event.preventDefault();\n    }\n\n    // We have to do this in case the HTML where the sliders are on\n    // have been animated into view.\n    this.calculateViewDimensions();\n\n    if (ValueHelper.isNullOrUndefined(pointerType)) {\n      pointerType = this.getNearestHandle(event);\n    }\n\n    this.currentTrackingPointer = pointerType;\n\n    const pointerElement: SliderHandleDirective = this.getPointerElement(pointerType);\n    pointerElement.active = true;\n\n    if (this.viewOptions.keyboardSupport) {\n      pointerElement.focus();\n    }\n\n    if (bindMove) {\n      this.unsubscribeOnMove();\n\n      const onMoveCallback: ((e: MouseEvent|TouchEvent) => void) =\n        (e: MouseEvent|TouchEvent): void => this.dragging.active ? this.onDragMove(e) : this.onMove(e);\n\n      if (CompatibilityHelper.isTouchEvent(event)) {\n        this.onMoveEventListener = this.eventListenerHelper.attachPassiveEventListener(\n          document, 'touchmove', onMoveCallback, this.viewOptions.touchEventsInterval);\n      } else {\n        this.onMoveEventListener = this.eventListenerHelper.attachEventListener(\n          document, 'mousemove', onMoveCallback, this.viewOptions.mouseEventsInterval);\n      }\n    }\n\n    if (bindEnd) {\n      this.unsubscribeOnEnd();\n\n      const onEndCallback: ((e: MouseEvent|TouchEvent) => void) =\n        (e: MouseEvent|TouchEvent): void => this.onEnd(e);\n\n      if (CompatibilityHelper.isTouchEvent(event)) {\n        this.onEndEventListener = this.eventListenerHelper.attachPassiveEventListener(document, 'touchend', onEndCallback);\n      } else {\n        this.onEndEventListener = this.eventListenerHelper.attachEventListener(document, 'mouseup', onEndCallback);\n      }\n    }\n\n    this.userChangeStart.emit(this.getChangeContext());\n\n    if (CompatibilityHelper.isTouchEvent(event) && !ValueHelper.isNullOrUndefined((event as TouchEvent).changedTouches)) {\n      // Store the touch identifier\n      if (ValueHelper.isNullOrUndefined(this.touchId)) {\n        this.touchId = (event as TouchEvent).changedTouches[0].identifier;\n      }\n    }\n\n    // Click events, either with mouse or touch gesture are weird. Sometimes they result in full\n    // start, move, end sequence, and sometimes, they don't - they only invoke mousedown\n    // As a workaround, we simulate the first move event and the end event if it's necessary\n    if (simulateImmediateMove) {\n      this.onMove(event, true);\n    }\n\n    if (simulateImmediateEnd) {\n      this.onEnd(event);\n    }\n  }\n\n  // onMove event handler\n  private onMove(event: MouseEvent|TouchEvent, fromTick?: boolean): void {\n    let touchForThisSlider: Touch = null;\n\n    if (CompatibilityHelper.isTouchEvent(event)) {\n      const changedTouches: TouchList = (event as TouchEvent).changedTouches;\n      for (let i: number = 0; i < changedTouches.length; i++) {\n        if (changedTouches[i].identifier === this.touchId) {\n          touchForThisSlider = changedTouches[i];\n          break;\n        }\n      }\n\n      if (ValueHelper.isNullOrUndefined(touchForThisSlider)) {\n        return;\n      }\n    }\n\n    const newPos: number = !ValueHelper.isNullOrUndefined(touchForThisSlider)\n      ? this.getEventPosition(event, touchForThisSlider.identifier)\n      : this.getEventPosition(event);\n    let newValue: number;\n    const ceilValue: number = this.viewOptions.rightToLeft\n        ? this.viewOptions.floor\n        : this.viewOptions.ceil;\n    const floorValue: number = this.viewOptions.rightToLeft ? this.viewOptions.ceil : this.viewOptions.floor;\n\n    if (newPos <= 0) {\n      newValue = floorValue;\n    } else if (newPos >= this.maxHandlePosition) {\n      newValue = ceilValue;\n    } else {\n      newValue = this.positionToValue(newPos);\n      if (fromTick && !ValueHelper.isNullOrUndefined(this.viewOptions.tickStep)) {\n        newValue = this.roundStep(newValue, this.viewOptions.tickStep);\n      } else {\n        newValue = this.roundStep(newValue);\n      }\n    }\n    this.positionTrackingHandle(newValue);\n  }\n\n  private onEnd(event: MouseEvent|TouchEvent): void {\n    if (CompatibilityHelper.isTouchEvent(event)) {\n      const changedTouches: TouchList = (event as TouchEvent).changedTouches;\n      if (changedTouches[0].identifier !== this.touchId) {\n        return;\n      }\n    }\n\n    this.touchId = null;\n\n    if (!this.viewOptions.keyboardSupport) {\n      this.minHandleElement.active = false;\n      this.maxHandleElement.active = false;\n      this.currentTrackingPointer = null;\n    }\n    this.dragging.active = false;\n\n    this.unsubscribeOnMove();\n    this.unsubscribeOnEnd();\n\n    this.userChangeEnd.emit(this.getChangeContext());\n  }\n\n  private onPointerFocus(pointerType: PointerType): void {\n    const pointerElement: SliderHandleDirective = this.getPointerElement(pointerType);\n    pointerElement.on('blur', (): void => this.onPointerBlur(pointerElement));\n    pointerElement.on('keydown', (event: KeyboardEvent): void => this.onKeyboardEvent(event));\n    pointerElement.on('keyup', (): void => this.onKeyUp());\n    pointerElement.active = true;\n\n    this.currentTrackingPointer = pointerType;\n    this.currentFocusPointer = pointerType;\n    this.firstKeyDown = true;\n  }\n\n  private onKeyUp(): void {\n    this.firstKeyDown = true;\n    this.userChangeEnd.emit(this.getChangeContext());\n  }\n\n  private onPointerBlur(pointer: SliderHandleDirective): void {\n    pointer.off('blur');\n    pointer.off('keydown');\n    pointer.off('keyup');\n    pointer.active = false;\n    if (ValueHelper.isNullOrUndefined(this.touchId)) {\n      this.currentTrackingPointer = null;\n      this.currentFocusPointer = null;\n    }\n  }\n\n  private getKeyActions(currentValue: number): {[key: string]: number} {\n    const valueRange: number = this.viewOptions.ceil - this.viewOptions.floor;\n\n    let increaseStep: number = currentValue + this.viewOptions.step;\n    let decreaseStep: number = currentValue - this.viewOptions.step;\n    let increasePage: number = currentValue + valueRange / 10;\n    let decreasePage: number = currentValue - valueRange / 10;\n\n    if (this.viewOptions.reversedControls) {\n      increaseStep = currentValue - this.viewOptions.step;\n      decreaseStep = currentValue + this.viewOptions.step;\n      increasePage = currentValue - valueRange / 10;\n      decreasePage = currentValue + valueRange / 10;\n    }\n\n    // Left to right default actions\n    const actions: {[key: string]: number} = {\n      UP: increaseStep,\n      DOWN: decreaseStep,\n      LEFT: decreaseStep,\n      RIGHT: increaseStep,\n      PAGEUP: increasePage,\n      PAGEDOWN: decreasePage,\n      HOME: this.viewOptions.reversedControls ? this.viewOptions.ceil : this.viewOptions.floor,\n      END: this.viewOptions.reversedControls ? this.viewOptions.floor : this.viewOptions.ceil,\n    };\n    // right to left means swapping right and left arrows\n    if (this.viewOptions.rightToLeft) {\n      actions.LEFT = increaseStep;\n      actions.RIGHT = decreaseStep;\n      // right to left and vertical means we also swap up and down\n      if (this.viewOptions.vertical) {\n        actions.UP = decreaseStep;\n        actions.DOWN = increaseStep;\n      }\n    }\n    return actions;\n  }\n\n  private onKeyboardEvent(event: KeyboardEvent): void {\n    const currentValue: number = this.getCurrentTrackingValue();\n    const keyCode: number = !ValueHelper.isNullOrUndefined(event.keyCode)\n      ? event.keyCode\n      : event.which;\n    const keys: {[keyCode: number]: string} = {\n        38: 'UP',\n        40: 'DOWN',\n        37: 'LEFT',\n        39: 'RIGHT',\n        33: 'PAGEUP',\n        34: 'PAGEDOWN',\n        36: 'HOME',\n        35: 'END',\n      };\n    const actions: {[key: string]: number} = this.getKeyActions(currentValue);\n    const key: string = keys[keyCode];\n    const action: number = actions[key];\n\n    if (ValueHelper.isNullOrUndefined(action) || ValueHelper.isNullOrUndefined(this.currentTrackingPointer)) {\n      return;\n    }\n    event.preventDefault();\n\n    if (this.firstKeyDown) {\n      this.firstKeyDown = false;\n      this.userChangeStart.emit(this.getChangeContext());\n    }\n\n    const actionValue: number = MathHelper.clampToRange(action, this.viewOptions.floor, this.viewOptions.ceil);\n    const newValue: number = this.roundStep(actionValue);\n    if (!this.viewOptions.draggableRangeOnly) {\n      this.positionTrackingHandle(newValue);\n    } else {\n      const difference: number = this.viewHighValue - this.viewLowValue;\n      let newMinValue: number;\n      let newMaxValue: number;\n\n      if (this.currentTrackingPointer === PointerType.Min) {\n        newMinValue = newValue;\n        newMaxValue = newValue + difference;\n        if (newMaxValue > this.viewOptions.ceil) {\n          newMaxValue = this.viewOptions.ceil;\n          newMinValue = newMaxValue - difference;\n        }\n      } else if (this.currentTrackingPointer === PointerType.Max) {\n        newMaxValue = newValue;\n        newMinValue = newValue - difference;\n        if (newMinValue < this.viewOptions.floor) {\n          newMinValue = this.viewOptions.floor;\n          newMaxValue = newMinValue + difference;\n        }\n      }\n      this.positionTrackingBar(newMinValue, newMaxValue);\n    }\n  }\n\n  // onDragStart event handler, handles dragging of the middle bar\n  private onDragStart(pointerType: PointerType, event: MouseEvent|TouchEvent,\n    bindMove: boolean, bindEnd: boolean): void {\n    const position: number = this.getEventPosition(event);\n\n    this.dragging = new Dragging();\n    this.dragging.active = true;\n    this.dragging.value = this.positionToValue(position);\n    this.dragging.difference = this.viewHighValue - this.viewLowValue;\n    this.dragging.lowLimit = this.viewOptions.rightToLeft\n        ? this.minHandleElement.position - position\n        : position - this.minHandleElement.position;\n    this.dragging.highLimit = this.viewOptions.rightToLeft\n        ? position - this.maxHandleElement.position\n        : this.maxHandleElement.position - position;\n\n    this.onStart(pointerType, event, bindMove, bindEnd);\n  }\n\n  /** Get min value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft */\n  private getMinValue(newPos: number, outOfBounds: boolean, isAbove: boolean): number {\n    const isRTL: boolean = this.viewOptions.rightToLeft;\n    let value: number = null;\n\n    if (outOfBounds) {\n      if (isAbove) {\n        value = isRTL\n          ? this.viewOptions.floor\n          : this.viewOptions.ceil - this.dragging.difference;\n      } else {\n        value = isRTL\n          ? this.viewOptions.ceil - this.dragging.difference\n          : this.viewOptions.floor;\n      }\n    } else {\n      value = isRTL\n        ? this.positionToValue(newPos + this.dragging.lowLimit)\n        : this.positionToValue(newPos - this.dragging.lowLimit);\n    }\n    return this.roundStep(value);\n  }\n\n  /** Get max value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft */\n  private getMaxValue(newPos: number, outOfBounds: boolean, isAbove: boolean): number {\n    const isRTL: boolean = this.viewOptions.rightToLeft;\n    let value: number = null;\n\n    if (outOfBounds) {\n      if (isAbove) {\n        value = isRTL\n          ? this.viewOptions.floor + this.dragging.difference\n          : this.viewOptions.ceil;\n      } else {\n        value = isRTL\n          ? this.viewOptions.ceil\n          : this.viewOptions.floor + this.dragging.difference;\n      }\n    } else {\n      if (isRTL) {\n        value =\n          this.positionToValue(newPos + this.dragging.lowLimit) +\n          this.dragging.difference;\n      } else {\n        value =\n          this.positionToValue(newPos - this.dragging.lowLimit) +\n          this.dragging.difference;\n      }\n    }\n\n    return this.roundStep(value);\n  }\n\n  private onDragMove(event?: MouseEvent|TouchEvent): void {\n    const newPos: number = this.getEventPosition(event);\n\n    let ceilLimit: number,\n        floorLimit: number,\n        floorHandleElement: SliderHandleDirective,\n        ceilHandleElement: SliderHandleDirective;\n    if (this.viewOptions.rightToLeft) {\n      ceilLimit = this.dragging.lowLimit;\n      floorLimit = this.dragging.highLimit;\n      floorHandleElement = this.maxHandleElement;\n      ceilHandleElement = this.minHandleElement;\n    } else {\n      ceilLimit = this.dragging.highLimit;\n      floorLimit = this.dragging.lowLimit;\n      floorHandleElement = this.minHandleElement;\n      ceilHandleElement = this.maxHandleElement;\n    }\n\n    const isUnderFloorLimit: boolean = (newPos <= floorLimit);\n    const isOverCeilLimit: boolean = (newPos >= this.maxHandlePosition - ceilLimit);\n\n    let newMinValue: number;\n    let newMaxValue: number;\n    if (isUnderFloorLimit) {\n      if (floorHandleElement.position === 0) {\n        return;\n      }\n      newMinValue = this.getMinValue(newPos, true, false);\n      newMaxValue = this.getMaxValue(newPos, true, false);\n    } else if (isOverCeilLimit) {\n      if (ceilHandleElement.position === this.maxHandlePosition) {\n        return;\n      }\n      newMaxValue = this.getMaxValue(newPos, true, true);\n      newMinValue = this.getMinValue(newPos, true, true);\n    } else {\n      newMinValue = this.getMinValue(newPos, false, false);\n      newMaxValue = this.getMaxValue(newPos, false, false);\n    }\n\n    this.positionTrackingBar(newMinValue, newMaxValue);\n  }\n\n  // Set the new value and position for the entire bar\n  private positionTrackingBar(newMinValue: number, newMaxValue: number): void {\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) &&\n        newMinValue < this.viewOptions.minLimit) {\n      newMinValue = this.viewOptions.minLimit;\n      newMaxValue = MathHelper.roundToPrecisionLimit(newMinValue + this.dragging.difference, this.viewOptions.precisionLimit);\n    }\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) &&\n        newMaxValue > this.viewOptions.maxLimit) {\n      newMaxValue = this.viewOptions.maxLimit;\n      newMinValue = MathHelper.roundToPrecisionLimit(newMaxValue - this.dragging.difference, this.viewOptions.precisionLimit);\n    }\n\n    this.viewLowValue = newMinValue;\n    this.viewHighValue = newMaxValue;\n    this.applyViewChange();\n    this.updateHandles(PointerType.Min, this.valueToPosition(newMinValue));\n    this.updateHandles(PointerType.Max, this.valueToPosition(newMaxValue));\n  }\n\n  // Set the new value and position to the current tracking handle\n  private positionTrackingHandle(newValue: number): void {\n    newValue = this.applyMinMaxLimit(newValue);\n    if (this.range) {\n      if (this.viewOptions.pushRange) {\n        newValue = this.applyPushRange(newValue);\n      } else {\n        if (this.viewOptions.noSwitching) {\n          if (this.currentTrackingPointer === PointerType.Min &&\n              newValue > this.viewHighValue) {\n            newValue = this.applyMinMaxRange(this.viewHighValue);\n          } else if (this.currentTrackingPointer === PointerType.Max &&\n                     newValue < this.viewLowValue) {\n            newValue = this.applyMinMaxRange(this.viewLowValue);\n          }\n        }\n        newValue = this.applyMinMaxRange(newValue);\n        /* This is to check if we need to switch the min and max handles */\n        if (this.currentTrackingPointer === PointerType.Min && newValue > this.viewHighValue) {\n          this.viewLowValue = this.viewHighValue;\n          this.applyViewChange();\n          this.updateHandles(PointerType.Min, this.maxHandleElement.position);\n          this.updateAriaAttributes();\n          this.currentTrackingPointer = PointerType.Max;\n          this.minHandleElement.active = false;\n          this.maxHandleElement.active = true;\n          if (this.viewOptions.keyboardSupport) {\n            this.maxHandleElement.focus();\n          }\n        } else if (this.currentTrackingPointer === PointerType.Max &&\n                   newValue < this.viewLowValue) {\n          this.viewHighValue = this.viewLowValue;\n          this.applyViewChange();\n          this.updateHandles(PointerType.Max, this.minHandleElement.position);\n          this.updateAriaAttributes();\n          this.currentTrackingPointer = PointerType.Min;\n          this.maxHandleElement.active = false;\n          this.minHandleElement.active = true;\n          if (this.viewOptions.keyboardSupport) {\n            this.minHandleElement.focus();\n          }\n        }\n      }\n    }\n\n    if (this.getCurrentTrackingValue() !== newValue) {\n      if (this.currentTrackingPointer === PointerType.Min) {\n        this.viewLowValue = newValue;\n        this.applyViewChange();\n      } else if (this.currentTrackingPointer === PointerType.Max) {\n        this.viewHighValue = newValue;\n        this.applyViewChange();\n      }\n      this.updateHandles(this.currentTrackingPointer, this.valueToPosition(newValue));\n      this.updateAriaAttributes();\n    }\n  }\n\n  private applyMinMaxLimit(newValue: number): number {\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) && newValue < this.viewOptions.minLimit) {\n      return this.viewOptions.minLimit;\n    }\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) && newValue > this.viewOptions.maxLimit) {\n      return this.viewOptions.maxLimit;\n    }\n    return newValue;\n  }\n\n  private applyMinMaxRange(newValue: number): number {\n    const oppositeValue: number = (this.currentTrackingPointer === PointerType.Min)\n      ? this.viewHighValue\n      : this.viewLowValue;\n    const difference: number = Math.abs(newValue - oppositeValue);\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.minRange)) {\n      if (difference < this.viewOptions.minRange) {\n        if (this.currentTrackingPointer === PointerType.Min) {\n          return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.minRange, this.viewOptions.precisionLimit);\n        } else if (this.currentTrackingPointer === PointerType.Max) {\n          return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.minRange, this.viewOptions.precisionLimit);\n        }\n      }\n    }\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxRange)) {\n      if (difference > this.viewOptions.maxRange) {\n        if (this.currentTrackingPointer === PointerType.Min) {\n          return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.maxRange, this.viewOptions.precisionLimit);\n        } else if (this.currentTrackingPointer === PointerType.Max) {\n          return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.maxRange, this.viewOptions.precisionLimit);\n        }\n      }\n    }\n    return newValue;\n  }\n\n  private applyPushRange(newValue: number): number {\n    const difference: number = (this.currentTrackingPointer === PointerType.Min)\n          ? this.viewHighValue - newValue\n          : newValue - this.viewLowValue;\n    const minRange: number = (!ValueHelper.isNullOrUndefined(this.viewOptions.minRange))\n          ? this.viewOptions.minRange\n          : this.viewOptions.step;\n    const maxRange: number = this.viewOptions.maxRange;\n    // if smaller than minRange\n    if (difference < minRange) {\n      if (this.currentTrackingPointer === PointerType.Min) {\n        this.viewHighValue = MathHelper.roundToPrecisionLimit(\n          Math.min(newValue + minRange, this.viewOptions.ceil), this.viewOptions.precisionLimit);\n        newValue = MathHelper.roundToPrecisionLimit(this.viewHighValue - minRange, this.viewOptions.precisionLimit);\n        this.applyViewChange();\n        this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue));\n      } else if (this.currentTrackingPointer === PointerType.Max) {\n        this.viewLowValue = MathHelper.roundToPrecisionLimit(\n          Math.max(newValue - minRange, this.viewOptions.floor), this.viewOptions.precisionLimit);\n        newValue = MathHelper.roundToPrecisionLimit(this.viewLowValue + minRange, this.viewOptions.precisionLimit);\n        this.applyViewChange();\n        this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));\n      }\n      this.updateAriaAttributes();\n    } else if (!ValueHelper.isNullOrUndefined(maxRange) && difference > maxRange) {\n      // if greater than maxRange\n      if (this.currentTrackingPointer === PointerType.Min) {\n        this.viewHighValue = MathHelper.roundToPrecisionLimit(newValue + maxRange, this.viewOptions.precisionLimit);\n        this.applyViewChange();\n        this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue)\n        );\n      } else if (this.currentTrackingPointer === PointerType.Max) {\n        this.viewLowValue = MathHelper.roundToPrecisionLimit(newValue - maxRange, this.viewOptions.precisionLimit);\n        this.applyViewChange();\n        this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));\n      }\n      this.updateAriaAttributes();\n    }\n    return newValue;\n  }\n\n  private getChangeContext(): ChangeContext {\n    const changeContext: ChangeContext = new ChangeContext();\n    changeContext.pointerType = this.currentTrackingPointer;\n    changeContext.value = +this.value;\n    if (this.range) {\n      changeContext.highValue = +this.highValue;\n    }\n    return changeContext;\n  }\n}\n","import { Component, Input, TemplateRef } from '@angular/core';\n\n@Component({\n  selector: 'ng5-slider-tooltip-wrapper',\n  template: `<ng-container *ngIf=\"template\">\n  <ng-template *ngTemplateOutlet=\"template; context: {tooltip: tooltip, placement: placement, content: content}\"></ng-template>\n</ng-container>\n\n<ng-container *ngIf=\"!template\">\n  <div class=\"ng5-slider-inner-tooltip\" [attr.title]=\"tooltip\" [attr.data-tooltip-placement]=\"placement\">\n    {{content}}\n  </div>\n</ng-container>`,\n  styles: [`.ng5-slider-inner-tooltip{height:100%}`]\n})\nexport class TooltipWrapperComponent {\n  @Input()\n  template: TemplateRef<any>;\n\n  @Input()\n  tooltip: string;\n\n  @Input()\n  placement: string;\n\n  @Input()\n  content: string;\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { SliderComponent } from './slider.component';\nimport { SliderElementDirective } from './slider-element.directive';\nimport { SliderHandleDirective } from './slider-handle.directive';\nimport { SliderLabelDirective } from './slider-label.directive';\nimport { TooltipWrapperComponent } from './tooltip-wrapper.component';\n\n/**\n * Ng5Slider module\n *\n * The module exports the slider component\n */\n@NgModule({\n  imports: [\n    CommonModule\n  ],\n  declarations: [\n    SliderComponent,\n    SliderElementDirective,\n    SliderHandleDirective,\n    SliderLabelDirective,\n    TooltipWrapperComponent\n  ],\n  exports: [\n    SliderComponent\n  ]\n})\nexport class Ng5SliderModule { }\n"]},"metadata":{},"sourceType":"module"}