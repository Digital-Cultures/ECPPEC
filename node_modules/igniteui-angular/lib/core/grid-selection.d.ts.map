{"version":3,"file":"grid-selection.d.ts","sources":["grid-selection.d.ts"],"names":[],"mappings":"AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA","sourcesContent":["import { EventEmitter, NgZone } from '@angular/core';\nimport { IGridEditEventArgs } from '../grids/grid-base.component';\nexport interface GridSelectionRange {\n    rowStart: number;\n    rowEnd: number;\n    columnStart: string | number;\n    columnEnd: string | number;\n}\nexport interface ISelectionNode {\n    row: number;\n    column: number;\n    layout?: IMultiRowLayoutNode;\n    isSummaryRow?: boolean;\n}\nexport interface IMultiRowLayoutNode {\n    rowStart: number;\n    colStart: number;\n    rowEnd: number;\n    colEnd: number;\n    columnVisibleIndex: number;\n}\ninterface ISelectionKeyboardState {\n    node: null | ISelectionNode;\n    shift: boolean;\n    range: GridSelectionRange;\n    active: boolean;\n}\ninterface ISelectionPointerState extends ISelectionKeyboardState {\n    ctrl: boolean;\n    primaryButton: boolean;\n}\ndeclare type SelectionState = ISelectionKeyboardState | ISelectionPointerState;\nexport declare class IgxRow {\n    id: any;\n    index: number;\n    data: any;\n    transactionState: any;\n    state: any;\n    newData: any;\n    constructor(id: any, index: number, data: any);\n    createEditEventArgs(): IGridEditEventArgs;\n}\nexport declare class IgxCell {\n    id: any;\n    rowIndex: number;\n    column: any;\n    value: any;\n    editValue: any;\n    rowData: any;\n    primaryKey: any;\n    state: any;\n    constructor(id: any, rowIndex: number, column: any, value: any, editValue: any, rowData: any);\n    castToNumber(value: any): any;\n    createEditEventArgs(): IGridEditEventArgs;\n}\nexport declare class IgxGridCRUDService {\n    grid: any;\n    cell: IgxCell | null;\n    row: IgxRow | null;\n    createCell(cell: any): IgxCell;\n    createRow(cell: IgxCell): IgxRow;\n    sameRow(rowID: any): boolean;\n    sameCell(cell: IgxCell): boolean;\n    readonly inEditMode: boolean;\n    readonly rowEditing: boolean;\n    readonly primaryKey: any;\n    beginRowEdit(): void;\n    endRowEdit(): void;\n    begin(cell: any): void;\n    end(): void;\n    isInEditMode(rowIndex: number, columnIndex: number): boolean;\n}\nexport declare class IgxGridSelectionService {\n    private zone;\n    grid: any;\n    dragMode: boolean;\n    activeElement: ISelectionNode | null;\n    keyboardState: ISelectionKeyboardState;\n    pointerState: ISelectionPointerState;\n    selection: Map<number, Set<number>>;\n    temp: Map<number, Set<number>>;\n    _ranges: Set<string>;\n    _selectionRange: Range;\n    rowSelection: Set<any>;\n    private allRowsSelected;\n    /**\n     * Returns the current selected ranges in the grid from both\n     * keyboard and pointer interactions\n     */\n    readonly ranges: GridSelectionRange[];\n    primaryButton: boolean;\n    constructor(zone: NgZone);\n    /**\n     * Resets the keyboard state\n     */\n    initKeyboardState(): void;\n    /**\n     * Resets the pointer state\n     */\n    initPointerState(): void;\n    /**\n     * Adds a single node.\n     * Single clicks | Ctrl + single clicks on cells is the usual case.\n     */\n    add(node: ISelectionNode, addToRange?: boolean): void;\n    /**\n     * Adds the active keyboard range selection (if any) to the `ranges` meta.\n     */\n    addKeyboardRange(): void;\n    remove(node: ISelectionNode): void;\n    isInMap(node: ISelectionNode): boolean;\n    selected(node: ISelectionNode): boolean;\n    isActiveNode(node: ISelectionNode): boolean;\n    isActiveLayout(current: IMultiRowLayoutNode, target: IMultiRowLayoutNode): boolean;\n    addRangeMeta(node: ISelectionNode, state?: SelectionState): void;\n    removeRangeMeta(node: ISelectionNode, state?: SelectionState): void;\n    /**\n     * Generates a new selection range from the given `node`.\n     * If `state` is passed instead it will generate the range based on the passed `node`\n     * and the start node of the `state`.\n     */\n    generateRange(node: ISelectionNode, state?: SelectionState): GridSelectionRange;\n    /**\n     *\n     */\n    keyboardStateOnKeydown(node: ISelectionNode, shift: boolean, shiftTab: boolean): void;\n    keyboardStateOnFocus(node: ISelectionNode, emitter: EventEmitter<GridSelectionRange>, dom: any): void;\n    pointerDown(node: ISelectionNode, shift: boolean, ctrl: boolean): void;\n    pointerDownShiftKey(node: ISelectionNode): void;\n    mergeMap(target: Map<number, Set<number>>, source: Map<number, Set<number>>): void;\n    pointerEnter(node: ISelectionNode, event: PointerEvent): boolean;\n    pointerUp(node: ISelectionNode, emitter: EventEmitter<GridSelectionRange>): boolean;\n    selectRange(node: ISelectionNode, state: SelectionState, collection?: Map<number, Set<number>>): void;\n    dragSelect(node: ISelectionNode, state: SelectionState): void;\n    clear(clearAcriveEl?: boolean): void;\n    clearTextSelection(): void;\n    restoreTextSelection(): void;\n    /**\n     * (╯°□°）╯︵ ┻━┻\n     * Chrome and Chromium don't care about the active\n     * range after keyboard navigation, thus this.\n     */\n    _moveSelectionChrome(node: Node): void;\n    /** Returns array of the selected row id's. */\n    getSelectedRows(): Array<any>;\n    /** Clears row selection, if filtering is applied clears only selected rows from filtered data. */\n    clearRowSelection(event?: any): void;\n    /** Select all rows, if filtering is applied select only from filtered data. */\n    selectAllRows(event?: any): void;\n    /** Select the specified row and emit event. */\n    selectRowById(rowID: any, clearPrevSelection?: any, event?: any): void;\n    /** Deselect the specified row and emit event. */\n    deselectRow(rowID: any, event?: any): void;\n    /** Select specified rows. No event is emitted. */\n    selectRowsWithNoEvent(rowIDs: any[], clearPrevSelection?: any): void;\n    /** Deselect specified rows. No event is emitted. */\n    deselectRowsWithNoEvent(rowIDs: any[]): void;\n    isRowSelected(rowID: any): boolean;\n    /** Select range from last selected row to the current specified row.*/\n    selectMultipleRows(rowID: any, rowData: any, event?: any): void;\n    areAllRowSelected(): boolean;\n    hasSomeRowSelected(): boolean;\n    readonly filteredSelectedRowIds: any[];\n    emitRowSelectionEvent(newSelection: any, added: any, removed: any, event?: any): boolean;\n    getRowDataById(rowID: any): Object;\n    getRowIDs(data: any): Array<any>;\n    clearHeaderCBState(): void;\n    /**Clear rowSelection and update checkbox state*/\n    clearAllSelectedRows(): void;\n    /** Returns all data in the grid, with applied filtering and sorting and without deleted rows. */\n    readonly allData: Array<any>;\n    private areEqualCollections;\n    private isFilteringApplied;\n    private isRowDeleted;\n}\nexport declare function isChromium(): boolean;\nexport {};\n"]}